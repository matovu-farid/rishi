[{"text":"Authors of Head First Software Architecture\nRaju Gandhi\nRaju is an architect, consultant, author, and teacher and a regularly invited speaker at conferences around the world. He believes in keeping things simple, and his approach is always to understand and explain the “why,” as opposed to the “how.” He lives in Columbus, Ohio, with his wonderful wife, Michelle; their sons, Mason and Micah; their daughter, Delphine; and three furry family members, Buddy, Skye, and Princess Zara. You can find his contact information at RajuGandhi.com.\nMark Richards","metadata":{"id":7381992659790760,"pageNumber":5,"bookId":1}},{"text":"Mark is an experienced hands-on software architect and the founder of DeveloperToArchitect.com, a free website devoted to helping developers in their journeys to becoming software architects. He has been in the software industry since 1983 and has significant experience and expertise in application, integration, and enterprise architecture. Mark has authored numerous technical books and videos, including Fundamentals of Software Architecture and Software Architecture: The Hard Parts (O’Reilly), co-authored with Neal Ford. Mark also does training and has spoken at hundreds of conferences and user groups around the world.\nNeal Ford","metadata":{"id":6416473637841565,"pageNumber":5,"bookId":1}},{"text":"Neal Ford is director, software architect, and meme wrangler at ThoughtWorks, a global IT consultancy with a focus on end-to-end software development and delivery. He is also the designer and developer of many applications, articles, and video presentations and the author and/or editor of an increasingly large number of books, spanning a variety of subjects and technologies. His professional focus is designing and building large-scale enterprise applications. He is also an internationally acclaimed speaker who has spoken at more than 300 developer conferences worldwide and has delivered more than 2,000 presentations.","metadata":{"id":2332957039275782,"pageNumber":5,"bookId":1}},{"text":"Table of Contents (the real thing)\nHow to use this Book: Intro\nBecause software architecture is hard, your brain will trick you into thinking you can’t learn it. Your brain’s thinking, ”Better to focus on more important things, like what to eat for lunch and whether pigs have wings.” The good news is that you CAN trick your brain into thinking software architecture is an important skill to learn, and in this chapter we’re going to show you just how to do that.\n“Who is this book for?”\n“We know what you’re thinking”\n“We know what your brain is thinking”\n“Metacognition: Thinking about thinking”\n“Here’s what WE did”\n“Here’s what YOU can do to bend your brain into submission”\n“Read me”\n“Do it yourself chapters”\n“The technical review team”\n“Joint acknowledgments”\n“Individual acknowledgments”\nChapter 1","metadata":{"id":415851667290782,"pageNumber":6,"bookId":1}},{"text":"Software architecture is fundamental to the success of your system. This chapter demystifies software architecture. You’ll gain an understanding of architectural dimensions and the differences between architecture and design. Why is this important? Because understanding and applying architectural practices helps you build more effective and correct software systems—systems that not only function better, but also meet the needs and concerns of the business and continue to operate as your business and technical environments undergo constant change. So, without further delay, let’s get started.\n“Building your understanding of software architecture”\n“Building plans and software architecture”\n“The dimensions of software architecture”\n“Puzzling out the dimensions”\n“The first dimension: Architectural characteristics”\n“The second dimension: Architectural decisions”\n“The third dimension: Logical components”\n“The fourth dimension: Architectural styles”\n“A design perspective”\n“An architectural perspective”\n“The spectrum between architecture and design”\n“Where along the spectrum does your decision fall?”\n“Strategic versus tactical”\n“High versus low levels of effort”\n“Significant versus less-significant trade-offs”\n“Putting it all together”\n“You made it!”\nChapter 2","metadata":{"id":827350179964518,"pageNumber":6,"bookId":1}},{"text":"What does your architecture need to support? Architectural characteristics (the capabilities of an architecture) are the fundamental building blocks of any system. Without them, you cannot make architectural decisions, select an architectural style, or in many cases even create a logical architecture. In this chapter you’ll learn how to define some of the more common characteristics (like scalability, reliability, and testability), how they influence a software architecture, how they help you make architectural decisions, and how to identify which ones are important for your particular situation. Ready to add some capabilities to your software architecture?\n“Causing Lafter”\n“Cubicle conversation”\n“What are architectural characteristics?”\n“Defining architectural characteristics”\n“Characteristics are nondomain design considerations”\n“Characteristics influence architectural structure”\n“Limit characteristics to prevent overengineering”\n“Consider explicit and implicit capabilities”\n“The International Zoo of “-ilities””\n“Process architectural characteristics”\n“Structural architectural characteristics”\n“Operational architectural characteristics”\n“Cross-cutting architectural characteristics”\n“Sourcing architectural characteristics from the problem domain”\n“Sourcing architectural characteristics from environmental awareness”\n“Sourcing architectural characteristics from holistic domain knowledge”\n“Composite architectural characteristics”\n“Priorities are contextual”\n“Lost in translation”\n“Architectural characteristics and logical components”\n“Balancing domain considerations and architectural characteristics”\n“Limiting architectural characteristics”\nChapter 3","metadata":{"id":1233270302824805,"pageNumber":6,"bookId":1}},{"text":"What happens when there are no “best practices”? The nice thing about best practices is that they’re relatively risk-free ways to achieve certain goals. They’re called “best” (not “better” or “good”) for a reason—you know they work, so why not just use them? But one thing you’ll quickly learn about software architecture is that it has no best practices. You’ll have to analyze every situation carefully to make a decision, and you’ll need to communicate not just the “what” of the decision, but the “why.”\nSo, how do you navigate this new frontier? Fortunately, you have the laws of software architecture to guide you. This chapter shows you how to analyze trade-offs as you make decisions. We’ll also show you how to create architectural decision records to capture the “hows” and “whys” of decisions. By the end of this chapter, you’ll have the tools to navigate the uncertain territory that is software architecture.\n“It starts with a sneaker app”\n“What do we know so far?”\n“Communicating with downstream services”\n“Analyzing trade-offs”\n“Trade-off analysis: Queue edition”\n“Trade-off analysis: Topic edition”\n“The first law of software architecture”\n“It always comes back to trade-offs”\n“Making an architectural decision”\n“What else makes a decision architectural?”\n“The second law of software architecture”\n“Architectural decision records (ADRs)”\n“Writing ADRs: Getting the title right”\n“Writing ADRs: What’s your status?”\n“Writing ADRs: Establishing the context”\n“Writing ADRs: Communicating the decision”\n“Writing ADRs: Considering the consequences”\n“Writing ADRs: Ensuring governance”\n“Writing ADRs: Closing notes”\n“The benefits of ADRs”\n“Two Many Sneakers is a success”\nChapter 4\nReady to start creating an architecture? It’s not as easy as it sounds—and if you don’t do it correctly, your software system could come crumbling to the ground, just like a poorly designed skyscraper or bridge.\nIn this chapter we’ll show you several approaches for identifying and creating logical components, the functional building blocks of a system that describe how its pieces all fit together. Using the techniques described in this chapter will help you to create a solid architecture—a foundation upon which you can build a successful software system.\nPut on your hard hat and gloves, get your tools ready, and let’s get started.\n“Logical components revisited”\n???\n“Adventurous Auctions goes online”\n“Logical versus physical architecture”\n“Creating a logical architecture”\n“Step 1: Identifying initial core components”\n“Workflow approach”\n“Actor/action approach”\n“The entity trap”\n“Step 2: Assign requirements”\n“Step 3: Analyze roles and responsibilities”\n“Sticking to cohesion”\n“Step 4: Analyze characteristics”\n“The Bid Capture component”\n“Component coupling”\n“Afferent coupling”\n“Efferent coupling”\n“Measuring coupling”\n“A tightly coupled system”\n“Applying the Law of Demeter”\n“A balancing act”\n“Some final words about components”\n???\nChapter 5","metadata":{"id":4151002675852599,"pageNumber":6,"bookId":1}},{"text":"There are lots of different architectural styles out there. Each one exists for a reason and has its own philosophy about how and when it should be used. Understanding a style’s philosophy will help you judge whether it’s the right one for your domain. This chapter gives you a framework for the different kinds of architectural styles (which we’ll be diving into for the remainder of this book), to help you make sense of these and all the other architectural styles you’ll encounter as a software architect.\nLet’s fill in that final piece of the puzzle, shall we?\n“There are lots of architectural styles”\n“The world of architectural styles”\n“Partitioning: Technical versus domain”\n“Deployment model: Monolithic versus distributed”\n“Monolithic deployment models: The pros”\n“Monolithic: The cons”\n“Distributed deployment models: The pros”\n“Distributed deployment models: The cons”\n“And that’s a wrap!”\nChapter 6","metadata":{"id":7081560651232102,"pageNumber":6,"bookId":1}},{"text":"What if your problem is simple and time is of the essence? Should you even bother with architecture? It depends on how long you want to keep what you build. If it’s disposable, throw caution to the wind. If not, then choose the simplest architecture that still provides some measurable organization and benefit, without imposing many constraints on speed of delivery. The layered architecture has become that architecture because it’s easy to understand and implement, leveraging design patterns developers already know. Let’s peel back the layers of this architecture.\n“Naan & Pop: Gathering requirements”\n“Design patterns redux”\n“Layering MVC”\n“Layering it on”\n“Translating layers into code”\n“Domains, components, and layers”\n“Drivers for layered architecture”\n“Layers, meet the real world: Physical architectures”\n“Physical architecture trade-offs”\n“One final caveat about domain changes”\n“Layered architecture superpowers”\n“Layered architecture kryptonite”\n“Layered architecture star ratings”\n“Wrapping it up”\nChapter 7\nThere’s more than one way to build a monolith. So far, you’ve encountered the layered architecture, which aligns things technically. You can go a long way with a layered monolith, but when changes begin to involve lots of communication and coordination between different teams, you might need a little more horsepower under the hood—and perhaps even a different architectural style.\nThis chapter looks at the modular monolith architectural style, which divides applications up by business concerns as opposed to technical concerns. You’ll learn what this means, what to look out for, and all the trade-offs associated with this style. Let’s take the modular monolith for a spin, shall we?\n“Modular monolith?”\n“Domain pains changes”\n“Why modular monoliths?”\n“Show me the code!”\n“Keeping modules modular”\n“Taking modularity all the way to the database”\n“Beware of joins”\n“Modular monolith superpowers”\n“Modular monolith kryptonite”\n“Modular monolith star ratings”\n“Naan & Pop is delivering pizza!”\nChapter 8\nYou can craft custom experiences, one capability at a time. Some architecture styles are particularly well suited for some capabilities, and the microkernel architecture is the world champion at customization. But it’s also useful for a bewildering range of applications. Once you understand this architectural style, you’ll start seeing it everywhere!\nLet’s dig into an architecture that lets your users have it their way.\n“The benefits of Going Green”\n“The two parts of microkernel architectures”\n“The spectrum of “microkern-ality””\n“Device assessment service core”\n“Encapsulated versus distributed plugins”\n“Plugin communication”\n“Plugin contracts”\n“Going Green goes green”\n“Microkernel superpowers”\n“Microkernel kryptonite”\n“Microkernel star ratings”\n“Wrapping it up”\nChapter 9","metadata":{"id":3015914059850927,"pageNumber":6,"bookId":1}},{"text":"Ready to extend your journey into software architecture? In this chapter, you’re the software architect. You’ll be determining architectural characteristics, building a logical architecture, making architectural decisions, and deciding whether to use a layered, modular, or microkernel architecture. The exercises in this chapter will give you an end-to-end view of what a software architect does and show you how much you’ve learned. Get ready to create an architecture for a startup company building a travel integration convenience site. Bon voyage—we hope you have a good trip building your architecture.\n“Making travel easier”\n“TripEZ’s user workflow”\n“Planning the architecture”\n“The architects’ roadmap”\n“Step 1: Identify architectural characteristics”\n“Step 2: Identify logical components”\n“Step 3: Choose an architectural style”\n“Step 4: Document your decision”\n“Step 5: Diagram your architecture”\n“There are no right (or wrong) answers”\nChapter 10","metadata":{"id":4454633029975002,"pageNumber":6,"bookId":1}},{"text":"How do you make an architecture easier to change? Business is changing faster than ever, and software architectures need to keep up. In this chapter you’ll learn how to create a flexible architecture that can change as your business changes, scale as your business grows, and remain operational even when system failures occur. Intrigued? We hope so, because in this chapter we’re going to show you microservices—an architectural style that solves all of these problems and more. Let’s get started on our journey through microservices, bit by bit.\n“Are you feeling okay?”\n“What’s a microservice?”\n“It’s my data, not yours”\n“How micro is “micro”?”\n“Granularity disintegrators”\n“Why should you make microservices smaller?”\n“Granularity integrators”\n“Why should you make microservices bigger?”\n“It’s all about balance”\n“Sharing functionality”\n“Code reuse with a shared service”\n“Code reuse with a shared library”\n“Managing workflows”\n“Orchestration: Conducting microservices”\n“Choreography: Let’s dance”\n“Microservices architecture superpowers”\n“Microservices architecture kryptonite”\n“Microservices star ratings”\n“Wrapping it up”\nChapter 11","metadata":{"id":1457229342310920,"pageNumber":6,"bookId":1}},{"text":"What if your architecture could do lots of things at the same time? As businesses grow and become more successful, they need to be able to handle more and more users, without slowing down or crashing systems. In this chapter, you’ll learn how to design high-performance systems that can scale as a business grows. Get ready for event-driven architecture, a highly popular distributed architecture style. It’s very fast, highly scalable, and easy to extend—but it’s also quite complex. You’ll be learning about lots of new concepts in this chapter, including things like events, messages, and asynchronous communication, so you can create an architectural that can do many things at once. Fasten your seatbelt, and let’s go on an asynchronous adventure through event-driven architecture.\n“Too slow”\n“Speeding things up”\n“Der Nile flows faster than ever”\n“What is an event?”\n“Events versus messages”\n“Initiating and derived events”\n“Is anyone listening?”\n“Asynchronous communication”\n“Fire-and-forget”\n“Asynchronous for the win”\n“Synchronous for the win”\n“Database topologies”\n“Monolithic database”\n“Domain-partitioned databases”\n“Database-per-service”\n“EDA versus microservices”\n“Hybrids: Event-driven microservices”\n“Event-driven architecture superpowers”\n“Event-driven architecture kryptonite”\n“Event-driven architecture star ratings”\n“Putting it all together”\n“Wrapping up”\nChapter 12","metadata":{"id":1604644800814539,"pageNumber":6,"bookId":1}},{"text":"Ready to test your skills in creating a distributed architecture? In this chapter, you’re the software architect. You’ll be determining architectural characteristics, building a logical architecture, making architectural decisions, and deciding whether to use microservices or event-driven architecture. The exercises in this chapter will give you an end-to-end view of what a software architect does and show you how much you’ve learned. Get ready to create an architecture for a student standardized test–taking system called Make the Grade. Good luck—we hope you get an A on your architecture!\n“Welcome to Make the Grade”\n“Student testing workflow”\n“Planning the architecture”\n“The architects’ roadmap”\n“Step 1: Identify architectural characteristics”\n“Step 2: Identify logical components”\n“Step 3: Choose an architectural style”\n“Step 4: Document your decision”\n“Step 5: Diagram your architecture”\n“There are no right (or wrong) answers!”\nAppendix A","metadata":{"id":4670327338931461,"pageNumber":6,"bookId":1}},{"text":"There’s a lot more to be said about software architecture. We promise you’re done with this book. But reading this book is just the first step in your journey to thinking architecturally, and we couldn’t in good conscience let you go without a little more preparation. So, we’ve gathered a few additional juicy bits into this appendix. Each of the topics that follow deserves as much attention as the other topics we’ve covered. However, our goal here is just to give you a high-level idea of what they’re all about. And yes, this really is the end of the book. Except for the index, of course—it’s a real page-turner!\n“#1 The coding architect”\n“#2 Expectations for architects”\n“#3 The soft skills of architecture”\n“#4 Diagramming techniques”\n“#5 Knowledge depth versus breadth”\n“#6 Practicing architecture with katas”","metadata":{"id":3719605127064162,"pageNumber":6,"bookId":1}},{"text":"How to use this Book: Intro\nNote\nIn this section we answer the burning question: “So why DID they put that in a software architecture book?”\nWho is this book for?\nIf you can answer “yes” to both of these:\nDo you want to learn what software architecture is all about?\nDo you prefer stimulating dinner-party conversation to dry, dull academic lectures?\nThis book is for you.\nWho should probably back away from this book?\nIf you can answer “yes” to any of these:\nAre you completely new to the tech industry?\n(While we firmly believe that software developers should understand the basics of software architecture, you might want to get a bit of experience developing software before diving into this book.)\nAre you a seasoned software architect looking for a reference book?\nAre you afraid to try something new? Would you rather sit in a corner licking 9-volt batteries than advance your career? Do you believe that a technical book can’t be serious if it uses zoo animals to explain architectural characteristics like scalability and fault tolerance?\nThis book is not for you.\nNote\n[Note from marketing: This book is for anyone with a credit card.]\nWe know what you’re thinking\n“How can this be a serious book on software architecture?”\n“What’s with all the graphics?”\n“Can I actually learn it this way?”\nWe know what your brain is thinking\nYour brain craves novelty. It’s always searching, scanning, waiting for something unusual. It was built that way, and it helps you stay alive.\nSo what does your brain do with all the routine, ordinary, normal things you encounter? Everything it can to stop them from interfering with the brain’s real job—recording things that matter. It doesn’t bother saving the boring things; they never make it past the “this is obviously not important” filter.\nHow does your brain know what’s important? Suppose you’re out for a day hike and a tiger jumps in front of you. What happens inside your head and body?\nNeurons fire. Emotions crank up. Chemicals surge.\nAnd that’s how your brain knows...\nThis must be important! Don’t forget it!\nBut imagine you’re at home, or in a library. It’s a safe, warm, tiger-free zone. You’re studying. Getting ready for an exam. Or trying to learn some tough technical topic your boss thinks will take a week, 10 days at the most.","metadata":{"id":1861530260858491,"pageNumber":7,"bookId":1}},{"text":"Just one problem. Your brain’s trying to do you a big favor. It’s trying to make sure that this obviously unimportant content doesn’t clutter up scarce resources. Resources that are better spent storing the really big things. Like tigers. Like the danger of fire. Like how you should never have posted those “party” photos on your Facebook page. And there’s no simple way to tell your brain, “Hey brain, thank you very much, but no matter how dull this book is and how little I’m registering on the emotional Richter scale right now, I really do want you to keep this stuff around.”\nWe think of a “Head First” reader as a learner.\nSo what does it take to learn something? First you have to get it, then make sure you don’t forget it. It’s not about pushing facts into your head. Based on the latest research in cognitive science, neurobiology, and educational psychology, learning takes a lot more than text on a page. We know what turns your brain on.\nSome of the Head First learning principles:\nMake it visual. Images are far more memorable than words alone and make learning much more effective (up to 89% improvement in recall and transfer studies). They also make things more understandable. Put the words within or near the graphics they relate to, rather than on the bottom or on another page, and learners will be up to twice as likely to be able to solve problems related to the content.\nUse a conversational and personalized style. In recent studies, students performed up to 40% better on post-learning tests if the content spoke directly to the reader, using a first-person, conversational style rather than taking a formal tone. Tell stories instead of lecturing. Use casual language. Don’t take yourself too seriously. Which would you pay more attention to: a stimulating dinner party companion, or a lecture?\nGet the learner to think more deeply. Unless you actively flex your neurons, nothing much happens in your head. A reader has to be motivated, engaged, curious, and inspired to solve problems, draw conclusions, and generate new knowledge. And for that, you need challenges, exercises, and thought-provoking questions, and activities that involve both sides of the brain and multiple senses.\nGet—and keep—the reader’s attention. We’ve all had the “I really want to learn this but I can’t stay awake past page one” experience. Your brain pays attention to things that are out of the ordinary, interesting, strange, eye-catching, unexpected. Learning a new, tough, technical topic doesn’t have to be boring. Your brain will learn much more quickly if it’s not.","metadata":{"id":6538106421651431,"pageNumber":7,"bookId":1}},{"text":"Touch their emotions. We now know that your ability to remember something is largely dependent on its emotional content. You remember what you care about. You remember when you feel something. No, we’re not talking heart-wrenching stories about a boy and his dog. We’re talking emotions like surprise, curiosity, fun, “what the...?” and the feeling of “I rule!” that comes when you solve a puzzle, learn something everybody else thinks is hard, or realize you know something that “I’m more technical than thou” Bob from engineering doesn’t.\nMetacognition: Thinking about thinking\nIf you really want to learn, and you want to learn more quickly and more deeply, pay attention to how you pay attention. Think about how you think. Learn how you learn.\nMost of us did not take courses on metacognition or learning theory when we were growing up. We were expected to learn, but rarely taught to learn.\nBut we assume that if you’re holding this book, you really want to learn what software architecture is all about. And you probably don’t want to spend a lot of time on it. If you want to use what you read in this book, you need to remember what you read. And for that, you’ve got to understand it. To get the most from this book, or any book or learning experience, take responsibility for your brain. Your brain on this content.\nThe trick is to get your brain to see the new material you’re learning as Really Important. Crucial to your well-being. As important as a tiger. Otherwise, you’re in for a constant battle, with your brain doing its best to keep the new content from sticking.\nSo just how DO you get your brain to treat software architecture like it’s a hungry tiger?\nThere’s the slow, tedious way, or the faster, more effective way. The slow way is about sheer repetition. You obviously know that you are able to learn and remember even the dullest of topics if you keep pounding the same thing into your brain. With enough repetition, your brain says, “This doesn’t feel important, but they keep looking at the same thing over and over and over, so I suppose it must be.”","metadata":{"id":639919393583605,"pageNumber":7,"bookId":1}},{"text":"The faster way is to do anything that increases brain activity, especially different types of brain activity. The things on the previous page are a big part of the solution, and they’re all things that have been proven to help your brain work in your favor. For example, studies show that putting words within the pictures they describe (as opposed to somewhere else on the page, like a caption or in the body text) causes your brain to try to make sense of how the words and picture relate, and this causes more neurons to fire. More neurons firing = more chances for your brain to get that this is something worth paying attention to, and possibly recording.\nA conversational style helps because people tend to pay more attention when they perceive that they’re in a conversation, since they’re expected to follow along and hold up their end. The amazing thing is, your brain doesn’t necessarily care that the “conversation” is between you and a book! On the other hand, if the writing style is formal and dry, your brain perceives it the same way you experience being lectured to while sitting in a roomful of passive attendees. No need to stay awake.\nBut pictures and conversational style are just the beginning…\nHere’s what WE did\nWe used visuals, because your brain is tuned for visuals, not text. As far as your brain’s concerned, a visual really is worth a thousand words. And when text and visuals work together, we embedded the text in the visuals because your brain works more effectively when the text is within the thing the text refers to, as opposed to in a caption or buried in a paragraph somewhere.\nWe used redundancy, saying the same thing in different ways and with different media types, and multiple senses, to increase the chance that the content gets coded into more than one area of your brain.\nWe used concepts and visuals in unexpected ways because your brain is tuned for novelty, and we used visuals and ideas with at least someemotionalcontent, because your brain is tuned to pay attention to the biochemistry of emotions. That which causes you to feel something is more likely to be remembered, even if that feeling is nothing more than a little humor, surprise, or interest.\nWe used a personalized, conversational style, because your brain is tuned to pay more attention when it believes you’re in a conversation than if it thinks you’re passively listening to a presentation. Your brain does this even when you’re reading.\nWe included dozens of activities, because your brain is tuned to learn and remember more when you do things than when you read about things. And we made the exercises challenging yet doable, because that’s what most people prefer.\nWe used multiple learning styles, because you might prefer step-by-step procedures, while someone else wants to understand the big picture first, and someone else just wants to see an example. But regardless of your own learning preference, everyone benefits from seeing the same content represented in multiple ways.\nWe included content for both sides of your brain, because the more of your brain you engage, the more likely you are to learn and remember, and the longer you can stay focused. Since working one side of the brain often means giving the other side a chance to rest, you can be more productive at learning for a longer period of time.\nAnd we included stories and exercises that present more than one point of view, because your brain is tuned to learn more deeply when it’s forced to make evaluations and judgments.","metadata":{"id":3360234939374053,"pageNumber":7,"bookId":1}},{"text":"We included challenges, with exercises, and we asked questions that don’t always have a straight answer, because your brain is tuned to learn and remember when it has to work at something. Think about it—you can’t get your body in shape just by watching people at the gym. But we did our best to make sure that when you’re working hard, it’s on the right things. That you’re not spending one extra dendrite processing a hard-to-understand example or parsing difficult, jargon-laden, or overly terse text.\nWe used people. In stories, examples, visuals, etc., because, well, because you’re a person. And your brain pays more attention to people than it does to things.\nHere’s what YOU can do to bend your brain into submission\nSo, we did our part. The rest is up to you. These tips are a starting point; listen to your brain and figure out what works for you and what doesn’t. Try new things.\nNote\nCut this out and stick it on your refrigerator.\nSlow down. The more you understand, the less you have to memorize.\nDon’t just read. Stop and think. When the book asks you a question, don’t just skip to the answer. Imagine that someone really is asking the question. The more deeply you force your brain to think, the better chance you have of learning and remembering.\nDo the exercises. Write your own notes.\nWe put them in, but if we did them for you, that would be like having someone else do your workouts for you. And don’t just look at the exercises. Use a pencil. There’s plenty of evidence that physical activity while learning can increase the learning.\nRead the “There Are No Dumb Questions.”\nThat means all of them. They’re not optional sidebars, they’re part of the core content! Don’t skip them.\nMake this the last thing you read before bed. Or at least the last challenging thing.\nPart of learning (especially the transfer to long-term memory) happens after you put the book down. Your brain needs time on its own, to do more processing. If you put in something new during that processing time, some of what you just learned will be lost.\nTalk about it. Out loud.\nSpeaking activates a different part of the brain. If you’re trying to understand something, or increase your chance of remembering it later, say it out loud. Better still, try to explain it out loud to someone else. You’ll learn more quickly, and you might uncover ideas you hadn’t known were there when you were reading about it.\nDrink water. Lots of it.\nYour brain works best in a nice bath of fluid. Dehydration (which can happen before you ever feel thirsty) decreases cognitive function.\nListen to your brain.\nPay attention to whether your brain is getting overloaded. If you find yourself starting to skim the surface or forget what you just read, it’s time for a break. Once you go past a certain point, you won’t learn faster by trying to shove more in, and you might even hurt the process.\nFeel something.\nYour brain needs to know that this matters. Get involved with the stories. Make up your own captions for the photos. Groaning over a bad joke is still better than feeling nothing at all.\nApply it every day!","metadata":{"id":5034940824095578,"pageNumber":7,"bookId":1}},{"text":"There’s only one way to learn how to really understand software architecture: apply it every day. You are going to be doing software architecture a lot in this book, and like with any other skill, the only way to get good at it is to practice. We’re going to give you a lot of practice: every chapter has exercises that pose problems for you to solve. Don’t just skip over them—a lot of the learning happens when you solve the exercises. We included a solution to each exercise—don’t be afraid to peek at the solution if you get stuck! (It’s easy to get snagged on something small.) But try to solve the problem before you look at the solution. And definitely get it working before you move on to the next part of the book.\nRead me\nThis is a learning experience, not a reference book. We deliberately stripped out everything that might get in the way of learning whatever it is we’re working on at that point in the book. And the first time through, you need to begin at the beginning, because the book makes assumptions about what you’ve already seen and learned.\nWe break things down, then build them back again.\nWe are fans of teasing things apart. This gives us the chance to focus on one aspect of software architecture at a time. We use a lot of visuals to explain various aspects of software architecture. We make sure you have a deep understanding of each aspect, and have the confidence to know when and how to use them. Only then do we start to bring things together, to explain the more complex ideas in software architecture.\nWe don’t exhaustively cover everything.\nWe use the 80/20 approach. We assume that if you are going for a PhD in software architecture, this isn’t going to be your only book. So, we don’t talk about everything—just the stuff that you’ll actually use, and that you need to hit the ground running. We want to hit the ground running.\nThe activities are NOT optional.\nThe exercises and activities are not add-ons; they’re part of the core content of the book. Some of them are to help with memory, some are for understanding, and some will help you apply what you’ve learned. Don’t skip the exercises. The crossword puzzles are the only thing you don’t have to do, but they’re good for giving your brain a chance to think about the words and terms you’ve been learning in a different context.\nThe redundancy is intentional and important.\nOne distinct difference in a Head First book is that we want you to really get it. And we want you to finish the book remembering what you’ve learned. Most reference books don’t have retention and recall as a goal, but this book is about learning, so you’ll see some of the same concepts come up more than once.\nThe examples are as generic as possible.\nTo teach you software architecture, we have to use business problems—otherwise, the concepts we introduce in this book would be too abstract and hard to follow. We’ve deliberately made the examples in this book generic, yet also interesting, fascinating, and downright fun. No matter your background, we are certain you will be able to relate to them when practicing software architecture, whatever kind of work you do.\nThe Brain Power exercises don’t always have answers.\nFor some of them, there is no right answer, and for others, part of the learning experience is for you to decide if and when your answers are right. In some of the Brain Power exercises, you will find hints to point you in the right direction.\nO’Reilly online learning\nFor more than 40 years, O’Reilly Media has provided technology and business training, knowledge, and insight to help companies succeed.\nOur unique network of experts and innovators share their knowledge and expertise through books, articles, and our online learning platform. O’Reilly’s online learning platform gives you on-demand access to live training courses, in-depth learning paths, interactive coding environments, and a vast collection of text and video from O’Reilly and 200+ other publishers. For more information, visit http://oreilly.com.\nDo it yourself chapters\nA unique aspect of this particular Head First book is what we call “do it yourself” chapters. These chapters (there are two of them) are entirely exercise-based and give you a chance to create an architecture from beginning to end, applying all the concepts you’ve learned up to that point.\nIn these chapters, you’re the software architect. You’ll determine architectural characteristics, build a logical architecture, and make architectural decisions, including what kind of architectural style to use. Doing the exercises in these chapters gives you an end-to-end view of what a software architect does and shows you how much you’ve learned.\nIn Chapter 9, the first “do it yourself” chapter, you’ll create an architecture for a trip-management system called TripEZ (pronounced like “trapeze”) that aims to make travel easier, especially for road warriors. This new online trip-management dashboard app will allow travelers to see and manage all of their travel reservations, organized by trip, through a browser or on their mobile devices.\nIn Chapter 12, the second “do it yourself” chapter, you’ll create an architecture for a standardized-testing system called Make the Grade. All Dataville Public School students in specific grade levels take the same test to determine how well students, teachers, and the school are doing. This chapter will be a great way for you to test your knowledge (so to speak).\nThe technical review team\nMeet our review team!\nWe were lucky enough to round up a powerhouse team of people to review this book, including senior developers, software architects, renowned public speakers, and prolific book authors.\nThese experts read every chapter, did the exercises, corrected our mistakes, and provided detailed commentary on every single page of this book. They also acted as our sounding board, letting us work through ideas, analogies, and narratives. They even helped us think through how this book should be organized.\nEvery single reviewer here made huge contributions to this book and vastly improved its quality. We deeply appreciate the countless hours they spent poring over the manuscript. We remain indebted to them.\nNote\nSpecial thanks also to Moataz Sanad for finding lots of our typos!\nNote\nDespite our (and our reviewers’) best efforts, any and all errors and omissions are ours and ours alone.\nThank you!\nJoint acknowledgments\nThis book would not have been possible without the help, guidance, and support from a number of great individuals. We have a lot of people to thank, so let’s get started!\nOur editor:","metadata":{"id":5990961755013867,"pageNumber":7,"bookId":1}},{"text":"Our first and foremost acknowledgment goes, along with our utmost thanks, to our brilliant editor Sarah Grey. Writing a book like Head First Software Architecture presented a number of unique challenges for us, and Sarah was there to guide us the entire time. She helped keep us on track when we deviated from the Head First style of writing (which was quite often) and made constant suggestions about every page’s layout (really, we mean every page). Sarah took on the role of crossword expert and helped us out quite a bit with the Make It Stick poetry. We frequently referred to Sarah as our “fourth author,” and in reality, she deserves much of the credit for the outcome of this book.\nThe O’Reilly team:\nA big thanks to the entire O’Reilly Media team, including Kristen Brown and Chris Faucher for making sure that our book was production-worthy, and to Rachel Head for her keen and astute copyediting eye. And if, like us, you routinely use book indexes, you have Tom Dinse to thank for this one.\nWe’d also like to thank Melissa Duffield for her continued support and patience throughout this process, and for considering us for this long project.\nMuch appreciation to the O’Reilly online training team, especially Yasmina Greco, Lindsay Ventimiglia, and all the producers, for giving us a platform to teach software architecture to thousands of developers and architects around the world.\nA shoutout to the Early Release team, who put out raw and unedited chapters as they were written for the audience on the O’Reilly platform to review. This gave many of our readers a chance to submit errata and feedback that made this book just that much better.\nFinally, we would be remiss if we did not mention series editors Elisabeth Robson and Eric Freeman, who took the time to review our work and ensure that it aligned with the vision that is the Head First series—not to mention giving us some really useful InDesign tips. Thank you!\nIndividual acknowledgments\nFrom Raju Gandhi:","metadata":{"id":6182964517507547,"pageNumber":7,"bookId":1}},{"text":"It’s hard for me to express how much of a privilege it has been to work on this project, and to be able to work with Mark and Neal—two of the smartest and most wonderful human beings, who not only were kind enough to consider me as a coauthor, but who since have spent countless hours teaching me the nuances of software architecture. Someday I hope I can repay that debt. For now, they have my deepest appreciation. A shoutout to so many friends, colleagues, unwitting mentors and teachers, and fellow speakers who’ve been a source of inspiration for me—you all know you who are. And finally, to my wife Michelle. We had baby Delphine while I was working on this project, and Michelle has certainly taken on more than her share as I spent many an hour working on this book. Thank you. I love you both.\nFrom Mark Richards:","metadata":{"id":6856882492343128,"pageNumber":7,"bookId":1}},{"text":"In addition to the joint acknowledgments, I would like to thank my friends and coauthors Raju and Neal. Raju brought prior Head First experience to the table from his great book Head First Git, and helped teach us the Head First style of writing and the ins and outs of InDesign. This is my third book with Neal, and as usual, working and collaborating with him was a very rewarding and enjoyable experience. I would also like to thank my lovely wife Rebecca for her patience and understanding while I was hidden away in my office for so many evenings writing this book instead of enjoying her company.\nFrom Neal Ford:","metadata":{"id":5626952711572036,"pageNumber":7,"bookId":1}},{"text":"I would like to thank first and foremost my coauthors, Mark and Raju, both of whom were a delight to work with and made this book possible. Mark is as always a fantastic collaborative juggernaut with a good sense of humor, both vital when writing is not our day job. I’d also like to thank our editor Sarah, who has an outsized role in this book series, for helping keep us in check. Thanks also to my extended families, both genetic and chosen, for their support and respite. That includes our weekly neighborhood cocktail club that moved to the parking lot during the pandemic and stayed there; it’s great to catch up with what is happening nearby. And finally and primarily, I’d like to thank my wonderful wife Candy, who endures many long hours with me away from her and our cats, working on stuff like what you hold in your hand.\nNote\nGood thing we only had three authors, or these acknowledgments would go on and on and on...\nAnd finally, you, the readers. Your attention is a scarce resource, and we deeply appreciate the time you’ll spend with this book. Happy learning.","metadata":{"id":2478400806408982,"pageNumber":7,"bookId":1}},{"text":"Chapter 1. Software Architecture Demystified: Let’s Get Started!\nSoftware architecture is fundamental to the success of your system. This chapter demystifies software architecture. You’ll gain an understanding of architectural dimensions and the differences between architecture and design. Why is this important? Because understanding and applying architectural practices helps you build more effective and correct software systems—systems that not only function better, but also meet the needs and concerns of the business and continue to operate as your business and technical environments undergo constant change. So, without further delay, let’s get started.\nBuilding your understanding of software architecture\nTo better understand software architecture, think about a typical home in your neighborhood. The structure of the home is its architecture —things like its shape, how many rooms and floors it has, its dimensions, and so on. A house is usually represented through a building plan, which contains all the lines and boxes necessary to know how to build the house. Structural things like those shown below are hard and expensive to change later and are the important stuff about the house.\nNote\nThe building metaphor is a very popular one for understanding software architecture.\nArchitecture is essential for building a house. Can you imagine building one without an architecture? It might turn out looking something like the house on the right.\nArchitecture is also essential for building software systems. Have you ever come across a system that doesn’t scale, or is unreliable or difficult to maintain? It’s likely not enough emphasis was placed on that system’s architecture.\nExercise\nGardening is another useful metaphor for describing software architecture. Using the space below, can you describe how planning a garden might relate to software architecture? You can see what we came up with at the end of this chapter.\nSolution in “Exercise Solution”\nBuilding plans and software architecture\nYou might be wondering how the building plans of your home relate to software architecture. Each is a representation of the thing being built. So what does the “building plan” of a software system look like? Lines and boxes, of course.\nA building plan specifies the structure of your home—the rooms, walls, stairs, and so on—in the same way a software architecture diagram specifies its structure (user interfaces, services, databases, and communication protocols). Both artifacts provide guidelines and constraints, as well as a vision of the final result.\nSharpen your pencil\nWhat features of your home can you list that are structural and related to its architecture? You can find our thoughts at the end of this chapter.\nNote\nUse this space to write down your ideas.\nSolution in “Sharpen your pencil Solution”\nDid you notice that the floor plan for the house above doesn’t specify the details of the rooms—things like the type of flooring (carpet or hardwood), the color of the walls, and where a bed might go in a bedroom? That’s because those things aren’t structural. In other words, they don’t specify something about the architecture of the house, but rather about its design.\nNote\nDon’t worry—you’ll learn a lot more about this distinction later in this chapter. Right now, just focus on the structure of something—in other words, its architecture.\nThe dimensions of software architecture\nMost things around us are multidimensional. For example, you might describe a particular room in your home by saying it is 5 meters long and 4 meters wide, with a ceiling height of 2.5 meters. Notice that to properly describe the room you needed to specify all three dimensions—its height, length, and width.\nYou can describe software architecture by its dimensions, too. The difference is that software architecture has four dimensions.\nArchitectural characteristics\nThis dimension describes what aspects of the system the architecture needs to support—things like scalability, testability, availability, and so on.\nArchitectural decisions\nThis dimension includes important decisions that have long-term or significant implications for the system—for example, the kind of database it uses, the number of services it has, and how those services communicate with each other.\nLogical components\nThis dimension describes the building blocks of the system’s functionality and how they interact with each other. For example, an ecommerce system might have components for inventory management, payment processing, and so on.\nArchitectural style\nThis dimension defines the overall physical shape and structure of a software system in the same way a building plan defines the overall shape and structure of your home.\nNote\nYou’ll learn about five of the most common architectural styles later in this book.\nPuzzling out the dimensions\nYou can think of software architecture as a puzzle, with each dimension representing a separate puzzle piece. While each piece has its own unique shape and properties, they must all fit together and interact to build a complete picture.\nEverything is interconnected.\nDid you notice how the pieces of this puzzle are joined in the middle? That’s exactly how software architecture works: each dimension must align.\nThe architectural style must align with the architectural characteristics you choose as well as the architectural decisions you make. Similarly, the logical components you define must align with the characteristics and the architectural style as well as the decisions you make.\nthere are no Dumb Questions\nQ:Do you need all four dimensions when creating an architecture, or can you skip some if you don’t have time?","metadata":{"id":3788731296525986,"pageNumber":8,"bookId":1}},{"text":"A: Unfortunately, you can’t skip any of these dimensions—they are all required to create and describe an architecture. One common mistake software architects make is using only one or two of these dimensions when describing their architecture. “Our architecture is microservices” describes a single dimension—the architectural style—but leaves too many unanswered questions. For example, what architectural characteristics are critical to the success of the system? What are its logical components (functional building blocks)? What major decisions have you made about how you’ll implement the architecture?\nThe first dimension: Architectural characteristics\nArchitectural characteristics form the foundation of the architecture in a software system. Without them, you cannot make architectural decisions or analyze important trade-offs.\nImagine you’re trying to choose between two homes. One home is roomy but is next to a busy, noisy motorway. The other home is in a nice, quiet neighborhood, but is much smaller. Which characteristic is more important to you—home size or the level of noise and traffic? Without knowing that, you can’t make the right choice.","metadata":{"id":4276434856948998,"pageNumber":8,"bookId":1}},{"text":"The same is true with software architecture. Let’s say you need to decide what kind of database to use for your new system. Should it be a relational database, a simple key/value database, or a complex graph database? The answer will be based on what architectural characteristics are critical to you. For example, you might choose a graph database if you need high-speed search capability (we’ll call that performance), whereas a traditional relational database might be better if you need to preserve data relationships (we’ll call that data integrity).\nExercise\nCheck the things you think might be considered architectural characteristics—something that the structure of the software system supports.\nChanging the font size in a window on the user interface screen\nMaking changes quickly\nHandling thousands of concurrent users\nEncrypting user passwords stored in the database\nInteracting with many external systems to complete a business request\nSolution in “Exercise Solution”\nThe term architectural characteristics might not be familiar to you, but that doesn’t mean you haven’t heard of them before. Collectively, things like performance, scalability, reliability, and availability are also known as nonfunctional requirements, system quality attributes, and simply “the -ilities” because most end with the suffix -ility. We like the term architectural characteristics because these qualities help define the character of the architecture and what it needs to support.\nNote\nArchitectural characteristics are capabilities that are critical or important to the success of the system.\nMake it Stick\nTo architect software you must first address:\nCapabilities key to the new app’s success\nWho Does What?\nHere’s your chance to see how much you already know about many common architectural characteristics. Can you match up each architectural characteristic on the left with its definition on the right? You’ll notice there are more definitions than characteristics, so be careful—not all of the definitions have matches.\nThe second dimension: Architectural decisions\nArchitectural decisions are choices you make about structural aspects of the system that have long-term or significant implications. As constraints, they’ll guide your development team in planning and building the system.\nShould your new home have one floor or two? Should the roof be flat or peaked? Should you build a big, sprawling ranch house? These are good examples of architectural decisions because they involve the structural aspect of your home.\nYou might decide that your system’s user interface should not communicate directly with the database, but instead must go through the underlying services to retrieve and update data. This architectural decision places a particular constraint on the development of the user interface, and also guides the development team about how other components should access and update data in the database.\nIt’s not uncommon to have several dozen or more documented architectural decisions within any system. Generally, the larger and more complicated the system, the more architectural decisions it will have.\nMake it Stick\nDecisions are structural guides for dev teams.\nThey often focus on significant themes.\nBE the architect\nYour job is to be the architect and identify as many architectural decisions as you can in the diagram below. Draw a circle around anything that you think might be an architectural decision and write what that decision might be.\nSolution in “BE the architect Solution”\nThe third dimension: Logical components\nLogical components are the building blocks of a system, much in the same way rooms are the building blocks of your home. A logical component performs some sort of function, such as processing the payment for an order, managing item inventory, or tracking orders.\nLogical components in a system are usually represented through a directory or namespace. For example, the directory app/order/payment with the corresponding namespace app.order.payment identifies a logical component named Payment Processing. The source code that allows users to pay for an order is stored in this directory and uses this namespace.\nSharpen your pencil\nYou’ve just created the following two components for a new system, and your development team wants to start writing class files to implement them. Can you create a directory structure for them so they can start coding? Flip to the end of the chapter for our solution.\nSolution in “Sharpen your pencil Solution”\nA logical component should always have a well-defined role and responsibility in the system—in other words, a clear definition of what it does.\nMake it Stick\nLogical components are blocks in conjunction.\nThey hold the source code for each business function.\nthere are no Dumb Questions\nQ:What is the difference between the system functionality and the domain?\nA: The domain is the problem you are trying to solve, and the system functionality is how you are solving that problem. In other words, the domain is the “what,” and the system’s functionality is the “how.”\nThe fourth dimension: Architectural styles\nHomes come in all shapes, sizes, and styles. While there are some wild-looking houses out there, most conform to a particular style, such as Victorian, ranch, or Tudor. The style of a home says a lot about its overall structure. For example, ranch homes typically have only one floor; colonial and Tudor homes typically have chimneys; contemporary homes typically have flat roofs.\nArchitectural styles define the overall shape and structure of a software system, each with its own unique set of characteristics. For example, the microservices architectural style scales very well and provides a high level of agility—the ability to respond quickly to change—whereas the layered architectural style is less complex and less costly. The event-driven architectural style provides high levels of scalability and is very fast and responsive.\nNote\nDon’t worry—you’ll be learning all about these architectural styles later in the book. We’ve devoted chapters to each of them.\nBecause the architectural style defines the overall shape and characteristics of the system, it’s important to get it right the first time. Why? Can you imagine starting construction on a one-story ranch home, and in the middle of construction changing your mind and deciding you’re going to build a three-story Victorian house instead? That would be a major undertaking, and likely exceed your budget and affect when you can move into the house.\nSoftware architecture is no different. It’s not easy changing from a monolithic layered architecture to microservices. Like the house example, this would be quite an undertaking.\nMake it Stick\nStyles shape the system and help serve its purposes.\nYou might choose a monolith or microservices.\nLater in the book, we’ll show you how to properly select an architectural style based on characteristics that are important to you.\nWhich brings us back to an earlier point—all of the dimensions of software architecture are interconnected. You can’t select an architectural style without knowing what’s important to you.\nBrain Power\nThe tightly wound tendons and muscles in a lion’s legs enable it to reach speeds as fast as reach speeds as fast as 50 miles (80 kilometers) per hour and leap up to 36 feet (11 meters) in a single bound. This characteristic allows lions to survive by catching fast prey.\nLook around you—what else has a structure or shape that defines its characteristics and capabilities?\nWho Does What?\nWe were trying to describe our architecture, but all the puzzle pieces got mixed up. Can you help us figure out which dimension does what by matching the statements on the left with the software architecture dimensions on the right? Be careful—some of the statements don’t have a match because they are not related to architecture.\nSolution in “Who Does What? Solution”\nNo, architecture and design are different.\nYou see, architecture is less about appearance and more about structure, while design is less about structure and more about appearance.\nThe color of a room’s walls, the placement of furniture, and the type of flooring (carpet or wood) are all aspects of design, whereas the physical size of the room and the placement of doors and windows are part of architecture—in other words, the structure of the room.\nThink about a typical business application. The architecture, or structure, is all about how the web pages communicate with backend services and databases to retrieve and save data, whereas the design is all about what each page looks like: the colors, the placement of the fields, which design patterns you use, and so on. Again, it becomes a matter of structure versus appearance.\nYour question is a good one, because sometimes it gets confusing trying to tell what is considered architecture and what is considered design. Let’s investigate these differences.\nA design perspective\nSuppose your company wants to replace its outdated order processing system with a new custom-built one that better suits its specific needs. Customers can place orders and can view or cancel orders once they have been placed. They can pay for an order using a credit card, a gift card, or both payment methods.\nFrom a design perspective, you might build a Unified Modeling Language (UML) class diagram like the one below to show how the classes interact with each other to implement the payment functionality. While you could write source code to implement these class files, this design says nothing about the physical structure of the source code—in other words, how these class files would be organized and deployed.\nAn architectural perspective\nUnlike design, architecture is about the structure of the system—things like services, databases, and how services communicate with each other and the user interface.\nLet’s think about that new order processing system again. What would the system look like? From an architectural perspective, you might decide to create separate services for each payment type within the order payment process and have an orchestrator service to manage the payment processing part of the system, like in the diagram below.\nExercise\nCheck all of the things that should be included in a diagram from an architectural perspective.\nHow services communicate with each other\nThe platform and language in which the services are implemented\nWhich services can access which databases\nHow many services and databases there are\nSolution in “Exercise Solution”\nThe spectrum between architecture and design\nSome decisions are certainly architectural (such as deciding which architectural style to use), and others are clearly design-related (such as changing the position of a field on a screen or changing the type of a field within a class). In reality, most decisions you encounter will fall between these two examples, within a spectrum of architecture and design.\nSharpen your pencil\nCircle all of the things that you think fall somewhere in the middle of the spectrum between architecture and design.\nSolution in “Sharpen your pencil Solution”","metadata":{"id":1606570361936397,"pageNumber":8,"bookId":1}},{"text":"Yes, it matters a lot. You see, knowing where along the spectrum between architecture and design your decision lies helps determine who should be responsible for ultimately making that decision. There are some decisions that the development team should make (such as designing the classes to implement a certain feature), some decisions that an architect should make (such as choosing the most appropriate architectural style for a system), and others that should be made together (such as breaking apart services or putting them back together).\nWhere along the spectrum does your decision fall?\nIs it strategic or tactical?","metadata":{"id":7595813243066330,"pageNumber":8,"bookId":1}},{"text":"Strategic decisions are long term and influence future actions or decisions. Tactical decisions are short term and generally stand independent of other actions or decisions (but may be made in the context of a particular strategy). For example, deciding how big your new home will be influences the number of rooms and the sizes of those rooms, whereas deciding on a particular lighting fixture won’t affect decisions about the size of your dining room table. The more strategic the decision, the more it sits toward the architecture side of the spectrum.\nHow much effort will it take to construct or change?\nArchitectural decisions require more effort to construct or change, while design decisions require relatively less. For example, building an addition to your home generally requires a high level of effort and would therefore be more on the architecture side of the spectrum, whereas adding an area rug to a room requires much less effort and would therefore be more on the design side.\nNote\nSometimes waking up in the morning requires a lot of effort—we’ll call those “architecture” mornings.\nDoes it have significant trade-offs?\nTrade-offs are the pros and cons you evaluate as you are making a decision. Decisions that involve significant trade-offs require much more time and analysis to make and tend to be more architectural in nature. Decisions that have less-significant trade-offs can be made quicker, with less analysis, and therefore tend to be more on the design side.\nNote\nWe’re going to walk you through the details of all three of these factors in the next several pages.\nBrain Power\nCan you think of a decision that doesn’t involve a trade-off, no matter how small or insignificant? Here’s a hint: if you think you’ve found a decision that doesn’t involve a trade-off, keep looking.\nStrategic versus tactical\nThe more strategic a decision is, the more architectural it becomes. This is an important distinction, because decisions that are strategic require more thought and planning and are generally long term.\nGood question. You can use these three questions to help determine if something is more strategic or tactical. Remember, the more strategic something is, the more it’s about architecture.\nHow much thought and planning do you need to put into the decision?\nIf making the decision takes a couple of minutes to an hour, it’s more tactical in nature. If thought and planning require several days or weeks, it’s likely more strategic (hence more architectural).\nHow many people are involved in the decision?\nThe more people involved, the more strategic the decision. A decision you can make by yourself or with a colleague is likely to be tactical. A decision that requires many meetings with lots of stakeholders is probably more strategic.\nDoes your decision involve a long-term vision or a short-term action?\nIf you are making a quick decision about something that is temporary or likely to change soon, it’s more tactical and hence more about design. Conversely, if this is a decision you’ll be living with for a very long time, it’s more strategic and more about architecture.\nSharpen your pencil\nOh dear. We’ve lost all of our marbles and we need your help collecting them and putting them back in the right spot. Using the three questions on the previous page as a guide, can you figure out which jar each marble should go in?\nSolution in “Sharpen your pencil Solution”\nHigh versus low levels of effort\nRenowned software architect and author Martin Fowler once wrote that “software architecture is the stuff that’s hard to change.” You can use Martin’s definition to help determine where along the spectrum your decision lies. The harder something is to change later, the further it falls toward the architecture side of the spectrum. Conversely, the easier it is to change later, the more it’s probably related to design.\nNote\nMartin Fowler’s website (https://martinfowler.com/architecture) has lots of useful stuff about architecture.\nSuppose you are planning on moving from one architectural style to another; say, from a traditional n-tiered layered architecture to microservices. This migration effort is rather difficult and will take a lot of time. Because the level of effort is high, this would be on the far end of the architecture side of the spectrum.\nNow suppose you’re rearranging fields on a user interface screen. This task takes relatively less effort, so it resides on the far end of the design side of the spectrum.\nCode Magnets\nWe had all of these magnets from our to-do list arranged from high effort to low effort, and somehow they all fell on the floor and got mixed up. Can you help us put them back in the right order based on the amount of effort it would take to make each change?\nSolution in “Code Magnets Solution”\nSignificant versus less-significant trade-offs\nSome decisions you make might involve significant trade-offs, such as choosing which city to live in. Others might involve less significant trade-offs, like deciding on the color of your living room rug. You can use the level of significance of the trade-offs in a particular decision to help determine whether that decision is more about architecture or design. The more significant the trade-offs, the more it’s about architecture; the less significant the trade-offs, the more it’s about design.\nExercise\nDecisions, decisions, decisions. How can we ever tackle all of these decisions? One thing we think might help is to identify the decisions that involve significant trade-offs, since those will require more thinking and will take longer. Can you help us by identifying which decisions have significant trade-offs and which don’t?\nIs this a significant trade-off?","metadata":{"id":6819806498720979,"pageNumber":8,"bookId":1}},{"text":"YesNoPicking out what clothes to wear to work todayYesNoChoosing to deploy in the cloud or on premisesYesNoSelecting a user interface frameworkYesNoNaming a variable in a class fileYesNoChoosing between vanilla and chocolate ice creamYesNoDeciding which architectural style to useYesNoChoosing between REST and messagingYesNoUsing full data or only keys for the message payloadYesNoSelecting an XML parsing libraryYesNoDeciding whether or not to break apart a serviceYesNoChoosing between atomic or distributed transactionsYesNoDeciding whether or not to go out to dinner tonight\nSolution in “Exercise Solution”\nPutting it all together\nNow it’s time to put all three of these factors to use to figure out whether a decision is more about architecture or more about design. This tells development teams when to collaborate with an architect and when to make a decision on their own.\nLet’s say you decide to use asynchronous messaging between the Order Placement service and the Inventory Management service to increase the system’s responsiveness when customers place orders. After all, why should the customer have to wait for the business to adjust and process inventory? Let’s see if we can determine where in the spectrum this decision lies.\nYou made it!\nCongratulations—you made it through the first part of your journey to understanding software architecture. But before you roll up your sleeves to dig into further chapters, here’s a little quiz for you to test your knowledge so far. For each of the statements below, circle whether it is true or false.\nTrue or False","metadata":{"id":1469659214496870,"pageNumber":8,"bookId":1}},{"text":"TrueFalseDesign is like the structure of a house (walls, roof, layout, and so on), and software architecture is like the furniture and decoration.TrueFalseMost decisions are purely about architecture or design. Very few exist along a spectrum between architecture and design.TrueFalseThe more strategic your decision, the more it’s about architecture; the more tactical, the more it’s about design.TrueFalseThe more effort it takes to implement or change your decision, the more it’s about design; the less effort, the more it’s about architecture.TrueFalseTrade-offs are the pros and cons of a given decision or task. The more significant the trade-offs become, the more it’s about architecture.\nSolution in “True or False Solution”\nBullet Points\nSoftware architecture is less about appearance and more about structure, whereas design is more about appearance and less about structure.\nYou need to use four dimensions to understand and describe software architecture: architectural characteristics, architectural decisions, logical components, and architectural style.\nArchitectural characteristics form the foundational aspects of software architecture. You must know which architectural characteristics are most important to your specific system, so you can analyze trade-offs and make the right architectural decisions.\nArchitectural decisions serve as guideposts to help development teams understand the constraints and conditions of the architecture.\nThe logical components of a software architecture solution make up the building blocks of the system. They represent things the system does and are implemented through class files or source code.\nLike with houses, with software there are many different architectural styles you can use. Each style supports a specific set of architectural characteristics, so it’s important to make sure you select the right one (or combination of them) for your system.\nIt’s important to know if a decision is about architecture or design, because that helps determine who should be responsible for the decision and how important it is.\nSoftware Architecture Crossword\nCongratulations! You made it through the first chapter and learned about what software architecture is (and isn’t). Now, why don’t you try architecting the solution to this crossword?\nAcross\n2. An architectural style determings the system’s overall _____\n4. _____-driven is an architectural style\n5. Architectural characteristics are sometimes called this\n10. Architectural decisions are usually _____ term\n12. If something takes a lot of _____ to implement, it’s probably architectural\n13. You’re learning about software _____\n15. You’ll make lots of architectural _____\n16. A system’s _____ components are its building blocks\n18. The number of rooms in your home is part of its _____\n19. Architecture and design exist on a _____\nDown\n1. Strategic decisions typically involve a lot of these\n3. Building this can be a great metaphor\n6. Decisions can be strategic of _____\n7. How many dimensions it takes to describe a software architecture\n8. A website’s user _____ involves lots of design decisions\n9. The overall shape of a house or a system, like Victorian or microservices\n11. It’s important to know whether a decision is about architecture or this\n13. You might want to become one after reading this book\n14. You analyze these when making an architectural decision\n17. Trade-offs are about the _____ and cons\nSolution in “Software Architecture Crossword Solution”\nFrom “Exercise”\nExercise Solution\nGardening is another useful metaphor for describing software architecture. Using the space below, can you describe how a garden might relate to software architecture?\nThe overall layout of a garden can be compared to the architectural style, whereas each grouping of like plants (either by type or color) can represent the architectural components. Individual plants within a group represent the class files implementing those components.\nGardens are influenced by weather in the same way a software architecture is influenced by changes in technology, platforms, the deploymnent environment, and so on. Also, if you don’t pay attention to the garden, weeds grow-just like structural decay within your architecture.\nFrom “Sharpen your pencil”\nSharpen your pencil Solution\nWhat features of your home can you list that are structural and related to its architecture?\nFrom “Exercise”\nExercise Solution\nCheck the things you think might be considered architectural characteristics—something that the structure of the software system supports.\nFrom “Who Does What?”\nWho Does What? Solution\nHere’s your chance to see how much you already know about many common architectural characteristics. Can you match up each architectural characteristic on the left with its definition on the right? You’ll notice there are more definitions than characteristics, so be careful—not all of the definitions have matches.\nFrom “BE the architect”\nBE the architect Solution\nYour job is to be the architect and identify as many architectural decisions as you can in the diagram below. Draw a circle around anything that you think might be an architectural decision and write what that decision might be.\nFrom “Sharpen your pencil”\nSharpen your pencil Solution\nYou’ve just created the following two components for a new system, and your development team wants to start writing class files to implement them. Can you create a directory structure for them so they can start coding?\nSolution in “Exercise Solution”\nFrom “Who Does What?”\nWho Does What? Solution\nWe were trying to describe our architecture, but all the puzzle pieces got mixed up. Can you help us figure out which dimension does what by matching the statements on the left with the software architecture dimensions on the right? Be careful—some of the statements don’t have a match because they are not related to architecture.\nFrom “Exercise”\nExercise Solution\nCheck all of the things that should be included in a diagram from an architectural perspective.\nFrom “Sharpen your pencil”\nSharpen your pencil Solution\nCircle all of the things that you think fall somewhere in the middle of the spectrum between architecture and design.\nFrom “Sharpen your pencil”\nSharpen your pencil Solution\nOh dear. We’ve lost all of our marbles and we need your help collecting them and putting them back in the right spot. Using the three questions in “Sharpen your pencil” as a guide, can you figure out which jar each marble should go in?\nFrom “Code Magnets”\nCode Magnets Solution\nWe had all of these magnets from our to-do list arranged from high effort to low effort, and somehow they all fell on the floor and got mixed up. Can you help us put them back in the right order based on the amount of effort it would take to make each change?\nFrom “Exercise”\nExercise Solution\nDecisions, decisions, decisions. How can we ever tackle all of these decisions? One thing we think might help is to identify the decisions that involve significant trade-offs, since those will require more thinking and will take longer. Can you help us by identifying which decisions have significant trade-offs and which ones don’t?\nFrom “True or False”\nTrue or False Solution\nSoftware Architecture Crossword Solution\nFrom “Code","metadata":{"id":8300259219081296,"pageNumber":8,"bookId":1}},{"text":"Chapter 2. Architectural Characteristics: Know Your Capabilities\nWhat does your architecture need to support? Architectural characteristics (the capabilities of an architecture) are the fundamental building blocks of any system. Without them, you cannot make architectural decisions, select an architectural style, or in many cases even create a logical architecture. In this chapter you’ll learn how to define some of the more common characteristics (like scalability, reliability, and testability), how they influence a software architecture, how they help you make architectural decisions, and how to identify which ones are important for your particular situation. Ready to add some capabilities to your software architecture?\nCausing Lafter\nSillycon Symposia is a startup with a Bay Area feel whose business plan combines technology-themed conferences with comedy. By gathering like minds, Sillycon provides unique offerings for each group and keeps them engaged by keeping them laughing.\nNote\nHow hard could it be to start a social networking site?!\nPart of the business plan includes building Lafter, a social media network related to (but not limited to) the conferences Sillycon hosts. The business stakeholders put together a requirements document for it:\nSillycon Symposia is hosting a social media network of like-minded technologists named Lafter.\nUsers: Hundreds of speakers, thousands of users\nRequirements:\nNote\nA pretty standard level of detail for a requirements document\nUsers can register for usernames and approve the privacy policy\nUsers can add new content on Lafter as a “Joke” (long-form post) or \t “Pun” (short-form post)\nFollowers can “HaHa” (indicating strong approval) or “Giggle” (a \t milder approval message) content they like\nSpeakers at Sillycon Symposia events have a special icon\nSpeakers can host forums on the platform related to their content\nUsers can post messages of up to 281 characters\nUsers can also post links to external content\nAdditional Context:\nInternational support\nVery small support staff\n“Bursty” traffic: extremely busy during live conferences\nCubicle conversation\nAlex: Look what just landed in my inbox—the Powers That Be want me to be the architect for the Sillycon Symposia social media app, Lafter.\nSam: You have the requirements? You should jump right into the design of the system—it seems really straightforward.\nMara: Well, you can really only do that for the simplest of applications, and I don’t think this one qualifies. Remember the diagram I drew on the whiteboard the other day?\nYou need to analyze both architectural characteristics and logical components before you can choose an architectural style as a starting point.\nYou can implement just about any application in any architectural style, but some are more suitable than others. Choosing the style before performing this type of analysis is a classic case of putting the cart before the horse.\nSam: Can’t we just be super-agile, start with something tiny, and then keep iterating on it until we have the entire system?\nMara: The iterative approach you talk about doesn’t quite work like that for architectural characteristics analysis. For example, it’s difficult to make a system highly scalable if it wasn’t designed for that.\nAlex: That makes sense. I guess I need to roll up my sleeves and analyze some architectural characteristics—thanks!\nWhat are architectural characteristics?","metadata":{"id":7912511626018379,"pageNumber":9,"bookId":1}},{"text":"You have a problem. You decide, “I’m going to write some software to solve this problem!” The thing you’re writing software about is called the domain, and designing for it will occupy much of your effort—that is, after all, why you’re writing software. However, it’s not the only thing an architect must consider—they must also analyze architectural characteristics. Here are a few examples of architectural characteristics that show how different domains have different, but often overlapping, architectural characteristics.\nNote\nThese make up one of the dimensions that help describe your architecture.\nDefining architectural characteristics\nPart of your job as an architect is structural design for software systems, for which there are two parts: logical components and architectural characteristics. Logical components represent the domain of the application—the motivation for writing the software system (we cover these in Chapter 4). If you combine architectural characteristics with logical components, you have the structural considerations for an architecture.\nArchitectural characteristics are the important parts of the construction process of a software system or application, irrespective of the problem domain. They represent its operational capabilities, internal structure decisions, and other necessary characteristics.\nWe’ll show you lots of examples of architectural characteristics in the upcoming pages, but first we want to cover the concept itself.\nWe define architectural characteristics in three parts, as shown here.\nLet’s look at each of these edges one at a time.\nCharacteristics are nondomain design considerations\nTo define architectural characteristics, we first need to look at what they are not. The requirements specify what the application should do; architectural characteristics specify operational and design criteria for success, how to implement the requirements, and why certain choices were made. For example, an application’s level of performance is an important architectural characteristic that often doesn’t appear in requirements documents.\nStructural design in architecture can be divided into domain and non-domain considerations. Architectural characteristics represent your design effort to create the capabilities necessary for the project to succeed.\nMara: OK, the business analysts and subject matter experts have toiled away to create both a requirements document and the beginning of a domain design. But we need to work with them to figure out what architectural characteristics we need to support.\nSam: Isn’t that part of the domain design? Why does an architect need to get involved at this point?\nAlex: Well, our business analysts have never worked on a software porject, so they probably won’t understand the impact of one decision versus another.\nMara: That’s correct—often what seems like a minor difference to a business person makes a big difference for an architect! What they want may turn out to be difficult to support in architecture. That’s why it’s important for architects to be involved early and often in the design process.\nSam: What kinds of things are we looking for?\nAlex: Part of the definition of architectural characteristics is “nondomain design considerations.” Let’s look at what they’ve designed and see if they’ve considered things like performance and scalability.\nCharacteristics influence architectural structure\nThe primary reason architects try to describe architectural characteristics has to do with architectural considerations: does this characteristic require special structural support to succeed? For example, security is a concern in virtually every project, and all systems must take baseline precautions during design and coding. However, security becomes an architectural characteristic when the architect needs to make a special effort to accommodate it.\nConsider the following potential architecture diagrams for Lafter, which include functionality for marketing upcoming promotions and rules for when each promotion applies. An architect could design this as a monolithic architecture—one with a single deployable unit and matching database—or as a series of independent services.\nFor the monolithic architecture, the entire application would have to be redeployed when the promotion rules change, because monoliths are built and deployed as a single unit. However, in a distributed architecture, only the Promotions service would be affected, and it could be redeployed independently.\nYou must consider many trade-offs when making architectural decisions, such as whether to use a monolithic versus distributed physical architecture.\nLimit characteristics to prevent overengineering\nApplications could support a huge number of architectural characteristics…but they shouldn’t. Every architectural characteristic the system must support adds complexity.\nThe sheer number and variety of architectural characteristics means there are many tempting choices. But as architects, we should try to pick as few architectural characteristics as possible, rather than as many as possible. This is because architectural characteristics are:\nImpossible to standardize\nDifferent organizations use different terms for the same architectural characteristics. For example, performance and responsiveness might indicate the same behavior.\nNote\nIt’s a good idea to create a “ubiquitous language” (shared vocabulary) for architectural characteristics within your organization—this gives you a fighting chance at creating a usable standard list.\nSynergistic\nArchitectural characteristics affect other architectural characteristics and domain concerns. For example, if you want to make an application more secure, the required changes will almost certainly affect performance negatively (more on-the-fly encryption and other similar changes will lead to performance overhead).\nNote\nYour takeaway? You often cannot choose one architectural characteristic without considering how it may affect others.\nOverabundant\nPossible architectural characteristics are extraordinarily abundant, and new ones appear all the time. For example, a few years ago there was no such thing as on-demand elasticity via a cloud provider.\nNote\nEven the number of categories of architectural characteristics has increased over the last few years, with additions such as cloud constraints and capabilities.\nNote\nWe’ll be discussing some categories of architectural characteristics soon.\nA common hazard for architects is overengineering: supporting too many architectural characteristics and complicating the overall design to little or no benefit. Knowing which architectural characteristics are critical or important to application success acts as a filtering tool. It help us eliminate features that would be nice to have but just end up adding needless complexity to the system.\nBeware of resume-driven development (RDD)! It’s fun to play with new stuff, and we should keep learning, but trying to support too many architectural characteristics in our systems will not align with larger priorities or help the application succeed.\nWatch it!\nSynergy can be dangerous!","metadata":{"id":2694408807635078,"pageNumber":9,"bookId":1}},{"text":"Architects would love to design for architectural characteristics irrespective of the domain design. Unfortunately, the real world refuses to cooperate. When we say that architectural characteristics are synergistic, we mean that changes to one might require changes to other architectural characteristics and/or the domain. No matter how clever you are, no architect can make every single architecture scalable. Some architectures can’t scale as successfully as others because of physical constraints such as memory and bandwidth.\nBe careful when you change one architectural characteristic; consider how that change may affect other parts of your architecture. The same applies to making changes to domain design, such as component boundaries and distribution—changes to the domain may synergistically affect your architectural characteristics. For example, if you change your application to begin storing users’ payment information, the security and data integrity architectural characteristics will also change.\nBrain Power\nMany things in the the real world are synergistic—that is, combining them yields something different than the sum of the parts. See if you can think of some real-world examples of synergy. Hint: These might include things that are still identifiable (like peanut butter and chocolate) or things that merge (such as emulsions like oil and vinegar).\nNote\nUse this space to jot down your ideas.\nConsider explicit and implicit capabilities\nSome things are explicit—stated clearly—whereas others are implicit—assumed based on context or other knowledge. Imagine if you saw a bunch of mail and packages piling up outside the door of a home—what conclusions would you draw?\nExplicit architectural characteristics are specified in the requirements for the application.\nImplicit architectural characteristics are factors that influence an architect’s decisions but aren’t explicitly called out in the requirements. Security is often an implicit architectural characteristic: even if it isn’t mentioned in the requirements, architects know that we shouldn’t design an insecure system.\nYou must use your knowledge of the problem domain to uncover these architectural characteristics during the analysis phase. For example, a high-frequency trading firm may not specify how critical it is for transactions to complete within milliseconds, but the architects in that problem domain know how important this is.\nthere are no Dumb Questions\nQ:What about important things like good internal structure that no one thinks to ask for?\nA: Some implicit architectural characteristics are more subtle, but just as important. For example, architects should pay attention to the application’s internal structure as developers create it, to ensure that sloppy coding and other deficiencies don’t degrade the longevity of the application. However, virtually no requirements list will specify “Don’t mess up the internal modularity of the system as you build it!” or “Make sure the software is maintainable!”\nThe International Zoo of “-ilities”","metadata":{"id":6497336497649473,"pageNumber":9,"bookId":1}},{"text":"Like the animals in a zoo, architectural characteristics exist along a broad spectrum. Just as animals range from primates to reptiles, architectural characteristics range from low-level code characteristics, such as modularity, to sophisticated operational concerns, such as scalability and elasticity. Unfortunately, there is no “universal list” of architectural characteristics, nor are there any real standards for what many of these terms mean (although people have tried). Instead, each organization interprets these terms for itself.\nAdditionally, the software ecosystem is constantly adding new concepts, terms, measures, and verifications, providing new opportunities to define even more architectural characteristics.\nSam: We’re supposed to define architectural characteristics for Lafter, but I can’t seem to find a standard list anywhere.\nAlex: Gosh, there are so many possibilities...\nMara: That’s why I like to categorize them. Remember the old zoo maps that broke the zoo into “houses” and “enclosures” for each type of animal? That same kind of categorization can work here. It’s sort of like the genus and species of architectural characteristics.\nProcess architectural characteristics\nProcess architectural characteristics are where the software development process intersects with software architecture. They reflect the decisions about the mechanics of building software.\nStructural architectural characteristics\nStructural architectural characteristics affect the internal structure of the software system, including factors like the degree of coupling between components and the relationships between different integration points.\nOperational architectural characteristics\nOperational architectural characteristics represent how architectural decisions influence what operational team members can do.\nCross-cutting architectural characteristics\nAs much as we’d like a nice, orderly zoo of architectural characteristics, platypuses still show up! Lots of important characteristics defy categorization.\nWho Does What?\nSo many architectural characteristics! We had a nice database that listed the ones that are most important for Lafter, along with their definitions, but somehow the index became corrupted and we lost the linkage. Can you help restore them by drawing a line from each architectural characteristic to its definition?","metadata":{"id":8631214295749645,"pageNumber":9,"bookId":1}},{"text":"scalabilityDescribes how well the components in the system create well-defined groupings and boundaries between components.deployabilityThe system’s ability to recover from problems such as a power, internet connection, or hardware failure.modularityHow easy is it for all users to access the system, including those with disabilities like colorblindness or hearing loss.robustnessHow easy it is for architects and developers to apply changes to enhance the system and/or fix bugs.accessibilityDescribes how well the system handles a large number of concurrent users while maintaining reasonable performance.maintainabilityDescribes the cadence, efficiency, and reproducibility of deployments.\nSolution in “Who Does What? Solution”\nthere are no Dumb Questions\nQ:Where can I find a standard list of architectural characteristics?\nA: No standard list really exists (despite several futile efforts) because the software development ecosystem constantly shifts and changes. Anyone trying to create a standard list is trying to hit a moving target.\nQ:Isn’t security required for every application?\nA: It depends! While it’s a common concern, if you design a free intra-office lunch-ordering system, the only security concern lies with others finding out that you order an egg salad sandwich every day.\nQ:Doesn’t every application require availabilty?\nA: You guessed it—it depends! Again, availability is a common concern for most applications, but if the mythical sandwich-ordering system mentioned above fails, the only real downside is that everyone has to get their own lunch.\nQ:Can I choose any combination of architectural characteristics for my application?\nA: Some architectural characteristics oppose one another. For example, architects find it challenging to design for both high performance and scalability. Determining the most important architectural characteristics for a system is only part of the design process. Combining them with logical component design will point you to an appropriate architectural style.\nQ:What does it mean if you don’t choose an architectural characteristic like availability in your requirements?\nA: The architectural characteristics you choose provide a guideline for the appropriate architectural style. If an architect doesn’t choose availability, it doesn’t mean they will purposefully design the system to have poor availability. Rather, it’s an indication of priority: trading off one architectural characteristic for another.\nExercise\nWelcome to “Take It or Leave It!” The rules of this game are simple—we’ll give you a business requirement that might come up for the Lafter application, and two architectural characteristics. As you know, everything in architecture is a trade-off, so if you attempt to optimize one, you probably won’t do as well with the other. Your job is to tell us which characteristic you rate as a higher priority for that requirement. You’ll find our thoughts at the end of the chapter.\n“We need to get this to market ASAP!”fault toleranceagility“Money’s tight, folks!”scalabilitysimplicity“Oh, wow, this conference is going to be our biggest yet.”high availabilitymaintainability“We want to start storing users’ credit card information.”securityrecoverability“This site is going to be very popular upon launch.”agilityelasticity\nSolution in “Exercise Solution”\nGeek Note\nThe software architecture world lacks a standard term for what we call architectural characteristics. Here are some of the terms people often use, and why we don’t care for them.","metadata":{"id":8600699133466339,"pageNumber":9,"bookId":1}},{"text":"Most teams still call them nonfunctional requirements, which is misleading because architectural characteristics are indeed functional—they just don’t concern the domain. Calling them nonfunctional downplays their importance. Other teams call them system quality attributes, which implies an activity that happens at the end of the project rather than the beginning. Another common name is cross-cutting requirements, which is the one we dislike the least—but it contains the word requirement, which entangles it with domain behaviors, which come from requirements, as opposed to capabilities, which are defined by architectural characteristics.\nArchitectural characteristics don’t just appear out of thin air.  In fact, there are three different sources from which you should look to derive them.\nThe problem domain\nPart of your job is analyzing a problem to determine what architectural characteristics the system requires. Many structural design decisions come directly from the problem domain.\nEnvironmental awareness\nMany requirements come from having a good understanding of the environment in which you’re operating. For example, are you working for a fast-moving startup, or a large enterprise with a lot at stake?\nNote\nRecall that some architectural characteristics are “implicit.” Many implicit characteristics emerge from these two sources.\nHolistic domain knowledge\nSure, you’re working with a particular problem domain—but we can assure you that the domain is a lot bigger than your particular focus. Let’s say you’re building out a payment system. While understanding what’s required of you is important, you’ll reveal architectural characteristics if you understand the financial world, finance industry regulations, and customers’ habits.\nLet’s look at each of these sources in turn.\nSourcing architectural characteristics from the problem domain","metadata":{"id":1715033357152816,"pageNumber":9,"bookId":1}},{"text":"Architects derive many of the necessary architectural characteristics from the problem domain—it is, after all, the motivation for writing the software in the first place. That means you must translate the items stated in requirements documents into their corresponding architectural characteristics. For example, the Lafter requirements specify “thousands of users.” As an architect, you must dig deeper to more accurately determine how many users are expected (scalability), how many of them will be there at the same time (concurrency), and how rapidly they’ll show up (elasticity).\nExercise\nDomain requirements are often a rich source of architectural characteristics. For example, our Lafter application needs to support large numbers of users, so scalability will be one necessary characteristic. Can you uncover more? Here are the requirements again:\nUsers: hundreds of speakers, thousands of users\nRequirements:Architectural characteristicsScalability________________________________________________________________________________________________________________________Additional Context:____________________________________________________________\nUsers can register for usernames and approve the privacy policy\nUsers can add new content on Lafter as a “Joke” (long-form \t post) or “Pun” (short-form post)\nFollowers can “HaHa” (indicating strong approval) or “Giggle” \t (a milder approval message) content they like\nSpeakers at Sillycon Symposia events have a special icon\nSpeakers can host forums on the platform related to their content\nUsers can post messages of up to 281 characters\nUsers can also post links to external content\nInternational support\nVery small support staff\n“Bursty” traffic: extremely busy during live conferences\nSolution in “Exercise Solution”\nSourcing architectural characteristics from environmental awareness\nYou know a lot about where you work (maybe too much, in some cases!), and that will naturally drive your architectural characteristics analysis. For example, an architect working for a fast-moving startup will prioritize agility whether it is specified or not.\nNote\nSorry, but this means you’re going to have to start paying attention in those business prioritization meetings!","metadata":{"id":1743019581521551,"pageNumber":9,"bookId":1}},{"text":"It is important to understand organizational priorities so we can make more durable decisions. For example, let’s say we must decide how to integrate two subsystems. The choices are a customized but highly suited protocol or an industry-standard protocol that will require a little more effort. In a vacuum, we might choose the first. However, if we know that the organization’s goal is to engage heavily in mergers with other companies, that fact could tip our decision toward the more open solution.\nNote\nArchitects can’t make decisions in a vacuum—context is always important.\nSourcing architectural characteristics from holistic domain knowledge\nNote\nSome architects stay within particular domains exactly because they have the advantage of domain knowledge.\nYou have also no doubt absorbed a lot of domain knowledge: information that isn’t explicitly spelled out in the requirements but that you implicitly understand about important aspects of the domain.","metadata":{"id":371856135215383,"pageNumber":9,"bookId":1}},{"text":"Suppose Lafter has decided to run a promotion at a local university to entice students to sign up (they go to a lot of conferences, and some of them have a sense of humor). We need to design an application that handles sign-ups for the promotion day. To make the math easy, assume that the school has 1,000 students and they have 10 hours to sign up. Should we design the system using a consistent scale, implicitly assuming that the students will distribute themselves evenly during the sign-up process? (Have we met any university students?)\nBased on real-world experience, we can guess that this won’t work. Think about what you know about the target demographic. Some students are hyperdiligent; some tend to procrastinate. Thus, the actual design must handle an elastic burst of students in the first hour (as the Type A individuals rush to get in line), stay mostly idle for the bulk of the day, and then handle another elastic burst just before the sign-up window closes, to accommodate all the stragglers.\nNote\nNever underestimate some university students’ ability to procrastinate.\nNote\nOne of the most dangerous discoveries in life is how much you can procrastinate and still (mostly) get the job done.\nArchitects must make use of all available information sources to understand the full range of trade-offs inherent in our architectural decisions.\nWatch it!\nSolutions versus requirements","metadata":{"id":6435240217579655,"pageNumber":9,"bookId":1}},{"text":"Customers often come to architects with solutions rather than requirements. For example, back in the 1970s, the US Air Force commissioned a fighter jet and included a requirement that it be capable of achieving speeds up to Mach 2.5. The designers tried, but the technology of the time just wasn’t sufficient to meet the requirement. They went back to the Air Force and asked: “Why does it need to go Mach 2.5?” The answer was, “Well, these things are expensive, so we want it to be able to flee a fight if necessary.” With that knowledge in mind, they went back and designed the F-16 fighter jet. It had a maximum speed of Mach 2.1, but it was the most maneuverable and fastest-accelerating jet ever created.\nWhen users bring us solutions rather than requirements, it’s architects’ job to imitate an annoying toddler and keep asking “But why?!?” enough times to uncover the actual requirements hidden within the solutions.\nExercise\nIt’s sometimes difficult to distinguish requirements from solutions. Here are some responses you might get when you ask “why?” that could indicate something might be one or the other. Can you identify which indicate requirements and which solutions?\n“We need a system to track user preferences and customizations, then save them between sessions.”\nrequirementsolutionrequirementsolutionrequirementsolutionrequirementsolution\n“Do we really need to build our own survey service? Surely we can find one that does what we need.”\n“An enterprise service bus would solve some of our current problems (albeit with some changes and work-arounds) and it offers extreme extensibility.”\n“According to the friendly sales rep, this software package does all the things accounting needs, now and in the near future.”\nSolution in “Exercise Solution”\nComposite architectural characteristics\nAlex: The business analyst asked if we can make sure the system is “reliable.” What do they mean?\nSam: Wow, I can think of a lot of ways to define “reliable” for a piece of software.\nMara: This happens a lot. A composite is a combination of two or more things, and often architectural characteristics combine with each other to create (seemingly) new ones. We call these composite architectural characteristics.\nWhat does reliable mean? We can measure many different aspects of reliability, like how available the system is, how consistent the user interface workflows are, and how well it handles data integrity.\nAlex: How do I identify these?\nMara: To identify composites, ask: “Can I objectively measure this architectural characteristic?” While we often discuss performance as a single value, it’s actually a composite—because we have to be more specific to get to something measurable. An example of a measurable architectural characteristic is first contentful paint, which measures the time it takes for a web page to load on a mobile device.\nPriorities are contextual\nIt’s impossible to choose the same set of architectural characteristics for every project. The set of architectural characteristics you choose for a particular application, and how you prioritize each one, will differ based on context.\nSharpen your pencil\nContext matters. At the top, we’ve listed several architectural characteristics. Below that are three application scenarios. For each scenario, rank each characteristic based on how important it is for that type of application. Hint: Some applications won’t need all of them.\nSolution in “Exercise Solution”\nCongratulations, you have yet another job. You’re right to be skeptical about how sophisticated an understanding your coworkers have of architectural concepts. That means you have one more job as an architect: translation!\nAs much as it would be nice for our colleagues to learn our language, architects are generally the ones who have to translate the business’s goals into identifiable and measurable architectural characteristics.\nLost in translation\nIt’s not unusual for business experts and analysts to state (or subtly suggest) a requirement without realizing it, hidden in plain English. It’s your job, as a software architect, to read between the lines, find the requirements, and translate them into architectural characteristics. Here are a few examples.\nMore requirements are NOT better.\nWhat happens when an architect takes a list of possible architectural characteristics for Lafter to a group of business users and asks them, “Which of these do you want for the system?”\nThey invariably answer: “All of them!”\nAs nice as it would be to be able to accommodate that request, it’s not a good idea to try.\nRemember, architectural characteristics are synergistic with each other and with the problem domain. That means the more architectural characteristics the system must support, the more complex its design must be.\nWhen undertaking structural design for a system, architects must find a balance between domain priorities and the architectural characteristics necessary for success.\nArchitectural characteristics and logical components\nBefore we tell you how to go about trying to balance architectural characteristics with each other and the domain, we want to show you how architectural characteristics and logical components are two sides of the same coin. You see, both of them aim to support the problem domain (also known as the reason you are writing software to begin with).\nArchitectural characteristics ≈ capabilities\nArchitectural characteristics describe the kinds of capabilities your solution will support, rather than the behavior of the application, which is based on requirements.\nLogical components = behavior\nLogical components, covered in depth in Chapter 4, represent the design of the system you are attempting to implement in software in order to solve the fundamental problem at hand.\nBalancing domain considerations and architectural characteristics\nArchitects use architectural characteristics and logical component analysis to determine the appropriate architectural style, and the Lafter application is no exception. You need to strike a balance between the two.\nNo architectural characteristics\nSometimes we don’t take the time to analyze architectural characteristics before designing the system, leading to expensive and time-consuming rework as we discover that our system fails to exhibit the necessary architectural characteristics.\nGood balance between…\nIn this scenario, we have achieved a balance in our design decisions between architectural characteristics and domain considerations.\n…architectural characteristics and domain considerations\nThis allows us to achieve operational and structural goals without overengineering.\nToo many architectural characteristics\nUnfortunately, architects sometimes retreat to an ivory tower and spend too much time analyzing architectural characteristics, or identifying too many of them to be useful. This leads to overengineering, wasting time and effort that could be spent on implementation and ongoing maintenance.\nLimiting architectural characteristics\nWhen the business stakeholders want all of the possible architectural characteristics, how can you limit their enthusiasm?\nThe magical number 7\nOne useful guideline for the conversation between architects and business analysts is to limit the number of architectural characteristics they can choose to seven. Why seven? Psychological research indicates that people remember items in chunks of seven (one of the reasons that early phone numbers were seven digits). It’s also large enough to provide some variety without creating a paradox of choice by offering too many.\nNote\n“The Magical Number Seven, Plus or Minus Two: Some Limits on Our Capacity for Processing Information” is a famous paper from 1956 by psychologist George Miller.\nWe created a worksheet to help architects work with other stakeholders to arrive at a reasonable number. This is a demo; you’ll get to use it on the next page.\nSharpen your pencil\nin “Exercise”, you identified architectural characteristics for Sillycon Symposia’s social media application, Lafter. To make sure you’ve achieved a good balance, limit your list to seven characteristics. Then, check the boxes next to the top three most important.\nPossible Candidate Architectural Characteristics\nperformancedata integritydeployabilityresponsivenessdata consistencytestabilityavailabilityadaptabilityconfigurabilityfault toleranceextensibilitycustomizabilityscalabilityinteroperabilityrecoverabilityelasticityconcurrencyauditability\nSolution in “Exercise Solution”\nBullet Points\nArchitectural characteristics represent one part of the structural analysis that architects use to design software systems. (We’ll talk abou the other part, logical components, in Chapter 4.)\nArchitectural characteristics describe a system’s capabilities.\nSome architectural characteristics overlap with operational concerns (such as availability, scalability, and so on).\nThere are many catagories of architectural characteristics. No one can make a comprehensive list, because the software development ecosystem is constantly changing.\nWhen identifying architectural characteristics, architects look for factors that influence structural design.\nArchitects should be careful not to specify too many architectural characteristics, because they are synergistic—changing one requires other parts of the system to change.\nSome architectural characteristics are implicit: not explicitly stated in requirements, yet part of an architect’s design considerations.\nSome architectural characteristics may appear in multiple categories.\nMany architectural characteristics are cross-cutting: they interact with other parts of (and decisions in) the organization.\nArchitects must derive many architectural characteristics from requirements and other domain design considerations.\nSome architectural characteristics come from domain and/or environmental knowledge, outside of the requirements of a specific application.\nSome architectural characteristics are composites: they consist of a combination of other architectural characteristics.\nArchitects must learn to translate “business speak” into architectural characteristics.\nArchitects should limit the number of architectural characteristics they consider to some small number, such as seven.\nCharacteristics Crossword\nReady to have some fun and test your knowledge about what you’ve learned? Try this crossword puzzle about architectural characteristics.\nAcross\n3. An architectural characteristic that might be implicit\n4. _____ engineering is an architectural problem\n8. Choosing architectural characteristics means assigning each one a _____\n9. Magic number of characteristics to ask for\n11. A nonfunctional requirement is also called an architectural _____\n15. Some architectural characteristics are _____-cutting\n17. What architects should ask when users suggest solutions instead of requirements\n18. A system might need to _____ up and down to meet demand\n19. _____ tolerance is an architectural demand\nDown\n1. Uneven traffic often comes in _____\n2. A Lafter post can be a “joke” or a “_____”\n3. Architectural characteristics influence the system’s _____\n5. Architectural characteristics can be explicit or _____\n6. _____ integrity is an architectural characteristic\n7. A site with large numbers of _____ users might need to be scalable\n10. Many governments regulate data _____\n12. An architectural characteristic is critical or important to the system’s _____\n13. Combining architectural characteristics and logical components gives you an architectural _____\n14. The thing you’re writing software about\n16. Web page loading time is often called “first contentful _____”\nSolution in “Characteristics Crossword Solution”\nFrom “Who Does What?”\nWho Does What? Solution\nSo many architectural characteristics! We had a nice database that listed the ones that are most important for Lafter, along with their definitions, but somehow the index became corrupted and we lost the linkage. Can you help restore them by drawing a line from each architectural characteristic to its definition?\nFrom “Exercise”\nExercise Solution\nWelcome to “Take It or Leave It!” The rules of this game are simple—we’ll give you a business requirement that might come up for the Lafter application, and two architectural characteristics. As you know, everything in architecture is a trade-off, so if you attempt to optimize one, you probably won’t do as well with the other. Your job is to tell us which characteristic you rate as a higher priority for that requirement.\nFrom “Exercise”\nExercise Solution\nDomain requirements are often a rich source of architectural characteristics. For example, our Lafter application needs to support large numbers of users, so scalability will be one necessary characteristic. Can you uncover more? Here’s what we came up with.\nFrom “Exercise”\nExercise Solution\nIt’s sometimes difficult to distinguish requirements from solutions. Here are some responses you might get when you ask “why?” that indicate something might be one or the other. Can you identify which indicate requirements and which solutions?\nFrom “Sharpen your pencil”\nExercise Solution\nContext matters. At the top, we’ve listed several architectural characteristics. Below that are three application scenarios. For each scenario, rank each characteristic based on how important it is for that type of application. Hint: Some applications won’t need all of them. Here are our rankings.\nFrom “Sharpen your pencil”\nExercise Solution\nin “Exercise”, you identified architectural characteristics for the Sillycon Symposia Lafter social media application. To make sure you have achieved a good balance, limit the number to seven. Then, check the boxes next to the top three most important.\nPossible Candidate Architectural Characteristics\nperformancedata integritydeployabilityresponsivenessdata consistencytestabilityavailabilityadaptabilityconfigurabilityfault toleranceextensibilitycustomizabilityscalabilityinteroperabilityrecoverabilityelasticityconcurrencyauditability\nCharacteristics Crossword Solution\nFrom “Characteristics","metadata":{"id":666167786135207,"pageNumber":9,"bookId":1}},{"text":"Chapter 3. The Two Laws of Software Architecture: Everything’s a Trade-Off\nWhat happens when there are no “best practices”? The nice thing about best practices is that they’re relatively risk-free ways to achieve certain goals. They’re called “best” (not “better” or “good”) for a reason—you know they work, so why not just use them? But one thing you’ll quickly learn about software architecture is that it has no best practices. You’ll have to analyze every situation carefully to make a decision, and you’ll need to communicate not just the “what” of the decision, but the “why.”\nSo, how do you navigate this new frontier? Fortunately, you have the laws of software architecture to guide you. This chapter shows you how to analyze trade-offs as you make decisions. We’ll also show you how to create architectural decision records to capture the “hows” and “whys” of decisions. By the end of this chapter, you’ll have the tools to navigate the uncertain territory that is software architecture.\nIt starts with a sneaker app\nArchana works for Two Many Sneakers, a company with a very successful mobile app where shoe collectors (“sneakerheads”) can buy, sell, and trade collectible sneakers. With millions of shoes listed, customers can find the shoes they really want or upload photos to help sell the ones they don’t.\nThe app’s initial architecture was a single service as shown below:\nThe Two Many Sneakers app knows to talk to the trading service to fetch and update data (like a photo of a mint-condition pair of Nikes). The trading service, in turn, fetches data and updates the database.\nBusiness is booming. Sneakerheads are always willing to change up their collections, and Two Many Sneakers’ customer base has grown quickly. Now customers are demanding real-time notifications, so they’ll know whenever someone lists a pristine pair of those Air Jordans they’ve been pining for.\nSecurity is always a concern in online sales. Nobody wants knockoffs, and credit card numbers need to be protected. To stay a few steps ahead of any scammers, Two Many Sneakers’ management team wants to prioritize improving the app’s fraud detection capabilities. They plan to use data analytics to help detect fraud by spotting anomalies in user behavior and filtering out bots.\nWork has already begun—all the team needs to do now is set up the trading service to notify the new notification and analytics services anytime something of interest happens in the app.\nWhat do we know so far?\nWe need to figure out how these services will communicate with one another. Let’s recap what we know (and don’t know) so far:\nThe current architecture is rather simple—the trading service talks to its own database, and that’s that. We need the trading service to send information to the notification service and the analytics service.\nWord in the office is that there’s a chance that the finance department (which is responsible for compliance) will want updates from the trading service. In other words, whatever architecture we come up with will need to be extensible.\nWe don’t know what data to send the notification and analytics services—do the two services get the same kind of data, or wildly different data? And we don’t know where things stand with finance, so that’s another unknown.\nTo be clear, there are some things we know and plenty we don’t. Welcome to the world of software architecture.\nNote\nAs the system’s architects, we need to identify its architectural characteristics. (You learned about those in Chapter 2.)\nSpeaking of architecture, we’ll be done, say, next Thursday—right?\nExercise\nWhich of the following architectural characteristics stand out as important for this particular problem? Hint: There are no right answers here, because there is a lot we don’t know or aren’t sure of yet. Take your best guess—we’ve provided our solution at the end of this chapter. We’ll get you started:\nSolution in “Exercise Solution”\nBrain Power\nAll the characteristics in the previous exercise sound pretty good, right? Seriously, who’d say no to upgradability?\nBut for each one, ask yourself—is this characteristic critical to the project’s success? Or is it a nice-to-have?\nWhat’s more, some characteristics conflict. A highly secure application with loads of encryption and secure connections probably won’t be highly performant. Go back and see if any of your choices are at odds. If so, you can only pick one.\nNote\nFlashback to Chapter 2? You bet it is!\nthere are no Dumb Questions\nQ:Even this simple exercise seems to have a lot of moving parts. We know some things, we think we know some other things, and there’s a lot that we certainly don’t know. How do we go about thinking about architecture?\nA: You’re right. In almost all real-life scenarios, your list of architectural characteristics will probably contain a healthy mix of “this is what we want” and “this is something we might want.” Even your customers can’t answer the question of what they will eventually want. (Wouldn’t that be nice?) This is the “stuff you don’t know you don’t know,” also known as the “unknown unknowns.”\nIt’s not unusual for an “unknown unknown” to rear its head midway through a project and derail even the best-laid plans. The solution? Embrace agility and its iterative nature. Realize that nothing, particularly software architecture, remains static. What worked today might prove to be the biggest hurdle to success tomorrow. That’s the nature of software architecture: it constantly evolves and changes as you discover more about the problem and as your customers demand more of you.\nCommunicating with downstream services\nOur goal is to get the trading system to notify the reporting and analytics systems automatically. For now, let’s assume we decide to use messaging. But that presents a dilemma—should our messaging use queues or topics?\nNote\nIt’s OK if you don’t know much about messaging, queues, or topics. We’ll tell you what you need to know.\nBefore we go further, let’s make sure we’re on the same page about the differences between queues and topics. Most messaging platforms offer two models for a publisher of a message (in this case, that’s the trading service) to communicate with one or more consumers (the downstream services).\nThe first option is a queue, or a point-to-point communication protocol. Here, the publisher knows who is receiving the message. To reach multiple consumers, the publisher needs to send a message to one queue for each consumer. If the trading service wants to use queues to tell the analytics service and the reporting service about trades, this is what the setup will look like:\nNote\nIf it helps, think of queues as being like a group text—you pick everyone you want to inform, type your message, and hit “send.”\nWhen using the second option, topics, you are signing on for a broadcasting model. The publisher simply produces and sends a message. If another service downstream wants to hear from the publisher, it can subscribe to the topic to receive messages. The publisher doesn’t know (or care) how many services are listening.\nNote\nTopics are similar to posting a picture on your go-to social networking site. Anyone following you will see that picture, since they’ve “subscribed” to your timeline.\nBoth options sound good—so how do we pick? Let’s find out.\nAnalyzing trade-offs\nYou can’t have your cake and eat it too. The world is full of compromises—we often optimize for one thing at the cost of another. Want to take and store lots of pictures on your phone? Either get more storage, which costs more, or compress them, which lowers the image quality.\nSoftware architecture is no different. Every choice you make involves significant compromises or, as we like to call them, trade-offs. So what exactly does this mean for you?\nNote\nIf this sounds familiar, it should be! It was part of our discussion of significant versus less-significant trade-offs in Chapter 1.\nIf you know which architectural characteristics are most important to your project, you can start thinking of solutions that will maximize some of those attributes. But if a solution lets you maximize one characteristic (or more), it will come at the cost of other characteristics. For example, a solution that allows for great scalability might also make deployability or reliability harder.\nNo matter what solution you come up with, it will come with trade-offs—upsides and downsides.\nYour job is twofold: know the trade-offs associated with every solution you come up with, and then pick the solution that best serves the most important architectural characteristics.\nNote\nRich Hickey, creator of the Clojure programming language, once said, “Programmers know the benefits of everything and the trade-offs of nothing.” We’d like to add: “Architects need to understand both.”\nYou can’t have it all. You’ll have to decide which architectural characteristics are most important, and choose the solution that best allows for those characteristics.\nTrade-off analysis: Queue edition\nTrade-off analysis isn’t just about finding the benefits of a particular approach. It’s also about seeking out the negatives to get the full picture. Let’s look at each option in turn, starting with queues.","metadata":{"id":7434618506217437,"pageNumber":10,"bookId":1}},{"text":"With queues, for every service that the trading service needs to notify, we need a separate queue. If the notification service and the analytics service need different information, we can send different messages to each queue. The trading service is keenly aware of every system to which it communicates, which makes it harder for another (potentially rogue) service to “listen in.” (That’s useful if security is high on our priority list, right?) Oh, and since each queue is independent, we can monitor them separately and even scale them independently if needed.\nThe trading service is tightly coupled to its consumers—it knows exactly how many there are. But we’re not sure if we’ll need to send messages to the compliance service, too. If that happens, we’ll have to rework the trading service to start sending messages to a third queue. In short, if we choose queues, we’re giving up on extensibility.\nSee what we mean when we say “trade-off analysis”?\nTrade-off analysis: Topic edition\nWhat about using topics? Well, the upside is clear—the trading service only delivers messages to a topic, and anyone interested in listening for a message from the trading service simply subscribes to that topic. Compliance wants in? They can simply subscribe: no need to make any changes to the trading service. Low coupling for the win.\nBut topics have a few downsides, too. For one thing, you can’t customize the message for any particular service—it’s a one-size-fits-all, take-it-or-leave-it proposition. Scaling, too, is one-size-fits-all, since you have only one thing to scale. And anyone can subscribe to the topic without the trading service knowing—which, in some circumstances, is a potential security risk.\nBack to the whiteboard!\nSharpen your pencil\nSpend a few minutes comparing the results of our trade-off analysis. Notice how both options support some characteristics but trade off on others? Now we’re going to present you with some requirements—see if you can decide if you’d pick queues or topics to support each one.\nRequirements“Security is important to us.”Queues / Topics“Different downstream services need different kinds of information.”Queues / Topics“We’ll be adding other downstream services in the future.”Queues / Topics\nSolution in “Exercise Solution”\nThe first law of software architecture\nQueues or topics? Enough with the suspense already. The answer is—it depends!\nWhat’s important to the business? If security is paramount, we should probably go with queues. Two Many Sneakers is growing by leaps and bounds and has loads of other services interested in its sneaker trades, so extensibility is its biggest priority. That means we should pick the topic option.\nTime is also a factor: if we need to get to market quickly, we might pick a simpler architecture (simplicity) over one that offers high availability. (Having an application that guarantees three “nines” of uptime only matters if you have customers, right?)\nThe key takeaway is that in software architecture, you’ll always be balancing trade-offs. That leads us to the First Law of Software Architecture.\nIn software architecture, nice, clean lines are rare and there are no “best practices.” Every choice you make will involve many factors—often conflicting ones. The First Law is an important lesson, so take it to heart. Write it down on a sticky note and put it on your monitor. Get a backwards tattoo of it on your forehead so you’ll see it in the mirror! Whatever it takes.\nNote\nIf you find a decision in software architecture that doesn’t have a trade-off, you haven’t looked at it hard enough.\nSharpen your pencil","metadata":{"id":1549242873332695,"pageNumber":10,"bookId":1}},{"text":"This time, we’d like you to do some trade-off analysis on your own. We chose messaging as the communication protocol between our trading service and its consumers. Messaging is asynchronous. Choosing between asynchronous and synchronous forms of communication comes with its own set of trade-offs! We’ve given you two whiteboards, one for each form of communication, and we’ve listed a bunch of “-ilities.” We’d like you to consider how each architectural characteristic would work in both contexts. Is this characteristic a pro or a con (or neither) in synchronous communications? What about in asynchronous communications? Place each “-ility” in the appropriate column. Hint: Not all of them apply to this decision. We put the first pro on the whiteboard for you. When you’re done, you can see our answers at the end of the chapter.\nSolution in “Sharpen your pencil Solution”\nthere are no Dumb Questions\nQ:I’ve heard of the Architecture Tradeoff Analysis Method (ATAM). Is that what you’re talking about?\nA: ATAM is a popular method of trade-off analysis. With ATAM, you start by considering the business drivers, the “-ilities,” and the proposed architecture, which you present to the stakeholders. Then, as a group, you run through a bunch of scenarios to produce a “validated architecture.” While ATAM offers a good approach, we believe it comes with certain limitations—one being that it assumes the architecture is static and doesn’t change.\nRather than focusing on the process of ATAM, we prefer to focus on results. The objective of any trade-off analysis should be to arrive at an architecture that best serves your needs. You’ll probably go through the process several times as you discover more and more about the problem and come up with different scenarios.\nAnother popular approach is the Cost Benefit Analysis Method (CBAM). In contrast to ATAM, CBAM focuses on the cost of achieving a particular “-ility.”\nWe recommend you look at both methods and perhaps consider combining them—ATAM can help with trade-off analysis, while CBAM can help you get the best return on investment (ROI).\nJust remember—the process is not as important as the goal, which is to arrive at an architecture that satisfies the business’s needs.\nIt always comes back to trade-offs\nSome people always pick a particular technique, approach, or tool regardless of the problem at hand. Often they choose something they’ve had a lot of success with in the past. Sometimes they have what we affectionately call “shiny object syndrome,” where they think that some new technology or method will solve all their problems.\nRegardless of past achievements or future promises, just remember—for every upside, there’s a downside. The only questions you need to answer are “Will the upsides help you implement a successful application?” and “Can you live with the downsides?”\nWhenever someone sings the praises of a certain approach, your response should be: “What are the trade-offs?”\nNote\nTo be clear, we aren’t saying you shouldn’t use new tools and techniques. That’s progress, right? Just don’t forget to consider the trade-offs as you decide.\nMaking an architectural decision\nDebating the pros and cons with your team in front of a whiteboard is fun and all, but at some point, you must make an architecturaldecision.\nWe mentioned architectural decisions in Chapter 1, but let’s dive a little deeper. As you architect and design systems, you will be making lots of decisions, about everything from the system’s overall structure to what tools and technologies to use. So what makes a decision an architectural decision?\nIn most cases, any choice you make that affects the structure of your system is an architectural decision. Here are a couple of example decisions:\nNote\nTo jog your memory, picking whether you’d like a one- or two-story house would be an architectural decision.\nNotice how these decisions act as guides rather than rules. They aid teams in making choices, without being too specific. Most (but not all) of the architectural decisions you’ll make will revolve around the structure of your systems.\nNote\nAs we put it in Chapter 1: “Architectural decisions serve as guideposts to help development teams understand the constraints and conditions of the architecture.”\nWhat else makes a decision architectural?\nUsually, architectural decisions affect the structure of an architecture—are we going with a monolith, or will we leverage microservices? But every so often, you might decide to maintain a particular architectural characteristic. If security is paramount, for example, Two Many Sneakers might make a decision like this:\nAt other times, you might decide on a specific tool, technology, or process if it affects the architecture or indirectly helps you achieve a particular architectural characteristic. For example:\nEverything in this chapter so far has led to this important moment—making an architectural decision. You start with a trade-off analysis. Then you consider the pros and cons of each option in light of other constraints, like business and end user needs, architectural characteristics, technical feasibility, time and budgetary constraints, and even development concerns. Then, finally, you can make a decision.\nGeek Note","metadata":{"id":3335202269611666,"pageNumber":10,"bookId":1}},{"text":"Michael Nygard, author of the book Release It! (Pragmatic Programmer), defines an architecturally significant decision as “something that has an effect on how the rest of the project will run” or that can “affect the structure, non-functional characteristics, dependencies, interfaces, or construction techniques” of the architecture. To learn more, we recommend reading his blog post, “Documenting Architecture Decisions” (https://www.cognitect.com/blog/2011/11/15/documenting-architecture-decisions).\nYou bring up several good points. It’s important to record our decisions in a more permanent way. In addition, trade-off analysis is an involved process. It’d be a real waste if we lost all that work just because someone got a little hasty with the eraser.\nBut you make another key observation: while the decision itself is important, why we made that decision might be even more important. Which leads us to...\nThe second law of software architecture\nMaking decisions is one of the most important things software architects do.\nLet’s say you and your team do a trade-off analysis and conclude that you’re going to use a cache to improve your application’s performance. The result of your analysis is that your system starts using a cache somewhere. The what is easy to spot.\nThat decision is important, but so are the circumstances in which you made the decision, its impact on the team implementing it, and why, of all the options available to you, you chose what you did.\nThis leads us to the Second Law of Software Architecture.\nYou see, future architects (or even “future you”) might be able to discern what you did and even how you did it—but it’ll be very hard for them to tell why you did it that way. Without knowing that, they might waste time exploring solutions you’ve already rejected for good reasons, or miss a key factor that swayed your decision.\nThis is why we have the Second Law. You need to understand and record the “why” of each decision so it doesn’t get lost in the sands of time.\nSo how do we go about capturing architectural decisions? We’ll dive into that next.\nArchitectural decision records (ADRs)\nDo you remember everything you did last week? No? Neither do we. This is why it’s important to document stuff—especially the important stuff.\nThanks to the Second Law of Software Architecture, we know we need a way to capture not just the decision, but the reason we made it. Architects use architectural decision records (ADRs) to record such decisions because it gives us a specific template to work with.\nNote\nWe cannot emphasize enough how important keeping these records is.\nAn ADR is a document that describes a specific architectural decision. You write one for every architectural decision you make. Over time, they’ll build up into an architectural decision log. Remember that architectural decisions form the second dimension to describe your architecture. ADRs are the documentation that supports this dimension.\nAn ADR has seven sections: Title, Status, Context, Decision, Consequences, Governance, and finally Notes. Every aspect of an architectural decision, including the decision itself, is captured in one of these sections. Let’s take a look, shall we?\nCubicle conversation\nAlex: Doing the trade-off analysis between queues and topics took it out of me.\nMara: Me too. Trade-off analysis can be arduous, but I’m glad we got it done. This is a big architectural decision. It’s crucial that we understand the pros and cons of every choice.\nSam: Yeah, yeah. So we decided to use queues, right? Now can we get back to programming?\nMara: Slow down a second. You’re right—we’ve made a decision. Now we should record our decision in an ADR.\nNote\nGuess what? You’re going to be helping the team write their ADR. Keep an eye out for those exercises\nSam: But why? We already know what we’re going to do. That seems like a lot of work.\nAlex: Look, we know why we chose to go with queues. It’s the option that best supports the architectural characteristics we want to maximize in the system, right?\nMara: Correct. But while we know why we made that decision, what about anyone else who might come along and wonder why we chose queues over topics, like future employees? That’s why we should record our thinking.\nSam: I can see that being useful.\nAlex: Great! So can we start drafting our ADR?\nWriting ADRs: Getting the title right\nEvery ADR starts with a title that describes the decision. Craft this title carefully. It should be meaningful, yet concise. A good title makes it easy to figure out what the ADR is about, which is especially handy when you’re frantically searching for an answer!\nLet’s dive deeper into what a good ADR title looks like. Imagine a team is writing a service that provides surveys to customers. They’ve done a trade-off analysis and have decided to use a relational database to store survey results. Here’s what their ADR title might look like:\nThe title should consist mostly of nouns. Keep it terse: you’ll have plenty of opportunities to go into detail later. It should describe what the ADR is about, much like the headline of a news article or blog post. Get that right, and the rest will follow.\nThe title should start with a number—we suggest using three digits, with leading zeros where needed. This allows you to number your ADRs sequentially, starting with 001 for your first ADR, all the way to 999. Every time you add a new ADR, you increment the number. This makes it easy for anyone reading your records to know which decisions came before others.\nthere are no Dumb Questions\nQ:What happens if we end up writing more than 999 ADRs?\nA: That’s a lot of ADRs! If that were to happen, you’d need to revise a bunch of titles (and potentially filenames). In our experience, a three-digit prefix is plenty.\nQ:Can I reuse an ADR number?\nA: Every ADR should get a unique identifier. This makes it easier to reference them without confusion.\nNote\nMore about this when we discuss the Status section.\nExercise\nIn the following exercises, you’re going to help the team at Two Many Sneakers write an ADR. They’ve decided to use asynchronous messaging, with queues between the trading service and downstream services. Assume this is the 12th ADR the team is writing. What title would you give this ADR? Don’t forget to number it! Use this space to jot down your thoughts. You can see what we came up with at the end of this chapter.\nSolution in “Exercise Solution”\nWriting ADRs: What’s your status?\nGreat! You’ve settled on a descriptive title. Next, you’ll need to decide on the status of your ADR. The status communicates where the team stands on the decision itself.\nBut wait—isn’t the point of the ADR to record a decision? Well, kinda. But making decisions is a process.\nADRs do record architectural decisions, but they also act as documentation, making it easier to share and collaborate. Others might need to look at or even sign off on an ADR. Let’s start by considering the different statuses an ADR can have.\nRequest for Comment (RFC)\nUse this status for ADRs that need additional input—perhaps from other teams or some sort of advisory board. Usually, these ADRs affect multiple teams or address a cross-cutting concern like security. An ADR in RFC status is typically a draft, open for commentary and critique from anyone invited to do so. An ADR in RFC status should always have a “respond by” deadline.\nNote\nThis is like planning an evening out. You know you’d like to go out and which friends you want to invite, but you hope they’ll suggest a restaurant.\nNote\nYou ask everyone to respond by Tuesday so you can make reservations. (The deadline is important, since Ted can never make up his mind about anything.)\nProposed\nAfter everyone has a chance to comment, the ADR’s status moves to Proposed. This means the ADR is waiting for approvals. You might edit it or even overhaul the decision if you discover a limitation that makes it a no-go. In other words, you still haven’t made a decision, but you’re getting there.\nNote\nYou have a plan for the evening, but you haven’t hit “send” on the invite yet—just in case the weather turns.\nAccepted\nDoes exactly what it says on the tin. A decision has been made, and everyone is on board who needs to be. An Accepted status also tells the team tasked with implementing this decision that they can get started.\nNote\nOh yeah. Everyone has RSVP’d. Time to find a cool outfit!\nIf there’s no need for feedback from others, you can set the ADR’s status to Accepted as soon as the decision is made. Most ADRs stay at Accepted, but there is one more status to be aware of: Superseded.\nYou’ve arrived at a decision, which you diligently record in an ADR. Signed, sealed, delivered—you’re done.\nBut then things change.\nMaybe the business is growing and the board decides to focus more on scalability than on time to market. Maybe the company is entering international markets and needs to comply with EU data privacy and retention regulations. Whatever the reason, the decision you made is no longer appropriate. What now?\nWell, you write another ADR. The old ADR is superseded by the new one, and you record it as such. Suppose the customer survey team realizes that a relational database is no longer fulfilling their needs, so they do another trade-off analysis and decide to switch to a document store. Here are the titles and statuses of the old and new ADRs:","metadata":{"id":8062448243841223,"pageNumber":10,"bookId":1}},{"text":"An accepted ADR can move into Superseded status if a future ADR changes the decision it documents. It’s important for both ADRs to highlight which ADR did the superseding and which ADR has been superseded. This bidirectional linking allows anyone looking at a superseded ADR to quickly realize that it’s no longer relevant, and tells them exactly where to look for details on the new decision. Anyone looking at the superseding ADR can follow the link back to the superseded ADR to understand everything involved in solving that particular problem.\nNote\nLinking ADRs is an important part of a project’s “memory.” It helps everyone remember what has already been tried.\nthere are no Dumb Questions\nQ:All this superseding and numbering seems overly complicated. Why not just edit the original ADR?\nA: We use a three-digit prefix in the ADR title because it helps sequence things. Let’s say ADR 007 no longer applies to your situation, but you’ve made a bunch of architectural decisions in the meantime. The last ADR in your architectural decision log is ADR 013.\nNow you need to reevaluate ADR 007. Say you choose to edit it, as opposed to superseding it with ADR 014. What would happen?\nChronologically speaking, you amend ADR 007 after accepting ADR 013. But if someone tried to follow the decision process by reading the ADRs, they’d be seeing them in the wrong order! Readers might think that the new decision came first. It wouldn’t convey that you made one decision and then had to change it for some reason. Giving it a new number makes it clear that the old ADR 007 was no longer relevant after ADR 013. Confused yet?\nQ:So you’re telling me that an Accepted ADR is immutable: once accepted, it is not permitted to change. Is that right?\nA: Look at you! That’s exactly it. Except for when the status of an ADR goes from Accepted to Superseded, a decision recorded in an ADR is immutable. Sure, you might edit the ADR to include additional information, but for the most part, other than the status, things shouldn’t change much.\nExercise\nIn the previous exercise, you hashed out the title of Two Many Sneakers’ ADR about using queues for messaging. Let’s say you get the green light. Write down the title you chose in the space below and give your ADR a status:\nTitle: _________________________________________________________________________\nStatus: _________________________________________\nThree months later:\nWhoops! The requirements have changed. Your latest trade-off analysis reveals that topics would be a better fit. Everyone has signed off on this, so you need to supersede your ADR with a new ADR. This is the 21st ADR your team has worked on. Write down the title and the new status of the old ADR:\nTitle: _________________________________________________________________________\nStatus: _________________________________________\nNow write down the title and status of the newly introduced ADR:\nTitle: _________________________________________________________________________\nStatus: _________________________________________\nSolution in “Exercise Solution”\nWriting ADRs: What’s your status? (recap)\nThere’s a lot going on with ADR statuses, so we’ve created a handy visualization to help you out.\nWriting ADRs: Establishing the context\nContext matters. Every decision you’ve ever made, you made within a certain context and with certain constraints. When you chose what to have for breakfast this morning, the context might have included how hungry you were, how your body felt, your lunch plans, and whether you’re trying to increase your fiber intake. It’s no different for software architecture.\nThe Context section in the ADR template is your place to explain the circumstances that drove you to make the decision the ADR is capturing. It should also capture any and all factors that influenced your decision. While technological reasons will usually find their way onto this list, it’s not unusual to include cultural or political factors to help the reader understand where you’re coming from.\nSharpen your pencil\nContinue building out the ADR for Two Many Sneakers. Use the space below to write a Context section for the team’s decision to use queues for communication between the trading service and other services. (Then compare it with our take at the end of this chapter.)\nSolution in “Sharpen your pencil Solution”\nthere are no Dumb Questions\nQ:What about all that time and effort I spent on the whiteboard? Is that part of the context?\nA: If you need to document your trade-off analysis, we suggest you introduce a new section called “Alternatives.” In it, list all the alternatives you considered, followed by your lists of pros and cons.\nUsing a separate section to detail the trade-off analysis delineates it cleanly and avoids cluttering the Context section.\nWriting ADRs: Communicating the decision\nWe’ve finally arrived at the actual decision. Let’s start by looking at the customer survey team’s completed Decision section:\nIf this ADR’s status is RFC or Proposed, the decision hasn’t been made (yet). Even so, the Decision section starts by clearly expressing the decision being made. The tone of the writing should reflect that. It’s best to use an authoritative voice when stating the decision, with active phrases like “we will use” (as opposed to “we believe” or “we think”).\nThe Decision section is also the place to explain why you’re making this decision, paying tribute to the Second Law of Software Architecture: “Why is more important than how.” Future you, or anyone else who reads the ADR, will then understand not just the decision but the justification for it.\nNote\nIn the Context section, you explained why this decision was on the table. The Decision section, which immediately follows it, explains the decision itself. Together, they allow the reader to frame the decision correctly.\nNote\nThis is also a great place to list others who signed off on this decision. For example, “The marketing department requires...” is an example of CYA.\nNote\n“Cover Your Assets”! :)\nWatch it!\nThe ADR is not an opinion piece\nRemember that the ADR is not a place for anyone’s opinions on the state of things. It’s easy to slip into that mode, especially when justifying a decision. Even when explaining context, it can sometimes be hard to stay objective.\nTreat an ADR like a journalist treats a news article—stick to the facts and keep your tone neutral.\nExercise\nIt’s time for you to write the Decision section of the ADR for Two Many Sneakers. Here are the main factors the team considered when making their decision:\nQueues allow for heterogeneous messages.\nSecurity is an important architectural characteristic for the stakeholders.\nWe’ve given you some space to write out a Decision section, including the corresponding justification. This section should answer the question, “Why queues?” Hint: Be sure to focus on the decision and the “why.” See the solution at the end of the chapter for our own take.\nNote\nFeel free to glance back at the trade-off analysis we did earlier in the chapter to refresh your memory.\nSolution in “Sharpen your pencil Solution”\nthere are no Dumb Questions\nQ:I’m not entirely clear on the difference between the context and the “justification” we provide in the Decision section. Aren’t those the same thing?\nA: Maybe an example will help. Say it’s your best friend’s birthday, and you and a few others decide to go out to a fancy dinner to celebrate. That’s the context—the circumstances surrounding the decision you have to make.\nBefore you decide on the details, you might make a list of possible restaurants (the alternatives available to you), thinking about how well the cuisines they offer match everyone’s preferences. This would be akin to a trade-off analysis.\nYou pick a pan-Asian bistro: that’s the decision. You choose that particular restaurant because its menu has vegetarian and gluten-free options, and it allows anyone with dietary restrictions to make substitutions. That’s the justification for your decision.\nWriting ADRs: Considering the consequences\nEvery decision has consequences. Did you work out extra hard yesterday? If so, you might be sore this morning. (But maybe a little bit proud of yourself, too!)\nIt’s important to realize the consequences—good and bad—of architectural decisions and document them. This increases transparency by ensuring that everyone understands what the decision entails, including the team(s) affected by it. Most importantly, it allows everyone to assess whether the decision’s positive consequences will outweigh its negative consequences.\nThe consequences of an ADR can be limited in scope or have huge ramifications. Architectural decisions can affect all kinds of things—teams, infrastructure, budgets, even the implementation of the ADR itself. Here’s an incomplete list of questions to ask:\nHow does this ADR affect the implementing team? For instance, does it change the algorithms? Does it make testing harder or easier? How will we know when we’re “done” implementing it?\nDoes this ADR introduce or decommission infrastructure? What does that entail?\nAre cross-cutting concerns like security or observability affected? If so, what effects will that have across the organization?\nHow will the decision affect your time and budget? Does it introduce costs or save money? Will it take arduous effort to implement or make things easier?\nNote\nTime and money are big—be sure to think this one through!\nNote\nOf course, the ADR might make things simpler and more cost-effective. If so, that’s definitely worth highlighting.\nDoes the ADR introduce any one-way paths? (For example, using queues means we can’t control the order of messages.) If so, elaborate on this.\nCollaborating withothers is a great way to make sure your assessment is thorough. No matter how hard you think through the consequences of the ADR, you’re likely to miss a few things; multiple perspectives will reveal more potential consequences. Here’s a sample Consequences section:\nSharpen your pencil\nHelp the Two Many Sneakers team iron out the Consequences section of their ADR. Here are a few things to think about:\nA queue introduces a new piece of infrastructure.\nThe queues themselves will probably need to be highly available.\nNote\nThere are no right or wrong answers, but if you’d like to see how we approached this, glance at the solution at the end of the chapter.\nQueues mean a higher degree of coupling between services.\nSolution in “Sharpen your pencil Solution”\nBrain Power\nThink about an architectural decision made in your current project, or one you’ve worked on in the past. It might be programming language used, the application’s structure, or even the choice of database. Can you think of at least two intended consequences and two unintended consequences of that decision?\nWriting ADRs: Ensuring governance\nHave you ever made a New Year’s resolution that fizzled out before the end of February? Maybe you joined a gym, only to end up paying but never working out? Us too. A decision is only good if you act on it, and if you don’t accidentally stray away from it in the future.\nSure, you and your team spent a bunch of time analyzing trade-offs and writing an ADR to record the decision. Now what? How do you ensure that the decision is correctly implemented—and that it stays that way?\nThis is the role of the Governance section, which is vital in any ADR. Here, you outline how you’ll ensure that your organization doesn’t deviate from the decision—now or in the future. You could use manual techniques like pair programming or code reviews, or automated means like specialized testing frameworks.\nNote\nThese two sections aren’t part of the standard ADR template, but we think they add a lot of value.\nNote\nIf the word “governance” conjures up ideas of regulatory compliance, well, this isn’t that.\nNote\nOne of your authors has written a book called “Building Evolutionary Architectures” that shows you how to use “fitness functions” for architectural governance. Be sure to pick up a copy. (After you’re done with this book, of course!)\nWriting ADRs: Closing notes\nThe Notes section contains metadata about the ADR itself. Here’s a list of fields we like to include in our ADRs:\nOriginal author\nApproval date\nApproved by\nSuperseded date\nLast modified date\nModified by\nLast modification\nNote\nThis section is handy even if the tool you use to store your ADRs automatically records things like creation and modification dates. Yes, including this information may be repetitive, but making it part of the ADR makes it easier to discover.\nExercise\nLet’s bring it all together! You’ve been working piecemeal on the ADR for the Two Many Sneakers team. We’d like you to flip back to the past few exercises and copy your ADR sections onto this page to create a full ADR. We’ve given you the section titles—all you have to do is fill ’em out. (Assume the status to be “Accepted.”) You can find our version at the end of the chapter.\nSolution in “Exercise Solution”\nthere are no Dumb Questions\nQ:I really like the ADR template. But where am I supposed to store my ADRs?\nA: There are lots of options—it all depends on what you and your team are comfortable with, and who else might be interested in reading or contributing to the ADRs.\nOne option is to store ADRs in plain-text files (or maybe Markdown or AsciiDoc files) in a version-control system like Git. This way, there’s a commit history showing any changes to the ADRs. The downside is that nondevelopers don’t always know how to access version-controlled documents. If you do choose to store your ADRs this way, we recommend keeping them in a separate repository (as opposed to stuffing them in with your source code). You’ll thank us later.\nAlternatively, you could use a wiki. Most wikis use a WYSIWYG (“what you see is what you get”) editor, so they’re accessible to more people. Just be sure that your choice of wiki can track changes. You wouldn’t want someone to edit an ADR accidentally without everyone knowing.\nWhatever you choose, make sure it’s easy to add, edit, and search for ADRs. We’ve seen too many honest efforts at recording ADRs die just because no one could find the ADRs again if their lives depended on it.\nQ:My whole team loves Markdown. (Plain text for the win!) Any advice on file naming conventions?","metadata":{"id":2204198205125711,"pageNumber":10,"bookId":1}},{"text":"A: Recall that ADR titles have a three-digit prefix, followed by a very succinct description of the ADR. If you store your ADRs as plain-text files, we recommend using the title as your filename, including the prefix. For example, an ADR with the title “042: Use queues between the trading and downstream services” should be stored in a file named 042-use-queues-between-the-trading-and-downstream-services.md. We like using all lowercase letters, which avoids any confusion between different operating systems. Replace spaces with hyphens to avoid whitespace.\nThis forces you to come up with good titles! And the three-digit prefix means you can simply sort the files in a folder by name to put them in the right order.\nQ:Can you recommend any tools that make it easier to write and manage ADRs?\nA: Oh, sure! There are many options, from command-line tools to language-specific tools that allow you to record ADRs directly in your source code. You can see a list of available tools at https://adr.github.io/#decision-capturing-tools.\nMost third-party tools make assumptions about the format of the ADR—perhaps they generate Markdown files or store the files in a specific directory structure. Test-drive a tool a few times to get a feel for it.\nFinally, some age-old advice: keep it simple, silly. We suggest you start by writing out ADRs without any complicated tooling or automation. Get a sense of what works best for your team. Then, as your needs grow, go find a tool that fits those needs.\nQ:Do ADRs always belong to a single project, or can they affect multiple projects and teams? How about the whole organization?","metadata":{"id":4540543593199976,"pageNumber":10,"bookId":1}},{"text":"A: Yes, yes, and yes. ADRs can be as narrow or as broad as you’d like them to be. Some ADRs are project-specific, affecting only one team. Other ADRs affect many or all teams in an organization. At the online retailer Amazon, there’s an ADR affectionately referred to as “the Jeff Bezos API mandate.” It records a decision that company founder Jeff Bezos once made: that all services within Amazon can only talk to other services via an API. Naturally, this affected the entire organization—no small feat, given Amazon’s size.\nMost cross-project or cross-team ADRs require a lot of collaboration, and often the blessing of a central architecture review board. Such ADRs tend to affect cross-cutting concerns, like how services should communicate with one another or which data transfer protocol to use. ADRs related to security or regulatory compliance often cut across multiple teams or a whole organization.\nThe benefits of ADRs\nWe hope we’ve convinced you by now that recording your decisions in ADRs need not be a long, arduous process. We really like the format we’ve shown you in this chapter, but feel free to tweak or modify it.\nIs recording architectural decisions really that important? We certainly think so! There are tons of benefits to recording these decisions—not just for you and your team, but for your entire organization. Let’s quickly recap.\nWatch it!\nKeep the ADR process as frictionless as possible\nIt’s tempting to add sections to the ADR template in the hope of being comprehensive. While that’s a noble goal, it adds work. If you keep “feeding the beast,” the documentation process gets harder. That can discourage people, and some might stop writing ADRs altogether.\nFocus on concision and brevity. Keep it simple. You’ll thank us later.\nTwo Many Sneakers is a success\nThe team at Two Many Sneakers is ecstatic. Their customers love getting real-time notifications about new offerings in the app, and the improved analytics are giving the security team the information they need to sniff out any and all sneaker scams from a mile away.\nGrokking the two laws of software architecture will serve you well. Now you know that there are no “best practices” in software architecture—just trade-offs. It’s up to you (and your team) to find the most viable and best-fitting option. And don’t forget to record your decision in an ADR!\nOnward and upward.\nBullet Points\nThere is nothing “static” about architecture. It’s constantly changing and evolving.\nRequirements and circumstances change. It’s up to you to modify your architecture to meet new goals.\nFor every decision, you will be faced with multiple solutions. To find the best (or least worst), do a trade-off analysis. This collaborative exercise helps you identify the pros and cons of every possible option.\nThe First Law of Software Architecture is: Everything in software architecture is a trade-off.\nThe answer to every question in software architecture is “it depends.” To learn which solutions are best for your situation, you’ll need to identify the top priorities and goals. What are the requirements? What’s most important to your stakeholders and customers? Are you in a rush to get to market, or hoping to get things stable in growth mode?\nThe product of a trade-off analysis is an architectural decision: one of the four dimensions needed to describe any architecture.\nAn architectural decision involves looking at the pros and cons of every choice in light of other constraints—such as cultural, technical, business, and customer needs—and choosing the option that serves these constraints best.\nMaking an architectural decision isn’t just about choosing; it’s also about why you’re choosing that particular option.\nThe Second Law of Software Architecture is: Why is more important than how.\nTo formalize the process of capturing architectural decisions, use architectural decision records (ADRs). These documents have seven sections: Title, Status, Context, Decision, Consequences, Governance, and Notes.\nOver time, your ADRs will build into a log of architectural decisions that will serve as the memory store of your project.\nAn ADR’s title should consist of a three-digit numerical prefix and a noun-heavy, succinct description of the decision being made.\nAn ADR can be assigned one of many statuses, depending on the kind of ADR and its place in the decision workflow.\nOnce all parties involved in the decision sign off on the ADR, its status becomes Accepted.\nIf a future decision supplants an Accepted ADR, you should write a new ADR. The supplanted ADR’s status is marked as Superseded and the new ADR becomes Accepted.\nThe Context section of an ADR explains why the decision needed to be made to begin with.\nThe Decision section documents and justifies the actual decision being made. It always includes the “why.”\nThe Consequences section describes the decision’s expected impact, good and bad. This helps ensure that the good outweighs the bad, and aids the team(s) implementing the ADR.\nThe Governance section lists ways to ensure that the decision is implemented correctly and that future actions do not stray away from the decision.\nThe final section is Notes, which mostly records metadata about the the ADR itself—like its author and when it was created, approved, and last modified.\nADRs are important tools for abiding by the Second Law of Software Architecture, because they capture the “why” along with the “what.”\nADRs are necessary for building institutional knowledge and helping teams learn from one another.\n“Two Laws” Crossword\nThink you’ve mastered the two laws of software architecture? Why don’t you document your knowledge by completing this crossword?\nAcross\n2. Two Many _____\n4. Topics use a fire-and-_____ system\n5. A new ADR can _____ an old one\n7. You can list pros and cons on a _____board\n8. You should record every architectural _____ you make\n10. Documents made up of seven sections (abbr.)\n11. Heterogeneous\n13. Important architectural characteristic for a fast-growing business\n15. “Everything in software architecture is a trade-off” is the  _____ _____ of software architecture (two words)\n18. Examples of messaging mechanisms include queues and  _____\n19. Best tone to use when writing an ADR\n20. If you’re too excited about a new tool, you might have _____ Object Syndrome\nDown\n1. Topics can be independently _____\n3. An architectural characteristic that’s especially important for financial transactions\n5. Architects are responsible for making architecturally _____ decisions\n6. ADR section that tells you why a decision needed to be made\n9. High or low interdependence\n12. Short way to say “not at the same time”\n14. Two Many Sneakers’ mobile app communicates with the trading _____\n16. More important than how, according to the Second Law\n17. The _____ of an ADR might be Accepted\nSolution in ““Two Laws” Crossword Solution”\nFrom “Exercise”\nExercise Solution\nWhich of the following architectural characteristics stand out as important for this particular problem? Hint: There are no right answers here, because there is a lot we don’t know or aren’t sure of yet. Take your best guess—here are our thoughts:\nFrom “Sharpen your pencil”\nSharpen your pencil\nSpend a few minutes comparing the results of our trade-off analysis. Notice how both options support some characteristics but trade off on others? Now we’re going to present you with some requirements—see if you can decide if you’d pick queues or topics to support each one. Here are our answers:\nFrom “Sharpen your pencil”\nSharpen your pencil Solution","metadata":{"id":5282843338185206,"pageNumber":10,"bookId":1}},{"text":"This time, we’d like you to do some trade-off analysis on your own. We chose messaging as the communication protocol between our trading service and its consumers. Messaging is asynchronous. Choosing between asynchronous and synchronous forms of communication comes with its own set of trade-offs! We’ve given you two whiteboards, one for each form of communication, and we’ve listed a bunch of “-ilities.” We’d like you to consider how each architectural characteristic would work in both contexts. Is this characteristic a pro or a con (or neither) in synchronous communications? What about in asynchronous communications? Place each “-ility” in the appropriate column. Hint: Not all of them apply to this decision. You’ll find our answers below:\nFrom “there are no Dumb Questions”\nExercise Solution\nIn the following exercises, you’re going to help the team at Two Many Sneakers write an ADR. They’ve decided to use asynchronous messaging, with queues between the trading service and downstream services. Assume this is the 12th ADR the team is writing. What title would you give this ADR? Don’t forget to number it! Here’s what we came up with:\n012: Use of queues for asynchronous messaging between order and downstream services\nFrom “there are no Dumb Questions”\nExercise Solution\nIn the previous exercise, you hashed out the title of Two Many Sneakers’ ADR about using queues for messaging. Let’s say you get the green light. Write down the title you chose in the space below and give it a status. Here’s ours:\nThree months later:\nWhoops! The requirements have changed. Your latest trade-off analysis reveals that topics would be a better fit. Everyone has signed off on this, so you need to supersede your ADR with a new ADR. This is the 21st ADR your team has worked on. Write down the title and the new status of the old ADR:\nNow write down the title and status of the newly introduced ADR. Here’s ours:\nFrom “Sharpen your pencil”\nSharpen your pencil Solution\nContinue building out the ADR for Two Many Sneakers. Use the space below to write a Context section for the team’s decision to use queues for communication between the trading service and other services. Here’s our take:\nThe trading service must inform downstream services (namely the notification and analytics services, for now) about new items available for sale and about all transactions. This can be done through synchronous messaging (using REST) or asynchronous messaging (using queues or topics).\nFrom “Exercise”\nExercise Solution\nIt’s time for you to write the Decision section of the ADR for Two Many Sneakers. Here are the main factors the team considered when making their decision:\nQueues allow for heterogeneous messages.\nSecurity is an important architectural characteristic for the stakeholders.\nWe’ve given you some space to write out a Decision section, including the corresponding justification. This section should answer the question, “Why queues?” Hint: Be sure to focus on the decision and the “why.” There are no right answers, but here’s what we came up with:\nWe will use queues for asynchronous messaging between the trading and downstream services.\nUsing queues makes the system more extensible, since each queue can deliver a different kind of message. Furthermore, since the trading service is acutely aware of any and all subscribers, adding a new consumer involves modifying it—which improves the security of the system.\nFrom “Sharpen your pencil”\nSharpen your pencil Solution\nHelp the Two Many Sneakers team iron out the Consequences section of their ADR. Here are a few things to think about:\nA queue introduces a new piece of infrastructure.\nThe queues themselves will probably need to be highly available.\nHow do queues affect coupling between components?\nQueues mean a higher degree of coupling between services.\nWe will need to provision queuing infrastructure. It will require clustering to provide for high availability.\nIf additional downstream services (in addition to the ones we know about) need to be notified, we will have to make modifications to the trading service.\nNote\nHere’s our take.\nFrom “Exercise”\nExercise Solution\nLet’s bring it all together! You’ve been working piecemeal on the ADR for the Two Many Sneakers team. We’d like you to flip back over the past few exercises and copy your ADR sections onto this page to create a full ADR. We’ve given you the section titles—all you have to do is fill ’em out. (Assume the status to be “Accepted.”) Here’s our version:\n“Two Laws” Crossword Solution\nFrom ““Two Laws” Crossword”","metadata":{"id":5825656003584025,"pageNumber":10,"bookId":1}},{"text":"Chapter 4. Logical Components: The Building Blocks\nReady to start creating an architecture? It’s not as easy as it sounds—and if you don’t do it correctly, your software system could come crumbling to the ground, just like a poorly designed skyscraper or bridge.\nIn this chapter we’ll show you several approaches for identifying and creating logical components, the functional building blocks of a system that describe how its pieces all fit together. Using the techniques described in this chapter will help you to create a solid architecture—a foundation upon which you can build a successful software system.\nPut on your hard hat and gloves, get your tools ready, and let’s get started.\nLogical components revisited\nLogical components are one of the dimensions of software architecture. They are the functional building blocks of a system that make up what is known as the problem domain. In Chapter 1 you learned a bit about them, and in this chapter we’ll dive deep into what logical components are and how to create them.\nRemember that, in most programming languages, logical components are represented through the directory structure of your source code repository. For example, source code located in the app/order/tracking directory would be contained within a logical component named Order Tracking.\nExercise\nName that component\nIt’s your first week on the job as the new architect, and you’ve been assigned to an existing project to build a trouble ticket system. You want to understand the logical components of the architecture, but your team doesn’t know anything about logical components—they just started coding. To determine the logical architecture, you have to look at the existing directory structure. How many individual logical components can you identify from the codebase below?\nSolution in “Exercise Solution”\nAdventurous Auctions goes online\nWant to go on a safari in Tanzania? Observe wildlife in the Galapagos Islands? Hike to the base camp of Mount Everest? Adventurous Auctions is here to help!\nYou’ve probably seen our ads or attended some of our live auctions around the country. These kinds of adventures are hard to come by and can take years to reserve; our company auctions them off at a significant cost savings.\nWe want more people around the world to be able to access these great trips, so we’re taking our adventurous auctions online (in addition to our in-person auctions).\nThat’s where you come in: we need a new system to support the online auctions of our adventurous trips.\nHere’s what the new system needs to do:\nInclude both in-person and online bids in every auction.\nScale up to meet demand, so hundreds or even thousands of people can participate in each auction.\nAllow online users to register with Adventurous Auctions and provide us with their credit card details so they can pay if they win a trip.\nAllow online users to view live video streams of in-person auctions, as well as all bids placed so far, both in person and online.\nAllow online users to bid on trips, just like the people in the room.\nDetermine which online bidder bids the asking price first (this is called “winning the bid”). If an online bidder bids at the same time as an in-person bidder, the auctioneer then determines who bid first.\nWhen the auctioneer announces an online user as the winner, the system charges the winner’s credit card, notifies the winner, then moves on to the next trip in the auction.\nNote\nPay attention, because we’re going to show you how to create a logical architecture for this system.\nLogical versus physical architecture\nA logical architecture shows all of the logical building blocks of a system and how they interact with each other (known as coupling). A physical architecture, on the other hand, shows things like the architectural style, services, protocols, databases, user interfaces, API gateways, and so on.\nNote\nWe’re going to be talking a lot about component coupling later in this chapter.\nThe logical architecture of a system is independent of the physical architecture—meaning the logical architecture doesn’t care about databases, services, protocols, and so on. Let’s look at an example of what we mean by a logical architecture.\nAs you remember, Adventurous Auctions needs to create and schedule online auctions and allow bidders to register, search for auctions, and view the trips that are up for bid. Here are some of the components—the functional building blocks—that will help make that happen.\nSee how the logical architecture doesn’t include the various components of physical architecture mentioned above? It’s a different view of the system. To see what we mean, compare the diagram above with the following physical architecture diagram. Notice how the physical architecture associates services with components from the logical architecture, and also shows the services and databases for the system.\nWho Does What?\nWe had our logical and physical architecture responsibilities all figured out, but somehow they got all mixed up. Can you help us figure out who does what? Be careful—some responsibilities may not have a match (they aren’t part of a logical or physical architecture).\nBe sure to check the answers (located at the end of this chapter) before moving on.\nSolution in “Who Does What? Solution”\nCreating a logical architecture\nIdentifying logical components isn’t as easy as it sounds. To help, we’ve created this flowchart. Don’t worry—we’ll be covering all of these steps in detail in the following pages.\nThis flow continues as long as the system is alive.\nThis flowchart shows a series of steps to begin greenfield applications (new systems created from scratch) and perform ongoing maintenance on existing ones.\nEver wonder why it’s so common for a well-designed system to end up as an unmaintainable mess in no time? It’s because teams don’t pay enough attention to the logical architecture of their systems.\nAnytime you make a change or add a new feature to the system, you should always go through each of these steps to ensure that the logical components are the right size and are doing what they are meant to do.\nStep 1: Identifying initial core components\nThe first step in creating a logical architecture is identifying the initialcore components. Many times this is purely a guessing game, and you’ll likely refactor the components you initially identify into others. So don’t spend a lot of time worrying about how big or small your components are—we’ll get to that. First, let’s show you what we mean by a “guessing game.”\nGiven this simple description, you can start out by creating three logical components, one for each of the three major things the system does.\nThese components aren’t really doing anything yet. You see, we’ve identified the initial components, but we haven’t assigned them any responsibility yet. You could think of them as empty jars. They represent our initial best guess, based on a major action that takes place in the system. That’s why we call them initial core components.\nYes, there is! In fact, you can use several approaches to remove some of the guesswork.\nYou don’t know a lot of details about the system or its requirements yet, and the components you initially identify are likely to change as you learn more. That’s why we say it’s a guessing game at this stage—and that’s perfectly okay!\nWe’ll show you two common approaches for identifying initial core components: the workflow approach and the actor/action approach.\nThere are other approaches that may seem like good ideas initially but that can lead you down a very bad path. We’ll discuss those after we show you the good stuff.\nWorkflow approach\nThe workflow approach is an effective way to identify an initial set of core components by thinking about the major workflows of the system—in other words, the journey a user might take through the system. Don’t worry about capturing every step; start out with the major processing steps, and then work your way down to more details.\nNote\nYou can model different workflows to create even more initial components.\nLet’s use the workflow approach to identify some initial core components for the Adventurous Auctions architecture.\nthere are no Dumb Questions\nQ:You identified “Video Streamer” as a logical component, but what if our team decides to use a third-party library or service to stream the auction?\nA: Great question! Even though you might not develop the functionality yourself, it’s still part of the logical architecture.\nQ:Is each step in a workflow always mapped to a single logical component?\nA: Not always. You might have several steps in a workflow that point to the same logical component, particularly if their functionalities are closely related.\nNames matter.\nPay close attention to how you name your initial core components. A good name should succinctly describe what that component does.\nSharpen your pencil\nYour company wants a new system to assign workers to construction sites, and it’s your job as the software architect to identify its initial core components. Using the workflow approach, identify as many core components as you can, matching each to its associated workflow step. Remember, a workflow step can have multiple components, and not every workflow step has to have a unique component.\nStep 1: Maintain a list of all construction workers, their skills, and their locations\nStep 2: Create a new construction project and specify the work site\nStep 3: Create a schedule for when various construction projects start and end\nStep 4: When a new project starts, assign workers based on their skills and locations\nStep 5: When the project completes, free up workers so they can be reassigned\nNote\nDraw your logical components in this space. Remember to give them good descriptive names.\nSolution in “Sharpen your pencil Solution”\nActor/action approach\nThe actor/action approach is particularly helpful if you have multiple actors (users) in the system. You start by identifying the various actors. Then, you identify some of the primary actions they might take and assign each action to a new or existing component.\nReturning to our Adventurous Auctions example, let’s use the actor/action approach to identify some initial core components.\nExercise\nYou have a bakery that is ready to expand operations, and you would like a new system that lets customers view, order, and pay for bakery items online for pickup. Orders are sent to the bakery coordinator, who purchases ingredients and schedules orders. The baker receives the schedule of items to bake each morning and tells the system when the items are baked. The system then emails the customers to let them know their items are ready for pickup.\nUsing the actor/action approach, identify what actions each actor might take. Then draw as many logical components as you can for the new bakery system, matching the actions you identified to the components.\nSolution in “Exercise Solution”\nThe entity trap\nWelcome to the entity trap.\nWe call this approach the entitytrap because it’s very easy to fall into it when identifying the initial core logical components, and you’ll run into lots of issues if you do this.\nFirst of all, the name “Bid Manager” is too vague. Can you tell what the component does just by looking at the name? Neither can we. A name like this doesn’t tell us enough about the component’s role and responsibilities.\nSecond, the component has too many responsibilities. All too often, components in the entity trap become convenient dumping grounds for all functionality related to those entities. As a result, they take on too much responsibility and become too big and difficult to maintain, scale, and make fault tolerant.\nNote\nPro Tip\nWatch out for words like manager or supervisor when naming your logical components—those are good indicators that you might be in the entity trap.\nSharpen your pencil\nWhat other words besides manager can you list that, if they appeared in a component name, might indicate that you’ve fallen into the entity trap?\nsupervisor\nNote\nWe did this one for you.\nSolution in “Sharpen your pencil Solution”\nExercise\nCan you select the most appropriate approach to identifying initial core components in the following scenarios? In some cases, more than one approach may be appropriate.\nThe system has only one type of userWorkflowActor/ActionThe system has well-defined entitiesWorkflowActor/ActionYou have minimal functional requirementsWorkflowActor/ActionThe system has many complex user journeysWorkflowActor/ActionThe system has many types of usersWorkflowActor/Action\nSolution in “Sharpen your pencil Solution”\nthere are no Dumb Questions\nQ:The actor/action approach reminds me a lot of event storming. Are they the same thing?","metadata":{"id":7271375624100750,"pageNumber":11,"bookId":1}},{"text":"A: Great observation, and we’re glad you saw the similarities. Event storming is a workshop-based approach that is part of domain-driven design (DDD). With this approach, you analyze the business domain to identify domain events. While both approaches have the final goal of identifying actions performed within the system, event storming takes identifying components much further than the actor/action approach does. You could say that the actor/action approach identifies the domain event and actor elements of event storming, but doesn’t continue with other elements such as command, aggregate, and view. You can learn more about event storming at https://en.wikipedia.org/wiki/Event_storming.\nQ:Can you combine the workflow approach and actor/action approach, or do you have to choose between them?\nA: You can combine them, and in most cases this is a good idea. If you start with the actor/action approach to identify actions, you can then use the workflow approach to arrange them in the order in which they are likely to occur.\nQ:Are you telling me I should never use the words manager, supervisor, and so on as part of my component names?","metadata":{"id":2350674253104782,"pageNumber":11,"bookId":1}},{"text":"A: Not necessarily—there is no hard and fast rule to the entity trap. Sometimes it’s hard to come up with a name for something that does a general task. Take, for example, a component that manages all of the reference data in your application—name/value pairs like country codes, store codes, color codes, and so on. A good name for such a component would be “Reference Data Manager.” However, names like “Order Manager” or “Response Handler” are too broad and don’t describe what those components actually do.\nQ:When using the actor/action approach, how many actions should you identify for each actor?\nA: That’s a tough question. The purpose of identifying actions is to tease out likely logical components and what they might be responsible for. We usually look at the primary actions an actor might take, rather than diving into too many details.\nStep 2: Assign requirements\nOnce you’ve identified some initial core components, it’s time to move on to the next step: assigning requirements to those logical components.\nIn this step, you’ll take functional user stories or requirements and figure out which component should be responsible for each one. Remember, each component is represented by a directory structure. Your source code resides in that directory, so it contains that requirement.\nLet’s go back to the initial set of components we defined based on what Frank (the CIO) said about the basic workflow of Adventurous Auctions. Now it’s time to assign some responsibilities to these components.\nSharpen your pencil\nYour company, Going Green Corporation, wants a system to support its new electronics recycling program, where customers can send in their old electronic devices (like cell phones) and get money. We’ve already identified some of the initial core components. Your job is to figure out which component should be responsible for each of the functionalities listed below, or if a new component is needed. You’ll also need to come up with names for any new components.\nSolution in “Sharpen your pencil Solution”\nStep 3: Analyze roles and responsibilities\nAs you start assigning functionality (in other words, user stories or requirements) to logical components, the roles and responsibilities of each component will start to naturally grow. The purpose of this step is to make sure that the component to which you are assigning functionality should actually be responsible for that functionality and that it doesn’t end up doing too much.\nLet’s say we create a component called Live Auction Session that has the following responsibilities during a live auction:\nWith this added functionality, this component is now taking on too much responsibility. This is a common situation, so don’t be surprised if it happens to you. When it does, don’t panic—that’s what this step is here for. Let’s see if we can fix this situation by moving some of the responsibility of the Live Auction Session component to other components.\nNote\nIf you’ve ever had too much on your plate at work, you likely gave some of that work to others. Do the same with components—offload some of the responsibility to someone else.\nGeek Note\nHave you ever created a class file called Utility? What did it do? Chances are it contained a bunch of unrelated functions that you’d had a hard time placing. The same thing can happen with logical components within software architecture. Try to avoid components that contain lots of unrelated functions.\nSticking to cohesion\nWhen you analyze a component’s role and responsibility statement or set of operations, check to see if the functionality is closely related. This is known as cohesion: the degree and manner to which the operations of a component are interrelated. Cohesion is a useful tool for making sure a component has the right responsibilities.\nWhen analyzing the role and responsibilities of a component, it’s common to find an outlier (an odd piece of functionality) or a component that is doing too much. In these cases, it’s usually a good idea to shift some of the responsibility to other components.\nNow it’s your turn to fix the Live Auction Session component.\nMake it Stick\nComponent functions should all be related— but if they’re not, don’t get frustrated. Just start to break the component apart, and you’ll be considered very smart.\nExercise\nSee if you can offload some of the responsibility of the Live Auction Session component to others by creating new components to handle the additional functionality. Keep the first three original requirements associated with the Live Auction Session.\nSolution in “Exercise Solution”\nStep 4: Analyze characteristics\nThe final step in identifying initial core components is to verify that each component aligns with the driving architectural characteristics that are critical for success. In most cases this involves breaking apart a component for better scalability, elasticity, or availability, but it could also involve putting components together if their functionalities are tightly coupled.\nLet’s look once again at our Adventurous Auctions example. We previously identified a Bid Capture component that is responsible for accepting bids, storing all bids in a Bid Tracker database, and forwarding the highest bid to the auctioneer. Here is the overall flow for the Bid Capture component:\nThis architecture looks good, but just to be sure, we should make sure the Bid Capture component supports the system’s critical architectural characteristics (those that are important for success).\nWe know the system has to support thousands of bidders per second—that’s scalability. We also know the system must be up and running while auctions are taking place—that’s availability. Finally, the system must accept a bid and get it to the auctioneer as fast as possible—that’s performance.\nNote\nThese are all important to the success of Adventurous Auctions.\nNow it’s your turn to analyze the Bid Capture component against these critical architectural characteristics.\nBE the architect\nYour job is to play architect and analyze the Bid Capture component on the previous page to see if it should be modified based on the critical architectural characteristics we identified. Our solution is on the next page.\nThese are the critical architectural characteristics for Adventurous Auctions:\nScalability: The system has to support thousands of bidders per second\nAvailability: The system must be up and running while the auctions are taking place\nPerformance: The system must accept a bid and get it to the auctioneer as fast as possible.\nHints (things to consider):\nWhat if the database goes down?\nCan the database keep up with the volume of inserts based on the bids coming in?\nWill inserts into the database be fast enough to get the bids to the auctioneer?\nConsider the actions the Bid Capture component has to take upon receiving a bid.\nNote\nUse this area to draw how you might change the Bid Capture component based on the critical architectural characteristics and considerations above.\nThe Bid Capture component\nLet’s work through this exercise by reviewing the current responsibilities of the Bid Capture component:\nAccept bids from online bidders and from the auctioneer for live bidders.\nDetermine which online bid is the highest.\nWrite all bids to a Bid Tracker database for tracking purposes.\nNotify the auctioneer of the highest bid.\nIt makes sense for the Bid Capture component to write the bids to the database, since it has them. But database connections and throughput are limited, so having Bid Capture do this significantly impacts scalability. It also impacts performance by adding wait time for writing the data to the database, as well as availability if the database were ever to go down.\nNote\nThis is what we mean by analyzing characteristics.\nIf we assign the last requirement to a new component called Bid Tracker, we can significantly increase the scalability, performance, and availability of the Bid Capture component. That lets the system process more bids faster and get the highest bid to the auctioneer as quickly as possible. The Bid Capture component can send the bids to the Bid Tracker and won’t have to wait for the bid to be written to the database.\nNote\nYou might break apart or combine components in this step, based on the architectural characteristics needed.\nComponent coupling\nYes, and this is the right time to do it.\nAs you identify the initial core components, it’s important to determine how they interact. This is known as component coupling: the degree to which components know about and rely on each other. The more the components interact, the more tightly coupled the system is and the harder it will be to maintain.\nRemember this diagram from several pages ago? It’s called a “big ball of mud” because there are so many component interactions and dependencies that the diagram starts to look like a ball of mud (or maybe like a bowl of spaghetti).\nThat’s why it’s so important to pay attention to how components interact and what dependencies exist between them.\nYou need to be concerned about two types of coupling when creating logical components: afferent coupling and efferent coupling. Don’t be concerned if you’ve never heard these formal terms before—we’re going to explain them in the following pages.\nAfferent coupling\nChildren depend on their parents for a lot of things, like making sure they have plenty of food to eat and a safe place to live, driving them to soccer practice, or even giving them an allowance so they can buy candy or a really cool comic book. As it turns out, parents are afferently coupled to their children, and even to the family dog, because all of them depend on the parents for something.\nAfferent coupling is the degree and manner to which other components are dependent on some target component (in this case, Mom). It’s sometimes referred to as fan-in, or incoming, coupling. In most code analysis tools, it’s simply denoted as CA.\nTo see how afferent coupling works, look at the interaction between three of the logical components within the Adventurous Auctions logical architecture on the left.\nBoth the Auction Registration component and the Automatic Payment component depend on the Bidder Profile component to return bidder profile information. In this scenario, the Bidder Profile component has an afferent coupling level of 2, because two components depend on it to complete their work.\nGeek Note\nDid you know that the odd-sounding word afferent means “carrying toward”? It gets its roots from the Latin words ad (meaning “to” or “toward”) and ferre (“to carry”). In the medical field, the word afferent refers to nerves that carry impulses to the brain (your afferent nerves).\nEfferent coupling\nNow let’s look at things from a young child’s point of view. As a child, you might have been dependent not only on your parents, but also your teachers, friends, classmates, and so on. Being dependent on others is known as efferent coupling.\nEfferent coupling is exactly the opposite of afferent coupling, and it’s measured by the number of components on which a target component depends. It’s also known as fan-out coupling or outgoing coupling. In static source code analysis tools, it’s usually denoted as CE.\nSo, what does efferent coupling look like with logical components? Let’s take a look at Adventurous Auctions again, this time considering the process of accepting a bid from Kate for a trip.\nBecause the Bid Capture component depends on the Bid Streamer and Bid Tracker components to process a bid, it is efferently coupled to these components. It has an efferent coupling level of 2 (in other words, it’s dependent on two other components).\nMeasuring coupling\nYou can measure a particular component’s amount of coupling in three ways: by considering its total afferent coupling (CA), its total efferent coupling (CE), and its total coupling (CT), or the sum of the total afferent and efferent coupling. These measurements tell you which components have the highest and lowest coupling, as well as the entire system’s overall coupling level.\nSharpen your pencil\nGiven the components below, can you identify the total afferent coupling (CA), total efferent coupling (CE), and total coupling (CT) for each component? Also, what is the total coupling level for this logical architecture? Does the CT for this architecture seem high or low to you?\nSolution in “Sharpen your pencil Solution”\nGreat question. Developers are taught to strive for loosely coupled systems, but not how to do it. We’ll show you how by introducing a technique called the Law of Demeter.\nThe Law of Demeter, also known as the Principle of Least Knowledge, is named after Demeter, the Greek goddess of agriculture. She produced all grain for mortals to use, but she had no knowledge of what they did with the grain. Because of this, Demeter was loosely coupled to the mortal world.\nLogical components work in the same way. The more knowledge a component has about other components and what needs to happen in the system, the more coupled it is to those components. By reducing its knowledge of other components, we reduce that component’s level of coupling.\nOn the next few pages, we’ll show you more about the Law of Demeter and how it can be used to decouple systems.\nA tightly coupled system\nLet’s see how the Law of Demeter can be used to decouple systems by taking a look at the logical architecture of a typical order entry system.\nBrain Power\nWhat possible issues do you see with the logical architecture above? We’ve provided some (but not all) potential problems. Check off the ones you think might be an issue, and write down any other possible issues you see with this logical architecture.\nThe customer might not be available to get their email when it’s sent.\nThe supplier might not have stock on hand.\nThe Order Placement component knows too much about the steps involved in placing an order.\n_______________________________________________________________________________\n_______________________________________________________________________________\n_______________________________________________________________________________\nApplying the Law of Demeter\nThe total system coupling level didn’t bother us that much. What does bother us is how tightly coupled the Order Placement component is (CT=5), how unbalanced the component coupling is, and how much knowledge the Order Placement component has about the order placement process.\nNote\nThe Order Placement component is taking charge.\nLet’s apply the Law of Demeter to fix these problems by moving the “low stock” knowledge to the Inventory Management component.\nBy moving the knowledge of actions to take for a “low stock” condition to Inventory Management, we reduced the amount of knowledge about the system, and hence the coupling, of the Order Placement component However, we increased the knowledge of the Inventory Management component, and thus increased its coupling. This is what the Law of Demeter is all about—less knowledge, less coupling; more knowledge, more coupling.\nNote\nCoupling is all about how much knowledge components have about the rest of the system.\nGeek Note\nDid you notice that while we reduced the coupling of the Order Placement component, the total system coupling level remained the same? That’s because we didn’t remove the knowledge from the system, we just moved it to another component—Inventory Management.\nTest Drive\nNow it’s time to take the Law of Demeter for a test drive to see if you can decouple a logical architecture. Below is a logical architecture for a system where customers who have purchased a support plan with an electronic item can submit a trouble ticket and have an expert come out to fix the item. Here’s how it currently works:\nA customer creates a ticket.\nThe ticket gets assigned to an available expert in the field.\nThe ticket is uploaded to an app on the expert’s mobile device (that’s Ticket Routing).\nThe customer is notified that the expert is on their way to fix the problem.\nOnce the expert fixes the problem, they mark the ticket as completed.\nKeeping the components the same, how can you make this architecture more loosely coupled?\nSolution in “Test Drive Solution”\nA balancing act\nDo you remember the First Law of Software Architecture? Here it is again (because it’s so important):\nEverything in software architecture is a trade-off.\nLoose coupling is no exception. Let’s compare the two architectures we’ve just seen and analyze their trade-offs.\nWith the tightly coupled architecture, if you want to know what happens when a customer places an order, you only have to look at the Order Placement component to understand the workflow.\nHowever, changing the Item Pricing and Supplier Ordering components will no longer affect the Order Placement component.\nWith loose coupling, you distribute the knowledge about what needs to happen, so that no one component knows all the steps. If you want to understand the workflow of placing an order, you have to go to multiple components to get the full picture.\nHowever, in this case, the Order Placement component is dependent on four other components. If any one of those components changes, it could break the Order Placement component.\nTwo components are coupled if a change in one component might cause a change in the other component.\nNote\nThis is a good rule to remember.\nSome final words about components\nCongratulations! Now that you can identify logical components and the dependencies between them, you’re on your way to creating a software architecture. We know this was a long chapter, but it’s also an important one. Thinking about a system as a collection of logical components helps you, as an architect, better understand its overall structure and how it works.\nIn the next part of your software architectural journey, you’ll be focusing on the technical details of the system—things like architecture styles, services, databases, and communication protocols. But before you go, review the following bullet points to make sure you fully understand everything about logical components.\nBullet Points\nLogical components are the functional building blocks of a system.\nA logical component is represented by a directory structure—the folder where you put your source code.\nWhen naming a component, be sure to provide a descriptive name to clearly identify what the component does.\nCreating a logical architecture involves four continuous steps: identify components, assign requirements, analyze component responsibilities, and analyze architectural characteristics.\nYou can use the workflow approach to identify initial core logical components by assigning the steps in a primary customer journey to components.\nYou can use the actor/action approach to identify initial core logical components by identifying the actors in the system and assigning their actions to components.\nThe entity trap is an approach that models components after major entities in the system. Avoid using this approach, because it creates ambiguous components that are too large and have too much responsibility.\nWhen assigning requirements to components, review each component’s role and responsibilities to make sure it should be performing that function.\nCoupling happens when components depend on one other to perform a business function.\nAfferent coupling, also known as incoming coupling, occurs when other components are dependent on a target component.\nEfferent coupling, also known as outgoing coupling, occurs when a target component is dependent on other components.\nComponents having too much knowledge about what needs to happen in the system increases component coupling.\nThe Law of Demeter states that services or components should have limited knowledge of other services or components. This law is useful for creating loosely coupled systems.\nWhile loose coupling reduces dependencies between components, it also distributes workflow knowledge, making it harder to manage and control that knowledge.\nDetermining the total coupling (CT) of a logical architecture involves adding the afferent and efferent coupling levels for each component (CA + CE).\nLogical Components Crossword\nNow’s your chance to have a little fun and see how much knowledge you’ve gained. See if you can fill in this crossword puzzle with clues about logical components.\nAcross\n3. Each component performs a _____\n4. _____ gateways appear in a physical architecture but not a logical one\n6. A physical architecture associates _____ with components\n7. One system component might be a live video _____\n9. Avoid building a big ball of _____\n11. Be sure to avoid the _____ trap\n12. Coupling might be _____ or efferent\n13. Logical _____ are the functional building blocks of a system\n16. Early on, you’ll identify _____ core components\n19. A user’s journey through the system is called their _____\n20. Each logical component has a _____ and a responsibility\nDown\n1. A component’s _____ is about how interrelated its operations are\n2. Give each component a descriptive _____\n5. Afferent and efferent coupling are both forms of _____ coupling\n8. The Principle of Least Knowledge is also called the Law of _____\n10. A good place to look for components is the codebase’s _____ structure\n12. Step 2 is to _____ requirements to logical components\n14. An architecture diagram can show the logical or _____ architecture\n15. Adventurous Auctions lets users _____ on trips\n17. You can identify components with an _____/action approach\n18. Identifying logical components may involve taking your best  _____\nSolution in “Logical Components Crossword Solution”\nFrom “Exercise”\nExercise Solution\nName that component\nIt’s your first week on the job as the new architect, and you’ve been assigned to an existing project to build a trouble ticket system. You want to understand the logical components of the architecture, but your team doesn’t know anything about logical components—they just started coding. To determine the logical architecture, you have to look at the existing directory structure. How many individual logical components can you identify from the codebase below? Here are our answers.\nFrom “Who Does What?”\nWho Does What? Solution\nWe had our logical and physical architecture responsibilities all figured out, but somehow they got all mixed up. Can you help us figure out who does what? Be careful—some responsibilities may not have a match (they aren’t part of a logical or physical architecture).\nFrom “Sharpen your pencil”\nSharpen your pencil Solution\nYour company wants a new system to assign workers to construction sites, and it’s your job as the software architect to identify its initial core components. Using the workflow approach, identify as many core components as you can, matching each to its associated workflow step. Remember, a workflow step can have multiple components, and not every workflow step has to have a unique component.\nStep 1: Maintain a list of all construction workers, their skills, and their locations\nStep 2: Create a new construction project and specify the work site\nStep 3: Create a schedule for when various construction projects start and end\nStep 4: When a new project starts, assign workers based on their skills and locations\nStep 5: When the project completes, free up workers so they can be reassigned\nFrom “Exercise”\nExercise Solution\nYou have a bakery that is ready to expand operations, and you would like a new system that lets customers view, order, and pay for bakery items online for pickup. Orders are sent to the bakery coordinator, who purchases ingredients and schedules orders. The baker receives the schedule of items to bake each morning, and tells the system when the items are baked. The system then emails the customers to let them know their items are ready for pickup.\nUsing the actor/action approach, identify what actions each actor might take, then draw as many logical components as you can for the new bakery system, matching the actions you identified to the components.\nFrom “Sharpen your pencil”\nSharpen your pencil Solution\nWhat other words besides manager can you list that, if they appeared in a component name, might indicate that you’ve fallen into the entity trap?\nFrom “Exercise”\nExercise Solution\nCan you select the most appropriate approach to identifying initial core components in the following scenarios? In some cases, more than one approach may be appropriate.\nFrom “Sharpen your pencil”\nSharpen your pencil Solution\nYour company, Going Green Corporation, wants a system to support its new electronics recycling program, where customers can send in their old electronic devices (like cell phones) and get money. We’ve already identified some of the initial core components. Your job is to figure out which component should be responsible for each of the functionalities listed below, or if a new component is needed. You’ll also need to come up with names for any new components.\nFrom “Make it Stick”\nExercise Solution\nSee if you can offload some of the responsibility of the Live Auction Session component to others by creating new components to handle the additional functionality. Keep the first three original requirements associated with the Live Auction Session.\nFrom “Sharpen your pencil”\nSharpen your pencil Solution\nGiven the components below, can you identify the total afferent coupling (CA), total efferent coupling (CE), and total coupling (CT) for each component? Also, what is the total coupling level for this logical architecture? Does the CT for this architecture seem high or low to you?\nFrom “Test Drive”\nTest Drive Solution\nIt’s time to take the Law of Demeter for a test drive to see if you can decouple a logical architecture. Below is a logical architecture for a system where customers who have purchased a support plan with an electronic item can submit a trouble ticket and have an expert come out to fix the item. Here’s how it currently works:\nA customer creates a ticket.\nThe ticket gets assigned to an available expert in the field.\nThe ticket is uploaded to an app on the expert’s mobile device (that’s Ticket Routing).\nThe customer is notified that the expert is on their way to fix the problem.\nOnce the expert fixes the problem, they mark the ticket as completed.\nKeeping the components the same, how can you make this architecture more loosely coupled?\nLogical Components Crossword Solution\nFrom “Logical Components Crossword”","metadata":{"id":400919305546026,"pageNumber":11,"bookId":1}},{"text":"Chapter 5. Architectural Styles: Categorization and Philosophies\nThere are lots of different architectural styles out there. Each one exists for a reason and has its own philosophy about how and when it should be used. Understanding a style’s philosophy will help you judge whether it’s the right one for your domain. This chapter gives you a framework for the different kinds of architectural styles (which we’ll be diving into for the remainder of this book), to help you make sense of these and all the other architectural styles you’ll encounter as a software architect.\nLet’s fill in that final piece of the puzzle, shall we?\nThere are lots of architectural styles\nYou’ve learned a lot about software architecture so far, but there’s one thing we still haven’t talked about: architectural styles. That’s what we’ll do in this chapter—in fact, the rest of this book is dedicated to architectural styles!\nBefore we get started: look around your neighborhood, then watch a show or movie set in a different part of the world. How many styles of homes do you see? There are literally hundreds—all influenced by the locale, weather, and the owners’ personal preferences. New styles are created every day.\nThat’s true for architectural styles in software, too. There are so many out there that even in a book this big, try as we might, we’ll barely scratch the surface of all the available styles.\nThis chapter will give you a framework for thinking about architecture and architectural styles in general. Then, in the chapters that follow, we’ll dive deep into a handful of specific architectural styles and examine their philosophies, using what you learn in this chapter. Understanding a few crucial styles will leave you with a good foundation to understand others as you encounter them.\nLet’s do this.\nThe world of architectural styles\nIf you’ve done software development for any length of time, you may have heard about different architectural styles, like monoliths and microservices. To help us think systematically about them, we place them into two categories. The first deals with how the code is divided: either by technical concerns or by domain (business) concerns. The second category is about how the system is deployed: is all the code in the system delivered as one unit, or as multiple units?\nNote\nRecall from Chapter 2 that the domain is “the thing you’re writing software about.”\nAs you can see, there are multiple ways to slice and dice architectural styles. This doesn’t cover everything, of course—there are domain-specific architectures that are built explictly for certain problems—but a book can only be so long.\nNote\nWe won’t spend time on domain-specific architectures in this book. Let’s just say they don’t appeal to a broad audience.\nEach category reveals some of the architectural characteristics of its styles. For example, architectural styles delivered as one unit are easier to understand, but those delivered as multiple units tend to scale better.\nLet’s examine each category.\nPartitioning: Technical versus domain\nThink back to the last time you had dinner at a fancy restaurant. When you walked in, a host probably greeted you and escorted you to a table. A server offered you drinks and menus and explained the specials. The chef and other cooks prepared your food for you. When you finished your meal, a busser cleaned and reset the table.\nThese restaurant workers’ duties are separated by technicalconcern. A busser’s role isn’t to welcome you, and you probably don’t want the server cooking your food.\nNow, think back to the last application you worked on. Did it have a controller layer? Did it have services? How about a persistence tier? If so, congratulations: you’ve already worked on a technically partitioned architecture.\nIn a technically partitioned architecture, code is divvied up by technical concerns—there might be a presentation tier, a business (services) layer, and so on. The principle at play here is separation by concern—which most people think about in horizontal layers.\nNote\nAnother analogy that might help is a burger, with two halves of a bun, condiments, veggies, and a patty—each layer has a distinct and separate role.\nOn the other hand, imagine a food court. It has lots of restaurants, each specializing in a particular kind of food: pizza, salads, stir-fry, burgers. In other words, each restaurant has a specific domain.\nNote\nEach of these restaurants might have servers and bussers. But at a high level, the restaurant specializes in a particular kind of food.\nNote\nWe’ll dive into a lot of these details in future chapters.\nIn domain-partitioned architectures, the structure of the system is aligned with the domain. Rather than by roles, the code (and systems) are separated in ways that align with the problem you’re attempting to solve.\nthere are no Dumb Questions\nQ:In a domain-partitioned architecture, where do the presentation and services layers reside?\nA: In a domain-partitioned architecture, you are making the domain the “first-class citizen,” leaving the technical implementation as just that: implementation. The logical components that make up your architecture are organized around the domain, as opposed to the role they perform.\nA technically partitioned architecture’s components might be organized in namespaces like app.presentation.customer or app.services.customer. Note how the customer domain appears within the technical partition. However, in a domain-partitioned architecture, you’ll have namespaces like app.customer.presentation and app.customer.services.\nQ:Domain partitioning is pretty logical. Frankly, it sounds better. So why would anyone use technical partitioning?\nA: We prefer not to use value judgments such as “better” and “best” when discussing architectural styles. (You’re going to get tired of us saying this!) Your choice of architectural style will always be driven by a variety of factors, as you know, including the domain and the required architectural characteristics.\nTechnical partitioning is great if your teams tend to specialize—say, if you have teams of frontend experts, backend developers, and database administrators. But domain partitioning better aligns your system with the actual problem at hand.\nExercise\nA short-order cook pretty much does everything. They can cook everything on the menu, from fries to sandwiches, as well as blending smoothies and plating desserts. Often, they also serve food, take payments, and even clean tables after customers leave. Would you categorize a short-order cook’s work as partitioned technically or by domain? Why? Jot down your thoughts here.\nSolution in “Exercise Solution”\nDeployment model: Monolithic versus distributed\nLet’s play a game—we say a word, and you respond with the first thing that pops into your mind. Ready? Monolith.\nWe don’t know about you, but this word makes us think of something like a boulder or a glacier—something big. That’s exactly what monolithic architectures represent.\nIn a monolithic architecture, you deploy all the logical components that make up your application as one unit. This also means that your entire applications runs as one process.\nNote\nThis would be like packaging and deploying your entire application as a single WAR or JAR file in the Java ecosystem, or as an executable in the .NET world.\nIn a distributed architecture, by contrast, you split up the logical components that make up the application across many (usually smaller) units. These units each run in their own process and communicate with each other over the network.\nThere’s a lot to this distinction, so let’s talk about the pros and cons of both types.\nExercise","metadata":{"id":1619398011997609,"pageNumber":12,"bookId":1}},{"text":"Take a moment and consider your smartphone. It does it all—it lets you take pictures and videos, browse the web, post to your favorite social networking site, track your fitness activity, and navigate via GPS. And somewhere, embedded deep within the settings, there’s even a phone! As you can see, your phone is a monolithic system. We’d like you to jot down the pros and cons of such a system. Think in terms of architectural characteristics, like availability, upgradability, cost, and ease of use.\nJust a few years ago, people used separate devices for all those functions your phone performs today. Phones were, well, just phones, maybe with text messaging. We used laptop or desktop computers to browse the web and post to social networking sites; we could buy fitness trackers to help track workouts and GPS devices to install in cars for navigation help. Each of these “services” was deployed separately.\nJust like you did above, jot down the pros and cons of such a system. Again, think in terms of architectural characteristics.\nSolution in “Exercise Solution”\nMonolithic deployment models: The pros\nIn Chapter 2, you learned that architectural characteristics always influence some structural aspect of the design. Monoliths support some characteristics better than distributed systems, and knowing where they shine can help you decide when to use them.\nBecause monolithic systems run in one process, they make development easier—at least initially. And since they’re deployed as one unit, tracing errors is a lot easier.\nLet’s take a look at the pros and cons of both deployment models, starting with monoliths. Here are the pros:\nNow for the cons...\nMonolithic: The cons\nSome of monoliths’ strengths can become problematic as an application grows. Many of the operational characteristics we discussed in Chapter 2, like scalability and reliability, suffer as a monolithic application grows bigger and more complex.\nNext, we’ll look at the pros and cons of distributed architectures.\nBrain Power\nSpend a few minutes thinking about your industry. Does your organization have any special regulatory, security, or compliance needs? How might using a monolithic architecture help or hurt its ability to achieve the architectural characteristics that address those needs? List any ways you can think of here:\nDistributed deployment models: The pros\nWith distributed architectures, you deploy your logical components as separate units. This makes it easy to scale some parts of your application separately from others. And since logical components are physically separate, distributed architectures encourage lowcoupling.\nSo, what architectural characteristics are distributed architectures good for? Here’s a sampling:\nAs you might have noticed, distributed architectures do better on many of monolithic architectures’ weak points. But is the opposite true? Let’s find out.\nDistributed deployment models: The cons\nCan’t have pros without cons. Trade-offs, right? It’s all about trade-offs.\nDistributed architectures make some things easy, while making others very hard.\nWatch it!\nIt’s easy to underestimate how hard distributed computing is!\nFor all their benefits, distributed architectures depend on the network. Software architects often underestimate the complexities that arise from this dependency. Look up “The Fallacies of Distributed Computing,” a list compiled in the 1990s by L. Peter Deutsch and others at Sun Microsystems, to get a sense of what to watch out for.\nBrain Power\nLet’s repeat the exercise you did earlier, this time for distributed architecture. Does your organization have any special regulatory, security, or compliance needs? How might using a distributed architecture help or hurt your organization’s ability to achieve the architectural characteristics that address those needs? List any ways you can think of here:\nFireside Chats\nTonight’s talk: Monolithic and distributed architectures answer the question: “Who’s more relevant?”","metadata":{"id":837388916923554,"pageNumber":12,"bookId":1}},{"text":"Monolithic ArchitectureDistributed ArchitectureIt’s a good thing I’m still around. Boy, do you make things complicated.I don’t like that attitude. Sure, you might be “simpler” to develop, but you can’t keep up. Businesses need to move fast, and you just don’t deliver the goods.I might be simple, but I’m also faster to develop. I can’t imagine anyone building a minimum viable product with you—they’d never launch!I might give you that—but I’ll make sure they make it to the finish line. And if their product is a smash hit, will you help or just get in the way? I can ensure success even at scale.Oh! And I’m way cheaper. You realize that most businesses don’t want to waste money, right? I can’t imagine anyone using you to create a proof of concept.Riiiight. And when you fail, you just topple over. I provide a high degree of fault tolerance. Need a service to scale? Just scale that service. Scaling you is arduous.Hey, that’s the cost of doing business at scale. Teams might start with you, but if they want to keep growing, they’ll come to me—and leave you in the rearview mirror.What? Are you saying I’m old news? Well, the next time a team needs to get to market quickly, don’t call me—and then we’ll see how tough you really are.Feeling’s mutual, bud. Don’t call me when your team’s minimum viable product is a success and their architecture can’t handle all the attention.\nBusinesses also like making money. Once their applications grow, you’re just a money pit. I personify agility—I help teams and organizations scale as they grow.\nI also make testing easier, while you just rack up the technical debt.\nIt’s a good thing you can be tested easily—ever seen a useful error stack trace? Of course you haven’t. You’re all over the place. Good luck trying to trace why and where an error actually happened.\nAt least when I get an error, you get a nice, clear stack trace.\nAt least I’m just one process. No unnecessary network traffic here. You’re all talk, man—so much chatter. All your services are constantly talking to one another.\nAnd that’s only if the network is always reliable, because without it, you have nothing! Heaven help you if the network should fail.\nPlus, with me, you don’t need a whole bunch of network infrastructure. Do you know how expensive that stuff is to maintain?!\nAnd that’s a wrap!\nNow you know how to categorize the tons of architectural styles out there. Having a framework can help you make sense of them. And remember—each quadrant of the framework represents both the pros and cons of those architectural styles.\nIn the next chapter, we’ll start our deep dive into individual styles.\nBullet Points\nThere are a lot of architectural styles—in fact, too many to count.\nThere are multiple ways to categorize architectural styles. One is by their partitioning style. Architectural styles can be either technically partitioned or domain partitioned.\nIn technically partitioned architectural styles, the code is split up by technical concern. For example, there might be a presentation layer and a services layer.\nIn domain-partitioned architectural styles, the code is instead split up by problem domain.\nAnother way to categorize architectural styles is by their deployment model. Monolithic architectural styles deploy all the logical components that make up an application as a single unit. Distributed architectural styles deploy the logical components separately from one another, as multiple units.\nMonolithic architectures are easier to understand and debug and are often cheaper to build (at least initially). This makes them great candidates if there is a rush to bring a product to market.\nAs monolithic applications grow, scaling them up can become arduous. It’s an all-or-nothing scenario: you either scale up the whole application or nothing at all.\nMonolithic applications can also be unreliable—a bug can make the entire application unusable.\nDistributed architectures are highly scalable since their logical components are deployed separately, allowing different parts of the application to scale independently of one another.\nDistributed architectures encourage a high degree of modularity, which means testing them is easier.\nDistributed architectures are extremely expensive to develop, maintain, and debug.\nDistributed architectures use the network so that different services can talk to one another to complete work. This introduces even more complexity.\nStylin’ Architectures Crossword\nNow that you can make sense of architectural styles, see if you can make sense of this crossword.\nAcross\n2. You can _____ systems technically or by domain\n3. L. Peter _____ helped compile “The Fallacies of Distributed Computing”\n7. Monoliths are good for creating a _____\n10. Regardless of the physical architecture, a _____ system provides more confidence in correct outcomes\n14. Distributed and monolithic are both deployment _____\n15. Minimum viable _____\n17. Monolithic systems are easier to _____\n18. Monolithic architectures have _____ deployment units\nDown\n1. Layers are separated by _____\n2. Each architectural style has its own _____\n4. Monolithic architectures tend to have a fast _____ to market\n5. A system deployed as one big unit\n6. If you change anything in a monolith, you’ll need to _____\n8. An architecture’s organization is reflected in its _____ spaces\n9. Services in a distributed architecture use this to communicate\n11. Distributed systems consist of many _____ deployment units\n12. Nothing about distributed deployment models is _____\n13. Architectures often have more than one _____\n16. Distributed systems usually _____ more than monolithic ones do\nSolution in “Stylin’ Architectures Crossword Solution”\nFrom “Exercise”\nExercise Solution\nA short-order cook pretty much does everything. They can cook everything on the menu, from fries to sandwiches, as well as blending smoothies and plating desserts. Often, they also serve food, take payments, and even clean tables after customers leave. Would you categorize a short-order cook’s work as partitioned technically or by domain? Why? Jot down your thoughts here.\nNote\nBecause a short-order cook does everything needed to get customers their meals, from setting the tables to prepping and cooking to cleaning up, they own the whole “domain” of food preparation. This makes their job domain-partitioned.\nFrom “Exercise”\nExercise Solution","metadata":{"id":1167829476645524,"pageNumber":12,"bookId":1}},{"text":"Take a moment and consider your smartphone. It does it all—it lets you take pictures and videos, browse the web, post to your favorite social networking site, track your fitness activity, and navigate via GPS. And somewhere, embedded deep within the settings, there’s even a phone! As you can see, your phone is a monolithic system. We’d like you to jot down the pros and cons of such a system. Think in terms of architectural characteristics, like availability, upgradability, cost, and ease of use.\nJust a few years ago, people used separate devices for all those functions your phone performs today. Phones were, well, just phones, maybe with text messaging. We used laptop or desktop computers to browse the web and post to social networking sites; we could buy fitness trackers to help track workouts and GPS devices to install in cars for navigation help. Each of these “services” was deployed separately.\nJust like you did above, jot down the pros and cons of such a system. Again, think in terms of architectural characteristics.\nStylin’ Architectures Crossword Solution\nFrom “Stylin’ Architectures Crossword”","metadata":{"id":2487674155804935,"pageNumber":12,"bookId":1}},{"text":"Chapter 6. Layered Architecture: Separating Concerns\nWhat if your problem is simple and time is of the essence? Should you even bother with architecture? It depends on how long you want to keep what you build. If it’s disposable, throw caution to the wind. If not, then choose the simplest architecture that still provides some measurable organization and benefit, without imposing many constraints on speed of delivery. The layered architecture has become that architecture because it’s easy to understand and implement, leveraging design patterns developers already know. Let’s peel back the layers of this architecture.\nNaan & Pop: Gathering requirements\nSangita likes simple meals, so she created an Indian-inspired mom-and-pop restaurant called Naan & Pop, specializing in flatbread sandwiches and sodas.\nThe restaurant needs a website where customers can place orders online. Since Naan & Pop is a startup with a small budget, it needs to be simple and created quickly.\nSangita has some specific requirements.\nTime to market\nThe restaurant is already open. The faster they can get the site online, the faster they can start making money. The site should be simple.\nSeparation of responsibilities\nThe company has part-time help with specialized skills, such as user interface (UI) specialists and database administrators (DBAs). Thus, it would help to keep each part of the system separate.\nSimple, yet extensible\nWhile this is Sangita’s first foray into software architecture, she would like to keep building on the company’s online presence and find ways to extend and reuse parts of the system.\nSangita has some software development experience and realizes that many of these goals require a good separation of responsibilities. She passes these requirements to the development team she’s hired for this project. You’re a part of that team, so pay close attention.\nCubicle conversation\nAlex: Our project manager just sent the requirements and goals for Naan & Pop’s web application. It’s so simple. Couldn’t we just find an existing framework or library to handle most of it?\nMara: That would solve the simplicity goal. But Sangita also wants extensibility, and existing frameworks tend to be a bit rigid.\nSam: What kind of extensibility does she want?\nMara: If the restaurant is a success, we might want the site to support different kinds of user interfaces, or we could build integration points for delivery services.\nAlex: Yeah—existing simple applications might not handle the separation of responsibilities Sangita would need for that kind of extensibility.\nSam: But we don’t have time to build a fancy architecture!\nAlex: This seems impossible—how can we build a proper architecture with specializations under these time constraints?\nSam: Fortunately, we’ve already worked with other team members to define the architectural characteristics (for the application’s capabilities) and domain design (for its behavior). We just need to choose the appropriate architecture.\nMara: Those are some serious trade-offs and conflicting goals. We need a simple architectural style that lets us separate responsibilities around technical areas, such as user interface, data, business logic, and so on. That way, adding a new user interface will only affect one layer.\nAlex: “Separate responsibilities...” I just read that phrase in the book Head First Design Patterns! I was reading about the Model-View-Controller design pattern.\nSam: Yeah, but that’s a design pattern—how would you translate that to architecture?\nMara: Lots of design patterns end up in architecture, because often their goals overlap. But, while design patterns can focus just on design elements, architecture has to account for real-world constraints. Let’s crack open the book and see if we can map Model-View-Controller into architecture.\nDesign patterns redux\nTo illustrate the concept of design patterns, the influential book Head First Design Patterns uses the Model-View-Controller (MVC) design pattern, which separates capabilities based on their purpose.\nNote\nA “design pattern” is a contextualized solution to a common problem in software design.\nIn MVC, the model represents business logic and entities in the application; the view represents the user interface; and the controller handles the workflow, stitching model elements together to provide the application’s functionality, as shown here:\nBrain Power\nThe MVC design pattern separates logical responsibilities, but software architecture must also deal with physical systems, like browsers and databases. How would you split the responsibilities covered by MVC within the constraints of software architecture, while maintaining the overall goal of separating responsibilities and concerns?\nLayering MVC\nDesign patterns represent logical solutions to problems, but architecture must deal with real-world constraints like databases, user interfaces, and other implementation details.\nToday’s lnterview\nLayering it on with an architecture star: the Layer\nHead First: Welcome, Layer, to our luxurious studio. I know you have a busy schedule, so thanks for making the time.\nLayer: You’re welcome. As you say, I’m a pretty big deal. They even named an architecture after me!\nHead First: Let’s dig into that, Layer. Why base a whole architecture on you?\nLayer: Great question. I make everything nice and understandable in an application’s architecture, since each layer has a specific responsibility.\nHead First: So, this architecture is just for neat freaks?\nLayer: No! Putting all the similar functionality in separate layers makes it easier to find it again to make changes. For example, if the team needs to add a different database, they only have to change the persistence layer.\nHead First: Ah. So organizing everything allows for easier discovery and updating. Seems like a good reason for an architecture.\nLayer: While unified organization is nice, it’s not the only reason to base an architecture on me.\nHead First: What do you mean?\nLayer: I hate to brag, but us layers are quite flexible—we can be used for all sorts of things!\nHead First: Well, I know you often show up for user interfaces and provide a place to put all the business logic.\nLayer: Sure, we do the heavy lifting for those. But teams can mold us into all kinds of UIs. For instance, a services layer can provide an interface to other applications that need to interact with this one.\nHead First: Do you have a good example of how teams have leveraged you, Layer?\nLayer: You bet! I worked with a team that handled loyalty programs for a hotel. Every purchase a user made could qualify for bonus points, depending on their membership status, years of membership, and a bunch of other complicated stuff. The team successfully used a bonus layer to keep all the calculations in a single place.\nHead First: OK, that sounds useful. Can you address the recent controversy about your chilly relationship with Domain-Driven Design?\nLayer: What kind of interview is this? There’s no credence to those rumors that we can’t get along. Well, as you know, I specialize in technical separation. My friend DDD focuses more on domain or business separation. I’m happy to host a domain in my architecture, but it’ll likely have to split across the layers.\nHead First: Isn’t it true that you’re older than other architectural styles?\nLayer: The idea of layers in architecture predates just about any other concept. And is that really surprising? When architects start thinking about how to organize things, I just make sense.\nHead First: We’re nearly out of time, but can you tell us about your cozy relationship with the monolith? You seem to be hosted by it a lot.\nLayer: No comment.\nGreat question. Requests and responses flow through the layers.\nIn a layered monolithic architecture, when a user asks the system to do something, the user interface initiates the request. Then that request flows through each layer in the architecture. If the database is involved in persisting something, then the request goes from top to bottom and back.\nLayering it on\nFor an application like the Naan & Pop site, your team will build logical components to match the problem. But how will you implement those components?\nLayers, in this type of architecture, are created with packages or namespaces, just like domain components. However, to maintain the separation of concerns, the layers’ package structures typically reflect their place within the partitioning:\ncom.naanpop.orderapp.presentationcom.naanpop.orderapp.workflowcom.naanpop.orderapp.modelcom.naanpop.orderapp.persistence\nNote\nThe fully qualified names of these layers will appear as packages in Java, namespaces in .NET, or whatever namespacing mechanism your language of choice uses.\nLike the logical components, the architectural layers use the component implementation of the underlying platform, which often maps to the underlying filesystem:\nTranslating layers into code\nOnce your team has built the component packages (or namespaces), you’ll need to assist the developers in implementing the architecture. Here’s an example in Python-like pseudocode to illustrate how the layers translate to code.\nThe user interface layer, or presentation layer, is the topmost layer. It’s responsible for interacting with the user, serving the same purpose as the view part of MVC.\nThe workflow layer (sometimes called the business rules layer) is responsible for processing each request from the UI layer and returning a response.\nThe persistence layer (or data access layer) is responsible for accessing the data from the database and returning it to the workflow layer.\nthere are no Dumb Questions\nQ:You said in Chapter 5 that every architectural style has a category and a philosophy. Where does the layered architecture fit in?\nA: We’re glad you’re thinking about that. As we said in Chapter 5, understanding the categories reveals a lot about what characteristics a particular architectural style will support.\nThe layered architecture is a technicallypartitioned architectural style, typically deployed as a monolith. (We say typically because we’ll discuss some variations on this model soon.)\nThis is an important point—the domain behavior lives across the layers in this architecture.\nThe domain, as you’ll recall, represents logical components based on the problem you’re trying to solve. However, the layers in this architecture represent technical capabilities—user interface, business logic, and so on.\nThe domain maps onto the layered architecture, sometimes spreading between layers.\nthere are no Dumb Questions\nQ:Why these particular layers—presentation, workflow, and persistence?\nA: These are common layers, but they are by no means required. Most applications have at least some of this separation: for instance, the UI is often distinct from the core logic of the system, which in turn is separate from the database development.\nQ:Was the layered architecture inspired by the Model-View-Controller design pattern?\nA: The opposite is likely true. Layered architectures, which have existed as long as people have been building software from different parts, may well have inspired the design pattern. Design patterns are often harvested from observations of common occurrences, and the layered architecture has been around for quite some time in many forms.\nDomains, components, and layers\nIn a simple restaurant ordering system like Naan & Pop’s, we might come up with the following components based on the problem domain:\nBut there’s a problem. These components are based on the logical behavior of the domain, but the layered architecture splits things by capabilities. So, we need to separate the logical components (which include workflows and entities) into components that match what we need for the layered architecture:\nOnce we’ve split the logical components into workflow and entities, we can overlay the components over the layers in this architecture:\nSharpen your pencil\nNaan & Pop’s lead architects have designed a layered architecture. Today, though, they’re off at a daylong breadmaking seminar to learn more about their problem domain, leaving you to sort out which components go where. Can you decide in which layer (or layers) each component should reside? Draw the components below on the layer(s) to which they should map.\nSolution in “Sharpen your pencil Solution”\nthere are no Dumb Questions\nQ:Why go to the trouble of identifying logical components if we have to break them apart to fit them into this architecture?\nA: The logical components represent the problem you’re trying to solve. Mapping that to any architecture means applying real-world constraints (and trade-offs). We’ll show you a more direct domain-to-architecture mapping in the next chapter, but it has trade-offs, too.\nQ:Why is the layered architecture so popular?\nA: This architecture shows up a lot. First, it’s simple, without many moving parts. Second, as you’ve seen, it maps closely to the MVC design pattern, making it easy to understand. Third, it’s so common that teams can build simple projects quickly in this style. Fourth, many companies separate their employees by skill set, which facilitates an architecture with similar partitions.\nDrivers for layered architecture\nWe’ve put together a list of the things the layered architecture is really good at—that is, the things that might drive us toward picking this particular architectural style.\nSpecialization\nUsing a layered architecture allows organizations to split teams into specialists, sharing their capabilities between different projects.\nNote\nThe ability to specialize makes this architecture popular in organizations that need to share special skills across multiple projects.\nMatches physical separation\nThe layered architecture typically separates the logical components to match the physical separation. For example, it’s common for teams to implement different layers in different technology stacks (such as JavaScript, Java, and MySQL).\nNote\nOften, the real world prevents architects from designing what they want, instead forcing them to design with what they have.\nEase of (technical) reuse\nSplitting the architecture by technical capabilities allows better opportunities to reuse code. For example, if all persistence code resides in a single layer, it’s easier for developers to find, update, and reuse it.\nNote\nThe ability to reuse components within a layer is one of the key advantages of this architecture for many organizations.\nConceptual twin of MVC\nSimplicity and concerns about feasibility are driving forces in many architectures. Developers find it easier to understand and work within an architecture that matches familiar design patterns, such as MVC.\nNote\nFeasibility and simplicity for the win!\nLayers, meet the real world: Physical architectures\nThe layered monolith describes a logical architecture, but architects may implement that logical architecture in a variety of physical architectures.\nPhysical architecture trade-offs\nWhich physical architecture should you choose? Well, they all have trade-offs, like everything in software architecture.\nExercise\nGeneric trade-offs are one thing, but software architecture is always based on a real system. The architects at Naan & Pop need some help evaluating the trade-offs for each physical architecture as they decide which one to use. Can you help them figure out which specific trade-offs the Naan & Pop application will face for each physical architecture?\nSolution in “Exercise Solution”\nCubicle conversation\nAlex: Is Naan & Pop generic enough to only use the standard layers? When do teams add layers?\nSam: Why add layers to the architecture?\nMara: Each layer in a layered architecture has a specific responsibility within the system, so when they’re needed, we add layers.\nSam: What kinds of layers?\nAlex: It’s common to add a services layer, which provides access for business-to-business integration, or integration layers for other internal systems. Each request goes through each layer, so layers need to be things that happen to every request.\nMara: That’s right—architects can add whatever layers we need to support some new behavior. For example, the site needs integration with third-party delivery services, so maybe we should add an integration layer. Here, let me draw what I have in mind for our layered architecture on the whiteboard...\nAlex: Adding an integration layer for our delivery hooks would make things easier, wouldn’t it? It looks like all the code pertaining to that integration lives in the same place, which would make it easy to find and update.\nMara: Yes, and that’s true for the user interface layer, too. In fact, one of the next requirements we have to implement is an additional UI to support mobile.\nSam: So, if we add a separate mobile UI, we’d only have to change one layer?\nMara: That’s one of the best things about layered architecture!\nOne final caveat about domain changes\nOne of the primary advantages of a layered architecture is that it lets us group similar technical things together. For example, in the Naan & Pop application, separating the UI into its own set of components allows the team to add new UI types without affecting the other layers.\nLet’s pause for a second and think about this—what about changes to the problem domain? If Naan & Pop wanted to add something other than sandwiches to the menu, like pizza, would every layer have to change?\nThe power to change things in isolation is the layered architecture’s superpower, but it’s not a silver bullet. This architectural style’s big trade-off is that the problem domain is smeared across the layers in the architecture. For example, the Place Order logical component in the Naan & Pop architecture requires a UI (presentation), code to implement the workflow (workflow), and a data schema (persistence).\nThat means that technical capabilities are easy to change and enhance, but domain changes can create side effects that ripple through the layers.\nNote\nWe alluded to this earlier in the chapter.\nLayered architectures facilitate technical changes but make domain changes more difficult.\nSo, what to do? Well, there’s a reason why we started this book by showing you how to identify the architectural characteristics your application needs to support. If continual, significant domain changes are expected or suddenly become a higher priority, there are other architectural styles to consider.\nNote\nTake a deep breath. The next chapter will introduce you to an architectural style that is better suited to accommodating domain changes. Oh, the suspense!\nAll that said, let’s quickly summarize the good and bad of the layered architecture.\nthere are no Dumb Questions\nQ:That’s a rather large caveat. Why would I even consider the layered architectural style?\nA: Remember the First Law of Software Architecture—everything’s a trade-off. Sure, other architectural styles might allow for easier changes to the domain, but they have their own caveats. Align the strengths and weaknesses of every architectural style with your requirements, and then choose. There’s no one right choice, just the choice that works best for your particular set of circumstances.\nLayered architecture superpowers\nLayered architectures have been demonstrating their powers for many, many years—this is one of the oldest recognizable architectural styles.\nFeasibility\nIf time and budget are overwhelmingly important, the simplicity of this architecture is quite appealing.\nNote\nIf your whole company runs on investment dollars, feasibility is especially important.\nTechnical partitioning\nArchitects design components around technical capabilities, making it easier for them to reuse common capabilities. For example, if several teams need the same data functionality, they could implement it once in a persistence layer and then share it across teams.\nData-intensive\nSystems that do a lot of data-level processing may benefit from a layered architecture because it isolates data processing in a single database that’s optimized for the task.\nNote\nIn general, the less a system needs to access data over the network, the more efficient it can be.\nPerformance\nWell-designed layered monoliths can demonstrate high performance—making no network calls and processing data in a single place (the monolithic database) means there’s no need for network calls that could decrease performance.\nQuick to build\nSimplicity plus a single work/deployment unit means that teams can build small systems quite rapidly.\nLean and mean\nKeeping these systems small helps avoid some of the kryptonite on the next page.\nLayered architecture kryptonite\nThis architecture is pervasive and popular, but it can be overused and even abused. While feasibility may be a superpower, many teams default to this architecture because of its simplicity, long history, and widespread use, without considering if it’s really the most suitable option.\nDeployability\nAs monolithic systems get bigger, deployments tend to become more complex—especially when developers keep adding behavior.\nBig ball of mud\nBecause everything is connected to everything else, this architecture can become a highly coupled mess without careful governance.\nScalability\nProbably the biggest problem with monoliths is that when you only have one bucket and you keep adding things to it, it will eventually fill up. The same is true for monoliths generally, which eventually become constrained by some resource (memory bandwidth, and so on).\nElasticity\nA single process has a harder time dealing with sudden bursts of users.\nTestability\nHigh coupling and a large codebase make testing harder and harder over time.\nLayered architecture star ratings\nThe Naan & Pop architecture team decides to use a rating chart they found in the book Fundamentals of Software Architecture (O’Reilly), written by two of your authors, that describes the layered architecture in a convenient way. One star means that the architectural characteristic is not well supported; five stars means the architectural characteristic is very well supported.\nNote\nJust like movie reviews.\nExercise\nWhich of the following systems might be well suited for the layered monolithic architectural style, and why? Hint: Take into account its superpowers, its kryptonite, and the nature of the system.\nSolution in “Exercise Solution”\nWrapping it up\nCongratulations! The Naan & Pop team looked at several architectural styles, but after considering the business’s priorities, you chose a layered architecture. This paid off handsomely, allowing the business to grow without any problems.\nBullet Points\nA layered architecture is monolithic: the entire system (code and database) is deployed as a single unit.\nThe layers are separated by technical capabilities. Typical layers in this architecture include presentation (for the user interface), business rules (for the workflow and logic of the application), and persistence (facilities to support databases for systems that need persistent data).\nThe layered architecture supports feasibility well; it is easy to understand and it lets you build simple systems fast.\nThe layered architecture supports excellent separation of technical concerns, making it easy to add new capabilities like user interfaces or databases.\nThe layered architecture mimics some of the same concerns as the Model-View-Controller design pattern, but translated into physical layers and subject to real-world constraints.\nUser requests flow through the user interface and through each layer before a response is returned to the user.\nEach request in this architecture goes through each layer.\nA layered architecture’s capabilities degrade over time if teams continue to add functionality due to eventual resource limits (for example, they run out of capacity).\nThe layered architecture provides excellent support for specialization (user interface designers, coders, database experts, and so on).\nLogical components represent the problem domain, yet layers focus on technical capabilities, requiring translation between the domain and architecture layers.\nA layered architecture may manifest in several physical architectures, including two-tier (also known as client/server), three-tier (web), and embedded/mobile.\nChanging and adding to the technical capabilities represented in layers is easy; the layered architecture facilitates this.\nChanging the problem domain requires coordination across the layers of the architecture, making domain changes more difficult.\nLayered Architecture Crossword\nReady to add learning on top of learning by solving the layers of this crossword?\nAcross\n3. Layered architectures use familiar design _____\n5. Kind of layered architecture often found in smartphone apps\n6. Type of architecture covered in this chapter\n8. _____ can be confined to one layer\n9. Namespaces and packages correspond to the directory _____\n11. Too much coupling can lead to a big ball of _____\n14. Layer that maps object models to relational models for databases\n17. Depending on the network for data access makes an architecture _____ reliable\n19. Kind of database often used for persistence\n21. Layered architectures might have two or more _____\nDown\n1. The integration layer lets the system _____ with third parties\n2. Layered architectures facilitate _____\n4. The _____ domain spreads across all of the layers\n7. Logical and _____ components are usually separated in the same way\n10. Logical _____ reside in layers\n12. Domain-driven _____\n13. Layer that applies business rules\n15. The user _____ is part of the presentation layer\n16. The MVC pattern and layered architecture both _____ responsibilities\n18. A user’s request and its response _____ through the layers\n20. Model-_____-Controller design pattern\nSolution in “Layered Architecture Crossword Solution”\nFrom “Sharpen your pencil”\nSharpen your pencil Solution\nNaan & Pop’s lead architects have designed a layered architecture. Today, though, they’re off at a daylong breadmaking seminar to learn more about their problem domain, leaving you to sort out which components go where. Can you decide in which layer (or layers) each component should reside? Draw the components below on the layer(s) to which they should map.\nFrom “Exercise”\nExercise Solution\nGeneric trade-offs are one thing, but software architecture is always based on a real system. The architects at Naan & Pop need some help evaluating the trade-offs for each physical architecture as they decide which one to use. Can you help them figure out which specific trade-offs the Naan & Pop application will face for each physical architecture?\nFrom “Exercise”\nExercise Solution\nWhich of the following systems might be well suited for the layered monolithic architectural style, and why? Hint: Take into account its superpowers, its kryptonite, and the nature of the system.\nLayered Architecture Crossword Solution\nFrom “Layered Architecture Crossword”","metadata":{"id":2724360424830263,"pageNumber":13,"bookId":1}},{"text":"Chapter 7. Modular Monoliths: Driven by the Domain\nThere’s more than one way to build a monolith. So far, you’ve encountered the layered architecture, which aligns things technically. You can go a long way with a layered monolith, but when changes begin to involve lots of communication and coordination between different teams, you might need a little more horsepower under the hood—and perhaps even a different architectural style.\nThis chapter looks at the modular monolith architectural style, which divides applications up by business concerns as opposed to technical concerns. You’ll learn what this means, what to look out for, and all the trade-offs associated with this style. Let’s take the modular monolith for a spin, shall we?\nAs a reminder, Naan & Pop’s sandwich shop has a small development team, and its requirements haven’t changed a whole lot since the team built their layered application in Chapter 6. The competition is stiff, and time to market remains a concern. The system should remain simple.\nNote\nBe sure to review Chapter 6 if you need to refresh your memory.\nExercise\nCast your mind back to the layered architecture we built for Naan & Pop in Chapter 6. The following diagram shows its layers and logical components. Adding a new category to the menu (say, pizza) means changing a bunch of moving parts. Grab a marker and put a triangle () next to everything this new requirement will affect.\nSolution in “Exercise Solution”\nCubicle conversation\nAlex: Pfft! This is easy. We’ve already delivered a working and extensible system. Let’s get to it.\nMara: Hold your horses. This might be our first rodeo with such a change, but I doubt it’ll be our last.\nSam: So what? We’ve built an extensible system. Why are you being so reticent?\nMara: Let’s think this through—we have to add pizzas to the menu. Not only will we have to add new recipes and ingredients, but we’ll also need to allow patrons to order pizzas online. So where will we have to make changes?\nSam: Lots of places! It’ll at least affect ordering and recipe management. I still don’t see a concern.\nAlex: I think I do. We’ve built a layered architecture, and we have specialists working on each layer. A change like this means coordinating changes across all of those folks.\nMara: Bingo! The layered architecture smears the domain across all the layers. So, implementing anything that changes the domain can be arduous.\nAlex: You’re telling me that choosing the layered architecture was a mistake?\nMara: The layered architecture was simple and quick to build. It allowed us to launch quickly. But now we need to think about maturing the architecture to support modularity, so changes like these will be easier in the future.\nAlex: So where do we start?\nMara: Allow me to introduce you to the modular monolith. Rather than partitioning by technical concern, we’ll partition by business domain, using modules—hence the word modular. I’ll show you what this looks like as I explain it.\nSam: Ooh, I’m so excited. Let’s do it!\nModular monolith?\nA modular monolithic architecture, like a layered architecture, is deployed as a single unit, usually with its own database.\nNote\nThink back to Chapter 5. Architectural styles can be separated by how the code is partitioned and by deployment model.\nThat’s where the similarity ends. In a modular monolith, rather than partitioning your application by technical concerns, you partition it by functionality. Every business operates within a certain domain—like banking, education, or retail. Online stores usually have several subdomains, like Order Placement, Payment, and Inventory Management. Together, they make up the Online Store domain. You organize your application according to these subdomains, separating them into modules.\nNote\nHeads up—you’ll find the terms domain and subdomain used interchangeably. As long as you understand that both terms represent business concerns, you’re good.\nWhat is a module? At a high level, it’s just how you organize your code. In some languages, you might have support like packages or namespaces. But it doesn’t start or stop there.\nPartitioning your code using modules has implications for how you’ll go about separating concerns between modules and how modules will interact with each other. We have a lot more to say about this, so stay tuned. For now, we just want you to be able to distinguish between the layered and modular monolith architectural styles.\nthere are no Dumb Questions\nQ:Can you explain more about what you mean when you say module?\nA: A module is a software design element representing an independent unit that fulfills one piece of functionality. Technically, every layer in a layered architecture is a module—these modules just happen to be divided by technical concern.\nIn a modular monolith, on the other hand, each module represents a particular piece of the domain—that is, a subdomain. Each module contains all the business functionality needed for that particular subdomain.\nWho Does What?\nIdentifying which components should belong to a particular module can be tricky. In this game of “Who Does What?”—or rather, “What Goes Where?”—we’d like you to match each component to the module where it fits best. Multiple components can belong to one module.\nSolution in “Who Does What? Solution”\nDomain pains changes\nNaan & Pop wants to add a new food category (pizza) to the menu. Which parts of the architecture need to change to make this happen? Let’s take a look.\nIntroducing a new menu category primarily affects the Order domain. The menu needs to allow customers to order pizzas and customize their toppings. That might require changing or adding new business rules to support customization and perhaps delivery, since pizzas need to be delivered hot. It could also change how the system stores orders (since customers may ask for customizations.)","metadata":{"id":3380360415695189,"pageNumber":14,"bookId":1}},{"text":"As you can see, introducing new menu items can affect multiple components across multiple layers. This is because, as mentioned in the previous chapter, in a technically partitioned architecture the business domain gets “smeared” across multiple layers. This is great if you’re implementing a technical change, like changing the view technology or swapping out the database. But it’s not so great if the change affects the domain—you’ll have to round up folks from multiple teams to figure out how to implement it.\nNote\nNo one ever woke up and said, “How can I add yet another meeting to my calendar?”\nThis is where modular monoliths can really help.\nGeek Note\nIt’s not unusual for teams to start with a layered architecture, then refactor it into a modular monolith over time as the application grows.\nWhy modular monoliths?\nWhen you eat a burger (or a veggie burger!), do you take a bite of the top bun first, then bite into the gooey cheese, then take a bite of the patty? Or do you take one bite that slices vertically through every layer of the burger? The latter, right?\nNote\nEvery layer in a burger serves a specific purpose—so it tastes best if you bite through all the layers together.\nNote\nYum!\nThat’s exactly how you can think of a modular monolith. You don’t organize the application in horizontal layers separated by technical concern, but in vertical slices scoped by business concern. Each vertical slice aligns with a piece of the domain and is encapsulated in a module. Every module contains a set of business functions—for example, order placement, order completion, and order delivery would all be part of the Order Placement module.\nWhat does this mean? Changes to the domain that affect many or all layers require lots of coordination between different teams. You’ll need to ensure that everybody’s changes work with everybody else’s.\nNow, rather than having teams that specialize in the presentation layer or the persistence layer, you have cross-functional teams, each specializing in a domain. The result? It’s far easier to coordinate domain changes when one team takes full ownership.\nNote\nThis isn’t business-word bingo! It’s not always easy to build out cross-functional teams that work in multiple different technical stacks.\nHow astute of you! You’re absolutely right that each module here still consists of layers—but they don’t have to. The important thing is that your application is organized by domain.\nYour system still needs to process and respond to each request, though. So you’ll need an entry point (presentation layer), some business processing (workflow layer), and maybe a data store to write to (persistence layer). Even within a modular architecture, it makes sense to separate those responsibilities, much like the layered architecture does.\nHowever, if you zoom out and look at the whole architecture, you’ll see that the application is carved up into subdomains. The fact that each module is composed of a bunch of technically partioned layers becomes an implementation detail, as opposed to an architectural concern. In other words, how a module is laid out internally isn’t how the architecture is partitioned. Modular monoliths are domain-partitioned.\nLet’s get a bit more concrete by seeing what this looks like in code.\nShow me the code!\nYou’ve probably recognized that modular monoliths solve the problem you are working on differently from a layered architecture, by organizing applications by domain rather than technical concern. But how does this translate to your code?\nLet’s first talk about the modules themselves. They represent parts of the domain. Naan & Pop’s namespaces look like this:\nRemember, we’re still working with a monolith—that is, it’s still one deployment. Typically, one deployment would translate to one codebase, with the code organized in different namespaces. Each namespace represents a separate module, like so:\nExercise\nA critical piece of successfully developing modular monoliths is understanding the domain well enough that you can break it into individual modules. One way to do that (and there are many) is to really listen to your business experts.\nSay you are working for a startup that’s creating an expense-tracking app for small to medium-sized businesses. Here are the business requirements:\nThere are users and auditors. Users add expenses, and auditors review expense reports to ensure they align with policy guidelines.\nWhen a user adds an expense, it is recorded in the database for that user.\nThe app creates an audit trail that the auditors can use to ensure that everything is in order.\nCan you identify the subdomains that should make up this application? Hint: Not everything your business users say will translate into a module.\nSolution in “Exercise Solution”\nCubicle conversation, continued...\nAlex: I get it. We’re increasing the modularity of the codebase because our application is divided up by modules.\nSam: That sounds great in theory, but it’s not like they can all work independently of each other. Doesn’t the ordering side of things need to know what ingredients we have in our inventory? God forbid the kitchen should run out of mushrooms!\nMara: You’re both right. Splitting the application up by business concern means we’re increasing its modularity. But on the flip side, different parts of the application might also need to talk to each other.\nAlex: But it’s one codebase. I can just have the ordering side make an API call to the inventory module, right?\nSam: Oh, brilliant. I can already see the big ball of mud forming! Soon every module will be talking to every other module, and then there goes our modularity.\nMara: Right. If you just start making calls between modules willy-nilly, soon enough there won’t be any boundaries left. Everything will just start referencing everything else. And that would be, well, a big ball of mud.\nAlex: So how do we maintain separate modules, but still have them talk to one another?\nMara: Let me show you.\nKeeping modules modular\nModular monoliths are, well, monoliths, so they’re generally contained in one codebase. That makes it easy for someone working in one module to inadvertently reach into another module and end up coupling the two modules together.\nNote\nThe auto-import feature in your IDE is not your friend here! It’s way too easy to accidentally reference another module without realizing it.\nThe philosophy of the modular monolith centers on partitioning by domain within a monolithic deployment model. Your objective should be to create loosely coupled modules so that changing one doesn’t affect others. So how do you avoid the big ball of mud? Read on.\nNote\nYou got it! Callback to Chapter 5.\nBrain Power\nCan you think of any mechanisms to help you ensure that one part of your application won’t accidentally access another? For example, does your favorite programming language provide any support at compile time to keep modules separate? Jot down any ideas that come to mind here. You can see some of our ideas at the end of the chapter.\nSolution in “Exercise Solution”\nFrom a code design perspective, it’s best to think of each module as a separate service. Just to be clear, though, they aren’t really separate—they all still constitute one monolithic deployment. Each “service” exposes a public API while shielding its internal implementation from the other modules.\nAs long as modules only talk to one another through their public APIs, you can safely change one module without affecting others—thereby reducing their coupling.\nOf course, this sounds like a great idea in theory. But how can you maintain module boundaries so well that you can sleep peacefully at night? Let’s look at a few possibilities.\nthere are no Dumb Questions\nQ:Dividing my application into modules sure seems like a lot of trouble. Are modular monoliths really the better option?\nA: We’ve said this before, and we’ll say it again—we don’t like words like better. It’s always about trade-offs. So far, we’ve tried to highlight some of the benefits of modular monoliths (and we aren’t done yet), while also pointing out some of the challenges.\nDo modular monoliths require more thought and discipline, and maybe even more tooling (as we’ll see in a minute)? Absolutely.\nBut the trade-off is a much more modular architecture that allows cross-functional teams to work independently and thus move faster.\nKeeping modules modular (last time!)\nKeeping your modules modular isn’t as easy as it seems, but don’t lose hope just yet. You have options, depending on your technical stack—especially if you apply some creative thinking and elbow grease.\nSome languages, like Java, have built-in support to build modules. The Java Platform Module System (JPMS) allows you to build modules that are isolated from one another. The .NET platform, meanwhile, offers namespaces that use the internal keyword for this purpose.\nAnother approach is to break up your project code so that each module is a separate folder in your repository. These subprojects (or, as many build systems call them, multimodule projects) force isolation by virtue of being different projects. You might even consider creating different repositories to contain individual modules, then stitching the complete application together at build time.\nNote\nGradle, the Java build tool, supports subprojects.\nOf course, you are still deploying a monolith, so you’ll probably need to bring all the modules together using your build tool of choice. A monolithic deployment model doesn’t have to mean a monolithic codebase!\nArchitectural governance tools, like ArchUnit for Java projects and ArchUnitNET for the .NET platform, can help maintain module boundaries as a project grows.\nNote\nCheck out ts-arch for TypeScript and JavaScript projects!\nAnd none of these options needs to stand alone: you can use one or more together.\nthere are no Dumb Questions\nQ:Am I way off base here, or could these techniques be useful even for layered architectures?\nA: Give us a moment to wipe away the tears—you’ve grown up so fast! Absolutely; they can be useful whether your project is partitioned technically or by domain. It’s a great idea to use tools (like ArchUnit) and language features (like JPMS) to enforce module boundaries, regardless of architectural style.\nThat would be the logical end of modularization, wouldn’t it? Modularizing the code may not be enough. If all your data is still intertwined, then you’ve just moved your ball of mud into the database!\nBefore we go further, a caveat: most developers are not used to thinking vertically along business concern lines or breaking up their code into separate modules. Extending that modularity all the way to the database sounds like a great idea—it is—but it may be too much to take on all at once. Feel free to evolve your architecture over time when needed, rather than trying to get it all right the first time around.\nPut all the lessons you’ve learned in this book at work. Do your architectural characteristics push you to pick the modular monolith architecture? If so, start by modularizing your code first. Once your team gets the hang of thinking modularly, then see if it helps to take that approach all the way into the database.\nNext, let’s see what modularizing your database might look like.\nTaking modularity all the way to the database\nThe modular monolith is still a monolithic deployment, typically with a monolithic database backing it. There is a lot of power here: having a single database can make things a lot simpler. You don’t have to worry about transactions or eventual consistency, and most developers are very comfortable working with just one database. However, if you intend to maintain modularity at all levels, then you should consider modularizing your data.\nThe rule is simple: every module should access only its own tables. Here’s how you’d accomplish this for Naan & Pop:\nFor every module in your application, you define a schema and a set of tables. Any and all data that belongs to a particular module will reside only in the tables for that module.\nAs you can see, you can extend modularity all the way to the database by separating data that belongs to different modules into different tables (and maybe even different schemas).\nBrain Power\nTake a few moments and think about the implications of modularizing your database. What pros and cons can you think of?\nSharpen your pencil\nTake a look at the following table names and see if you can identify which tables belong to the schemas we’ve identified for the Naan & Pop database. Draw an arrow from each table to its schema.\nSolution in “Sharpen your pencil Solution”\nBeware of joins\nKeeping different tables, perhaps even in different schemas, does partition the data belonging to different modules—but it’s easy to slip up and accidentally perform a SQL join across tables that belong to different modules. Then you’re back to tight coupling!\nIt’s OK to store the IDs of records that belong to one module in another module’s tables. For example, the Naan & Pop Order domain is allowed to store “recipe item” IDs in its tables within the order_schema. If it ever needs more information about a particular item, it calls the Recipe module’s API and provides it with the recipe item’s ID.\nNote\nRead that again! This is not a foreign key reference.\nAnd there you have it. Now, as we’ve done before, we’ll show you some of the strengths and weaknesses of modular monoliths, followed by our star rating chart.\nModular monolith superpowers\nHere are some good reasons to use modular monoliths:\nDomain partitioning\nArchitects can design components around domain concerns, then build teams that specialize in one or more of these domains (as opposed to a technical specialization). Domain partitioning is the key superpower of this architectural style.\nDomain-based alignment\nModular monoliths encourage crossfunctional teams, which are better aligned with the domain than the technically partitioned teams used in layered architectures.\nPerformance\nPerformance is usually very good, like for most monolithic architectures. There are no network calls between modules, and all data processing happens in a single place.\nMaintainability\nModular monoliths separate business concerns from one another, with crossfunctional teams each specializing in a subdomain. This makes it easier to maintain the code, as long as changes don’t cross into other domains.\nTestability\nSince the scope of changes is limited to one module, testing is much easier. And since a cross-functional team’s members understand their subdomain really well, they can build out an entire testing suite, including integration, smoke, and end-to-end tests.\nModular monolith kryptonite\nOf course, there are always trade-offs. Here are some reasons not to use a modular monolith architecture:\nHard to reuse\nModular organization makes it hard to reuse logic and utilities across modules. For example, you can’t share common functionality between modules without extracting it as a dependency, increasing the coupling between the modules.\n(Still) a single set of architectural characteristics\nEven though modular monoliths are organized by modules, you still get a single set of architectural characteristics for the entire application—even if one business concern has a different set of needs than others.\nModularity can be fragile\nIt’s easy to dilute module boundaries accidentally. Avoiding the big ball of mud takes a lot of governance—and the database is even harder to govern.\nNote\nIt’s particularly hard to avoid joins in SQL via tooling.\nOperational characteristics\nDespite its focus on business concerns, a modular monolith is still, well, a monolith. And as with any monolith, operational characteristics like elasticity and fault tolerance tend to be hard to attain.\nModular monolith star ratings\nWe’ve created a star rating chart for modular monoliths, just like the one we showed you for layered architectures in the previous chapter. One star means that the architectural characteristic is not well supported; five stars means it’s very well supported.\nNote\nJust like movie reviews.\nYou’ll notice that our ratings for modular monoliths’ operational characteristics aren’t all that different from those for layered architectures. From a process perspective (that is, in terms of maintainability, testability, and deployability), however, the modular monolith does a lot better than the layered architecture. That’s because changes to a particular module only affect that module and can be tested in isolation, which reduces the risks involved in deploying software.\nModular monoliths cost a little more than layered architectures because they require the team to be vigilant. They also involve additional governance and tooling to maintain module boundaries.\nExercise\nWhich of the following systems might be well suited for the modular monolith architectural style, and why? Hint: Take into account its superpowers, its kryptonite, and the problem domain.\nSolution in “Exercise Solution”\nNaan & Pop is delivering pizza!\nThe development team has finally grokked modular monoliths! With a modular codebase and a modular database, they now feel ready for any other big changes to Naan & Pop’s menu. Rumor has it that the owners plan to introduce a full Mediterranean menu next. We can’t wait, and we wish them a lot of luck!\nBullet Points\nA modular monolith is a monolithic architectural style that is partitioned by domains and subdomains that reflect business concerns, not technical concerns.\nEach subdomain makes up one module of the application. Each module can contain multiple business use cases.\nEach module can be made up of layers to provide better organization. A module may be technically partitioned as a means to organize its functionality.\nAvoid having code in one module directly access any functionality in other modules. Allowing this can reduce or eliminate the boundaries between modules.\nEach module should have a public API that communicates with other modules while shielding the module’s internal implementation from the rest of the world.\nAvoiding intermodule communication allows modules to change internally without affecting other modules.\nIt takes time and effort to ensure that the modules in a modular monolith remain separate and distinct.\nYou can govern a modular monolith using a variety of techniques. Some languages have built-in support for building modules.\nAnother approach is to physically break up the codebase into separate subprojects or even different repositories. This usually involves using a build tool to bring all the modules back together when you build the monolith.\nThird-party tools can also help with architectural governance.\nYou may choose to use several techniques in combination to ensure the boundaries of individual modules are maintained.\nYou can extend modularity all the way to the database, keeping the data for each module separate.\nWatch that you don’t accidentally couple modules when inserting or fetching data (for example, when using a SQL join statement across tables that belong to different modules).\nModular Monolith Crossword\nModular monoliths are about separating business concerns. Take a look at these separate clues and test your knowledge about this architectural style.\nAcross\n1. Java _____ Module System\n6. _____ to one module don’t require _____ to the others\n8. The Recipes _____ interface is part of the Recipes domain\n9. Each module exposes a public _____\n10. Modular monoliths are good when many teams need to _____ their work\n13. Monoliths generally have one big _____base\n15. Highly rated characteristic in most monolithic architectures\n18. Each domain in this style represents a _____ concern\n19. With a modular monolith, _____ are often cross-functional\n20. Smaller bits of functionality can reside in their own _____ domains\n21. It’s important to maintain _____ between modules\n22. Style of monolithic architecture first used in this system\n23. Databases can show modularity by representing an entity via a _____\nDown\n1. The latest addition to Naan and Pop’s menu\n2. In a domain-partitioned architecture, each domain gets its own _____\n3. If something is an implementation _____, it’s not an architectural concern\n4. If technical concerns are like horizontal “slices” of a monolith, business concerns are ____ slices\n5. “Spaghetti code” is too closely ____\n7. This system is for ____ & Pop\n11. A challenging kind of architectural characteristic for monoliths\n12. Modules use ID references in ____ to look things up\n14. Monolithic and distributed are two kinds of deployment ____\n16. Example of a language that supports creating modules\n17. Modules communicate indirectly, through their ____ APIs\n19. Databases build schemas from related ____\nSolution in “Exercise Solution”\nFrom “Exercise”\nExercise Solution\nCast your mind back to the layered architecture we built for Naan & Pop in Chapter 6. The following diagram shows its layers and logical components. Adding a new category to the menu (say, pizza) means changing a bunch of moving parts. Grab a marker and put a triangle () next to everything this new requirement will affect.\nHere’s some space for you to explain your thought process:\nOffering pizzas probably means the menu will need a new listing. We might need to allow for customized toppings, which would affect the presentation layer and the associated pricing and could introduce new rules. There might be time constraints on deliveries (no one wants a cold pizza). The customizations might also affect how we persist pizza orders (as opposed to other kinds of orders).\nHowever, the recipe and inventory domains won’t be affected. A recipe is a recipe is a recipe—a list of ingredients with a set of steps to follow. And while there may be new ingredients, the inventory domain will manage them just like it would any other ingredients.\nFrom “there are no Dumb Questions”\nWho Does What? Solution\nIdentifying which components should belong to a particular module can be tricky. In this game of “Who Does What?”—or rather, “What Goes Where?”—we’d like you to match each component to the module where it fits best. Multiple components can belong to one module.\nFrom “Exercise”\nExercise Solution\nA critical piece of successfully developing modular monoliths is understanding the domain well enough that you can break it into individual modules. One way to do that (and there are many) is to really listen to your business experts.\nSay you are working for a startup that’s creating an expense-tracking app for small to medium-sized businesses. Here are the business requirements:\nThere are users and auditors. Users add expenses, and auditors review expense reports to ensure they align with policy guidelines.\nWhen a user adds an expense, it is recorded in the database for that user.\nThe app creates an audit trail that the auditors can use to ensure that everything is in order.\nCan you identify the subdomains that should make up this application? Hint: Not everything your business users say will translate into a module.\nFrom “Brain Power”\nBrain Power\nCan you think of any mechanisms to help you ensure that one part of your application won’t accidentally access another? For example, does your favorite programming language provide any support at compile time to keep modules separate? Jot down any ideas that come to mind here.\n• <insert your favorite programming language> feature\n• Repository structure\n• Build tool capabilities\n• Third-party libraries and governance frameworks\nFrom “Sharpen your pencil”\nSharpen your pencil Solution\nTake a look at the following table names and see if you can identify which tables belong to the schemas we’ve identified for the Naan & Pop database. Draw an arrow from each table to its schema.\nFrom “Exercise”\nExercise Solution\nWhich of the following systems might be well suited for the modular monolith architectural style, and why? Hint: Take into account its superpowers, its kryptonite, and the problem domain.\nModular Monolith Crossword Solution\nFrom “Modular Monolith Crossword”","metadata":{"id":7694775651407018,"pageNumber":14,"bookId":1}},{"text":"Chapter 8. Microkernel Architecture: Crafting Customizations\nYou can craft custom experiences, one capability at a time. Some architectural styles are particularly well suited for some capabilities, and the microkernel architecture is the world champion at customization. But it’s also useful for a bewildering range of applications. Once you understand this architectural style, you’ll start seeing it everywhere!\nLet’s dig into an architecture that lets your users have it their way.\nThe benefits of Going Green\nWhat does everyone have lying around? Old electronics! Going Green is a fast-moving startup that plans to capitalize on the market for buying and recycling old cell phones, music players, and other small electronics.\nAfter analyzing the architectural characteristics required, the architects have designed a three-part system, and each part of which needs different capabilities. They’d like your help. Ready? Here’s the system so far:\nBrain Power\nBased on what we know about Going Green’s business model and the corresponding separation of responsibilities in its system, would it be easier for this company to build a monolithic or a distributed architecture? Why?\nBE the architect\nArchitects just can’t stop analyzing stuff. Can you determine three important architectural characteristics for each of the three services in the new Going Green architecture?\nSolution in “BE the architect Solution”\nCubicle conversation\nMara: We need to split up the architecture work for the Going Green application. Mara, you and Alex should work on the device assessment service.\nAlex: Great! That’s the service that assesses the devices users send us to determine value, right? Seems like one of the more interesting parts of the application.\nSam: How often will we need to add new device configurations to the assessment service?\nMara: At least a few times a month, sometimes even a few times a week. This is especially important, because how fast we can update the device assessment service directly affects the company’s profitability.\nSam: Why such a direct connection?\nMara: Going Green makes a profit when it resells the highest-value electronics it receives. Generally, newer devices are in better shape and are worth more. The faster we can add new device assessments, the more money the company makes.\nAlex: Wow, so rapid change is a BIG deal for this service.\nMara: It is! And don’t forget, we have to make sure that supporting new devices won’t affect the system’s support for the existing ones. Are y’all up for it?\nSam and Alex: You bet!\nMara: I think we should consider using a microkernel architecture. That style makes it easier to design and add new capabilities using plugins.\nThe two parts of microkernel architectures\nThe microkernel architecture derives its name from operating system design. The kernel, or core, of an operating system is very small, offering only the most basic capabilities. A microkernel architecture consists of two primary parts: its core and its plugins (any number of them).\nthere are no Dumb Questions\nQ:Is the microkernel architecture technically or domain-partitioned?\nA: Flashback to Chapter 5! Most microkernel architectures are technically partitioned. You could divide the core into layers—perhaps one for presentation, another for business or workflow logic, and so on. However, microkernel is one of those strange architectural styles that can also be domain-partitioned, depending on how you design your plugins.\nAs for deployment models, microkernel architectures are usually monolithic. As you’ll see in this chapter, however, in some scenarios a distributed model might make more sense.\nNot quite. Every microkernel has plugins, but not all plugins belong to microkernels. Unfortunately, there is no definitive dividing line between microkernel systems and systems that support plugins. Mostly, we evaluate how “microkernel-y” an architecture is (let’s call that “microkern-ality”) by how functional its core is without any plugins and how volatile its core is (how often it needs to change).\nThe spectrum of “microkern-ality”\nLots of software supports plugins: IDEs, web browsers, build tools, you name it. But simply supporting plugins doesn’t make a system a microkernel—it’s all about the core. In extreme microkernels, the core can do very little useful work without plugins installed.\nthere are no Dumb Questions\nQ:Is every system that supports plugins a microkernel?\nA: Not at all. Lots of systems support plugins. How much of a microkernel it is (and no one is actually grading you on this) depends on the volatility and functionality of its core.\nQ:Is this architectural style only useful for software development tools?\nA: A lot of development tools use this architecture because it lets them offer programmatic customization, but many business and other applications use it too. It works for any problem domain that requires customization and in which each change acts in isolation.\nQ:Are microkernel and microservices the same thing?\nA: No, the similarity in the names is just a coincidence. Microkernel’s name comes from operating system design, whereas microservices is named for its relatively small and separate deployment units in a distributed architecture.\nExercise\nThe microkernel architectural style shows up in lots of places. See if you can place the specific tools and categories below in the correct place on the spectrum, by determining how much of a microkernel each one is. Hint: Each system’s degree of “microkern-ality” depends on how useful it is without plugins.\nSolution in “Exercise Solution”\nDevice assessment service core\nYou and your team all agree to use a microkernel architecture for the new device assessment service.\nThe core system includes the criteria needed to assess a device, like its age, condition, and model number. For each type of device, it defers to a device-specific plugin that executes the rules to determine how the system will assess the device’s resale value.\nYou decide to use a distributed physical architecture for the plugins, for better scalability. This also gives Going Green the option to add plugins in other languages in the future.\nFinally, you decide on synchronous communication, because the service is sufficiently responsive that there’s no need to add the complexity of asynchronous communication.\nLet’s dig into those decisions a little further.\nYes, we could! The architecture’s capabilities determine whether to encapsulate or distribute the plugins.\nSome microkernel architectures include both the core system and the plugins in a single monolithic architecture; others are distributed, as you might recall from Chapter 5.\nThe microkernel style exists in the shadowy netherworld between monolithic and distributed architectures. Architects can implement it with either deployment model.\nthere are no Dumb Questions\nQ:Does a microkernel architecture’s core system have to be a monolith?\nA: Not necessarily—microkernels often feature in hybrid architectures. When it makes sense (such as for a desktop application), you might implement the core as a single system; other times, you might distribute parts of the core as well as the plugins.\nQ:How do I implement plugins?\nA: You can implement your own plugin designs using interfaces, but virtually all platforms and technology stacks have libraries and frameworks to help out.\nQ:Can I implement plugins in different tech stacks than the stack in which the core is written?\nA: One of the advantages of using distributed plugins is that you can write them using any platform you can call via a network connection.\nEncapsulated versus distributed plugins\nThe core system in a microkernel is where the plugins, well, plug in. Generally, we implement that connection via an interface. The plugin implements the interface, while the core system supports that component via that interface.\nIf we design a microkernel as a monolithic architecture, we’ll implement each plugin as a component that connects to the core through the interface.\nIn other implementations of microkernel architectures, plugins are distributed: web endpoints, event queues, and so on. In addition, we can decide whether to call the plugins synchronously or asynchronously. (We’ll cover this in much more depth in Chapter 11.)\nExercise\nThe assessment service team at Going Green must decide whether the microkernel’s physical architecture should be monolithic (core and plugins in the same deployment unit) or distributed (plugins deployed separately from the core). They need your help with the trade-off analysis. Can you list some pros and cons for each option? We’ll get you started. Hint: Consider how each option would affect things like architectural characteristics.\nSolution in “Exercise Solution”\nPlugin communication\nTo be useful, plugins must communicate with the core system. For example, the core will call a method (based on an interface) and utilize the results. This communication can be implemented in a couple of different ways, based on factors like physical architecture.\nHow the actual call happens between the core and a plugin depends on the physical architecture you use to implement the plugins. In monolithic architectures, we implement plugins in the same technology stack as the core and deploy them as native components for the platform (like JAR files for Java, DLLs for .NET, or GEMs for Ruby).\nAs for distributed plugins, the core can call them with synchronous or asynchronous calls. Developers aren’t restricted to the core’s implementation platform, either—they can write plugins in a variety of languages.\nToday’s Interview\nPlugging into the star attraction of the microkernel: the Plugin\nHead First: Let’s see... let me get my microphone plugged in. Testing, testing... OK, welcome, Plugin!\nPlugin: How appropriate! All sorts of things use me to function. I’m happy to be here—and excited to clear up some controversies.\nHead First: Everyone says you’re the star of the microkernel architecture, yet the core gets more press time and attention. Is that fair?\nPlugin: Well, that may be true, but what good is the core without me? It may be bigger, but without me, the core is boring.\nHead First: You certainly show up in lots of places. What about your controversial role in non-microkernel architectures? Lots of systems support plugins that aren’t microkernels...\nPlugin: I’m happy wherever I appear. To be truthful, though, I prefer microkernels. For other architectures, plugins are just condiments—we’re not necessary, but we add some nice flavors. In a microkernel, though, I’m the main course! The whole architecture is based on me. I appreciate that level of importance.\nHead First: Let’s dig into something that seems to appear in trade-off analyses all the time. Your distributed version has some performance issues, no?\nPlugin: Hey, you can’t say bad things about all plugins just because we have some trade-offs! Yes, it’s true that when we use network calls to communicate, performance does take a hit. But you know what else? Those distributed plugins can scale better, and you can write them in a variety of languages. Different strokes for different folks, right? And different plugin physical architectures for different trade-offs.\nHead First: OK, fair enough. But let’s talk about working with overly volatile cores.\nPlugin: Alas, that’s one of the downsides to starring in a microkernel architecture—when the core decides to change all the time. Change is my job! The more the core changes, the more it’s likely to interfere with what I’m doing. I strive for professionalism, so I prefer to work with nice, stable cores with no drama.\nHead First: You get a lot of press because of your ability to handle customization, but do you have other roles? What else you can handle?","metadata":{"id":1619918343169394,"pageNumber":15,"bookId":1}},{"text":"Plugin: Thanks for asking, Head First. It’s always annoying to be pigeonholed into my best-known role. I can handle customizations without ugly, long switch statements, using an elegant architectural style, without even batting an eye. We plugins can be used for all kinds of things—really, anything that needs good isolation. For example, I show up all the time in A/B testing. The architects keep the old behavior in PluginA, add the new behavior in PluginB, and decide which to call. I also have starring roles in integration hubs, developer tools, and lots of other places.\nHead First: Before we finish up, is there anything you’d like to plug?\nPlugin: You bet! Look for me in an architecture near you, either as an integral part of a monolith or as an endpoint for a distributed microkernel.\nCubicle conversation\nMara: Hi, all. Just stopping by to take a look at your trade-off analysis for the Going Green assessment service. Have you decided yet between a monolithic and a distributed physical architecture?\nSam: We’re working on it. I did the trade-off analysis for the distributed version, and personally, I’m a big fan. Here’s our summary:\nMara: Can you explain how you arrived at these conclusions?","metadata":{"id":5114922580896235,"pageNumber":15,"bookId":1}},{"text":"Alex: Sure. For the distributed version, we don’t have to restart the core system to add new devices. That gives us better availability than the monolithic version, since that requires a restart to load new device plugins. Also, it’s simpler to deploy a single plugin than to redeploy the whole assessment service. Since the plugins don’t run in the same process as the core, we can make the whole system more scalable. But that would take a toll on its performance—after all, network calls take a lot longer than in-process ones.\nMara: That sounds like a good trade-off. The business agrees that scalability is very important for the new system.\nthere are no Dumb Questions\nQ:Where is the user interface in a microkernel architecture?\nA: It depends! If the system is monolithic, architects commonly include the UI as part of the core system. However, when you design a service in a distributed architecture as a microkernel, other parts of the system typically handle the UI.\nQ:Can the UI utilize a microkernel?\nA: You bet it can. In fact, lots of UI patterns (like the BFF pattern we mentioned earlier) use the microkernel structure to handle customized UI endpoints such as iOS, Android, and web browsers.\nQ:Isn’t a microkernel really just the Decorator design pattern?\nA: Good catch! While their purposes are mostly the same, the microkernel architecture is one way to implement the Decorator design pattern. Compared to design patterns, architecture requires more thought about physical limitations and possibilities. For example, design patterns don’t account for capabilities like scalability.\nQ:Is the microkernel style the only way to handle customization?\nA: Not at all. It’s one of many ways. A microkernel architecture is useful when the structure of your system—its core capabilities that rarely change—requires discrete customization via plugins. For systems without that kind of structure, other architectural styles may be more appropriate.\nQ:What’s the internal structure of the core system? Is it just one big logical component?","metadata":{"id":2580676595072320,"pageNumber":15,"bookId":1}},{"text":"A: In the microkernel style, we design the core system based on how we want to organize the logical components in the system. For example, if we want to separate capabilities within the core, we might choose to implement the core via layers, as we would in the layered architectural style. On the other hand, we might follow DDD and design the core around a bounded context, as in the modular monolith style. The microkernel style is often used in hybrid architectures where customizability is a driving characteristic.\nPlugins can talk to one another in a microkernel through the core system. But should they?\nPlugins typically communicate with the core system by implementing an interface that the core supports. That makes it possible for plugins to communicate with each other “through” the core system. For example, the Eclipse IDE, which supports multiple languages, allows language-based tools (like compilers and debuggers) to interact with each other in this way.","metadata":{"id":1538352649058248,"pageNumber":15,"bookId":1}},{"text":"Be cautious about allowing inter-plugin communication, though! It has some serious negative trade-offs. First, it requires consistent contracts between the core and the plugins, which eventually involves versioning. (More about contracts on the next page.) For example, one thing that makes Eclipse complex is the transitive dependencies between its components, which can cause versioning headaches. Second, dependencies between plugins create availability issues, because you must guarantee that all necessary plugins are present at runtime.\nTo understand the problems with letting plugins chat amongst themselves, we have to look at the two ways the core communicates with plugins.\nPlugin contracts\nWhen architects implement microkernel architectures, we usually ensure that the core calls plugins using a contract (another word for interface). That communication is solelybetween the plugin and the core, not between plugins. If you allow communication between plugins, the core has to act as their intermediary.\nIn the example system below, PluginA doesn’t know or care about other plugins; it communicates only with the core. However, PluginX needs to communicate with PluginY, and that communication must be mediated by the core system.\nBrain Power\nYou know you have to worry about intermediary communication through the core system, but consider this: what happens when you update PluginY in a way that changes the contract between PluginX and PluginY? If you don’t want to change PluginX when you change PluginY, how could you manage that communication?\nGoing Green goes green\nAfter considering how best to implement the plugin interaction with the core, the team decides to define an interface (called DeviceInterface) for each plugin to implement. Now Going Green can add new devices just by implementing the interface and customizing the valuation process for that specific device.\nYour device assessment engine is a success. Well done!\nTo wrap up, let’s quickly summarize the strong and weak points of this style of architecture.\nMicrokernel superpowers\nThe microkernel is a common architectural style. It’s also one of the most common styles you’ll find within hybrid architectures that require customization.\nCustom behavior\nThe microkernel is “shaped” in the best way to handle customizations.\nNote\nWho you gonna call to customize part of your application? Microkernel to the rescue!\nEvolvability\nEvolvability, as an architectural characteristic, means that architects can make fundamental underlying changes that gradually evolve the system away from its old behaviors. Unlike adaptable architectures, evolvable architectures only support the old behaviors for a short time. Plugins offer an excellent way to implement this capability.\nPartitioning\nIn a microkernel, you can handle customization with design or with architecture. However, if you use design, the developers must be very diligent about following the design correctly. If the system is structured around plugins, the distinction is clearer.\nNote\nThe microkernel is a great example of an architectural approach to customization\nAdaptability\nAdaptability, as an architectural characteristic, implies the ability to keep existing functionalities and continue adding more. A microkernel supports this well; you can keep old plugins as you implement new ones.\nSimple structure\nA microkernel has two basic moving parts (the core and plugins), making it easy for developers to understand and implement.\nNote\nSimplicity for the win!\nMicrokernel kryptonite\nThe microkernel architecture’s weaknesses mostly appear when architects use it improperly: for example, when the core changes too much or when plugins must communicate heavily with one another.\nMisaligned volatility\nIn a microkernel, the core system should change very little once it is implemented. If it changes a lot, that is likely a sign that this is not the ideal architectural solution or you have made the wrong things plugins.\nNote\nOne of the most common mistakes in a microkernel is a too-volatile core, due to frequent domain changes.\nSharing between plugins\nWhile it’s often tempting, sharing dependencies (such as shared libraries) between plugins is generally a bad idea because it creates headaches around coupling and deployment.\nNote\nTo keep a microkernel from devolving into a big ball of mud, keep an close eye on coupling via sharing.\nChatty plugins\nAllowing plugins to interact may be tempting, but it comes with a host of difficult trade-offs. Successful systems that use this approach (for example, Eclipse) do so at the cost of high complexity.\nPerformance\nWhen using distributed plugins for a physical architecture, you might notice an impact on performance, depending on the communication protocols and how much information passes between the core and the plugins.\nMicrokernel star ratings\nWe’ve created a chart of star ratings, like the ones we showed you for layered and modular monolith architectures, to indicate how well microkernel architectures do with each of the architectural characteristics listed. One star means that the architectural characteristic is not well supported; five stars means it’s very well supported.\nNote\nJust like movie reviews.\nExercise\nWhich of the following systems might be well suited for the microkernel architectural style, and why? Hint: Take into account its superpowers, its kryptonite, and the nature of each system.\nSolution in “Exercise Solution”\nWrapping it up\nThanks to your efforts, Going Green is assessing devices quickly and accurately, and profitability has never been better. This case shows just how useful microkernel architectures can be. For problems that need a customizable, stable system, a microkernel is hard to beat.\nBullet Points\nThe microkernel architectural style provides a structured way to handle customizations via plugins.\nMicrokernel architectures consist of two main parts: the core and one or more plugins.\nThe core system in a microkernel contains minimal functionality and has low volatility.\nArchitects design plugins to customize and/or add behaviors to a system.\nGenerally, plugins only communicate with the core system, not with each other.\nIf plugins do need to communicate with each other, the core must mediate the communication and handle issues like versions and dependencies. It essentially serves as an integration layer.\nMicrokernel architectures can be monolithic architectures or can be implemented as services in a distributed architecture.\nWhen built as a monolithic architecture, the core and plugins must be written in the same language.\nPlugin calls may be synchronous (for example, using REST in a distributed architecture) or asynchronous (using threads in a monolithic architecture or messaging in a distributed one). Whether remote calls are synchronous or asynchronous, architects can implement the plugins in a variety of technology stacks.\nMonolithic plugins generally offer better performance because calls take place in the same process.\nMonolithic microkernels suffer from the typical limitations of all monoliths, including limited operational capabilities such as scalability and elasticity.\nMicrokernels that use distributed plugins may offer better scalability, because they use multiple processes and offer scalable communications (events).\nMicrokernel architectures are best suited for problems with distinct categories of volatility.\nIf a microkernel’s core system changes often, its architects may have chosen the wrong architectural style or may have partitioned the work incorrectly.\nThe microkernel style shows up in lots of places: IDEs, text processing tools, build and deployment tools, integrations, translation layers, insurance applications, and electronics recycling applications, just to name a few.\nMicrokernel Crossword\nReady to see how much you’ve learned about microkernel architecture? Plug into this crossword puzzle!\nAcross\n3. Design pattern often used to implement microkernel architectures\n6. With inter-plugin communication, the core serves as an integration _____\n9. You can add new capabilities to a system by using these\n10. Microkernel architectures can _____ to include new functionalities\n11. Abbr. for a tool used to write code\n13. Monolithic architectures _____ both plugins and core\n14. Plugins are usually _____ independently from each other\n16. A microkernel is great for creating systems with _____ rules and behaviors\n17. You can use plugins written in more than one tech _____\nDown\n1. When plugins can talk to each other, their dependencies are _____\n2. Example of an IDE that uses interacting plugins\n4. _____ plugins provide better performance\n5. Number of primary component types in a microkernel architecture\n7. Constantly changing\n8. Microkernel architectures often support several programming _____\n12. When most monoliths load plugins\n15. A tool that applies style and syntax rules to code\n16. Plugins make _____ to talk to the core\n18. What plugins are plugged into\nSolution in “Microkernel Crossword Solution”\nFrom “BE the architect”\nBE the architect Solution\nArchitects just can’t stop analyzing stuff. Can you determine a few important architectural characteristics for each of the three services in the new Going Green architecture?\nFrom “Exercise”\nExercise Solution\nThe microkernel architectural style shows up in lots of places. See if you can place the specific tools and categories below in the correct place on the spectrum, by determining how much of a microkernel each one is. Hint: Each system’s degree of “microkern-ality” depends on how useful it is without plugins.\nFrom “Exercise”\nExercise Solution\nThe assessment service team at Going Green must decide whether the microkernel’s physical architecture should be monolithic (core and plugins in the same deployment unit) or distributed (plugins deployed separately from the core). They need your help with the trade-off analysis. Can you list some pros and cons for each option? Hint: Consider how each optionwould affect things like architectural characteristics.\nFrom “Exercise”\nExercise Solution\nWhich of the following systems might be well suited for the microkernel architectural style, and why? Hint: Take into account its superpowers, its kryptonite, and the nature of each system.\nMicrokernel Crossword Solution\nFrom “Microkernel","metadata":{"id":1972100707543593,"pageNumber":15,"bookId":1}},{"text":"Chapter 9. Do It Yourself: The TripEZ Travel App\nReady to extend your journey into software architecture? In this chapter, you’re the software architect. You’ll be determining architectural characteristics, building a logical architecture, making architectural decisions, and deciding whether to use a layered, modular, or microkernel architecture. The exercises in this chapter will give you an end-to-end view of what a software architect does and show you how much you’ve learned. Get ready to create an architecture for a startup company building a travel integration convenience site. Bon voyage—we hope you have a good trip building your architecture.\nMaking travel easier\nYou’ve just been hired as a software architect by an exciting new startup called TripEZ (pronounced like “trapeze”) that wants to make travel easier, especially for “road warriors” who travel frequently. The TripEZ app will be an online trip management dashboard that allows travelers to see all of their existing reservations organized by trip, through either a web browser or their mobile devices.\nTripEZ requirements document\n□ The system should continually poll the user’s email account for travel-related emails.\n□ The system must interface with the systems of travel partners (like travel agencies, booking apps, airlines, hotels, and car rental companies) to update travel details. These include delays, cancellations, updates, and gate changes. To beat the competition, updates must appear in the app within five minutes.\n□ Users should be able to add, update, or delete existing reservations manually.\n□ Users should be able to group items in the dashboard by trip. Once the trip is complete, the items should automatically be removed from the dashboard.\n□ Users should be able to share their trip information by interfacing with standard social media sites and by sharing it with specific people.\n□ The system should have the richest user interface possible, across all deployment platforms.\n□ The system should provide end-of-year summary reports with a wide range of metrics about users’ travel that year.\n□ TripEZ should gather analytical data—such as travel trends, locations, airline and hotel vendor preferences, and cancellation and update frequency—from users’ trips for various purposes.\n□ The company would like to ship TripEZ in six months, to coincide with an important trade show.\nPay attention, because these things are important.\nNote\nMeet Travis, former pilot and consultant to TripEZ. He has a few more important requirements for the system.\n“TripEZ must integrate seamlessly with the existing standard interface systems used across the travel industry, including internationally.\nIt must integrate with the user’s preferred travel agency (if any) to resolve problems quickly.\nFinally, users must be able to access the system at all times. Unplanned downtime should be limited to a maximum of five minutes per month.”\nTripEZ’s user workflow\nNow that we have the requirements, let’s get a better understanding of them by looking at the primary workflow for travelers using TripEZ.\nSharpen your pencil\nGiven the requirements for TripEZ, list some challenges that you will need to address when creating an architectural solution.\nSolution in “Sharpen your pencil Solution”\nPlanning the architecture\nWe have to create an architecture first.\nAs you’ve learned, architecture is a critical and necessary part of any software system. Without it, the system will likely fail to achieve any of its goals.\nBefore we start developing code, we have to create an architecture. This means going back to Chapter 1, where you learned about the four dimensions of software architecture.\nDon’t worry—we’ll get the system done. But first, it’s important to know what we’re building.\nThe architects’ roadmap\nLet’s get the TripEZ architecture started. You’ll use the steps you’ve learned in previous chapters to translate the requirements into an architecture.\nThis diagram will serve as your roadmap as you make your way through each of the exercises, so get used to seeing it. The next few pages will walk you through each of these steps.\nGood luck on your journey—TripEZ is counting on you.\nStep 1: Identify architectural characteristics\n“TripEZ must integrate seamlessly with the existing standard interface systems used across the travel industry, including internationally.\nIt must integrate with the user’s preferred travel agency (if any) to resolve problems quickly.\nFinally, users must be able to access the system at all times. Unplanned downtime should be limited to a maximum of five minutes per month.”\nNote\nWe copied the requirements here to make it easier for you to use them to identify the driving architectural characteristics.\nTripEZ requirements document\n□ The system should continually poll the user’s email account for travel-related emails.\n□ The system must interface with the interface systems of travel partners (like travel agencies, booking apps, airlines, hotels, and car rental companies) to update travel details. These include delays, cancellations, updates, and gate changes. To beat the competition, updates must appear in the app within five minutes.\n□ Users should be able to add, update, or delete existing reservations manually.\n□ Users should be able to group items in the dashboard by trip. Once the trip is complete, the items should automatically be removed from the dashboard.\n□ Users should be able to share their trip information by interfacing with standard social media sites and by sharing it with specific people.\n□ The system should have the richest user interface possible, across all deployment platforms.\n□ The system should provide end-of-year summary reports with a wide range of metrics about users’ travel that year.\n□ TripEZ should gather analytical data—such as travel trends, locations, airline and hotel vendor preferences, and cancellation and update frequency—from users’ trips for various purposes.\n□ The company would like to ship TripEZ in six months, to coincide with an important trade show.\nExercise\nIn Chapter 2, we showed you how to use this template to limit the number of architectural characteristics. Flip back to “Limiting architectural characteristics” if you need a refresher on how to use it.\nSolution in “Exercise Solution”\nStep 2: Identify logical components\nGood job! Now that you’ve identified the critical architectural characteristics for TripEZ, it’s time to apply what you’ve learned to create logical components.\nReferring to the requirements and primary workflow on the previous pages, use the actor/action approach described in Chapter 4 to identify actors and their actions. Then identify as many logical components as you can on the next page.\nHere’s some additional information you might find useful for this exercise:\n• When users sign up for TripEZ, they provide credentials to allow the different travel services to provide up-to-date status reports on delays, cancellations, and so on.\n• If a travel partner’s integration point won’t supply updates within the required five-minute window, the system should query the vendor.\nNote\nThis allows the system to work with travel partners that can’t meet its agreed-upon thresholds.\n• Updates, especially to the mobile application, should use as little data as possible to accommodate potentially spotty cell signals in remote places.\n• TripEZ can’t be held responsible for integration point availability; if the call fails, the system must return an error rather than failing silently (which would mislead the user into thinking no update was sent).\nSharpen your pencil\nUsing the actor/action approach, identify actions for each of the actors below.\nSolution in “Sharpen your pencil Solution”\nExercise\nUsing the space below, draw your logical components and their interactions.\nSolution in “Exercise Solution”\nStep 3: Choose an architectural style\nLeveraging what you’ve learned about the layered, modular monolith, and microkernel architectural styles, use the next page to analyze their pros and cons with respect to the TripEZ system. You’ll also need to refer to the requirements, your logical architecture, and the star rating charts for each architectural style (we’ve added those below for you). Choose an architectural style based on your analysis.\nHere are some considerations that might help you decide which architectural style would be better suited for TripEZ:\n• Go back to your logical architecture diagram and see if you can identify distinct technical or business concerns. If so, a layered or modular monolith architecture might be a good choice.\n• Think about different points of integration. If there are many, each with specific logic, then a microkernel architecture might be a good fit.\nExercise\nOutline the pros and cons of each architectural style to help you make a choice about which one might be most appropriate for TripEZ.\nList your winning choice here: _____________________\nSolution in “Exercise Solution”\nStep 4: Document your decision\nCongratulations on choosing which architectural style to use for TripEZ. Now’s your chance to explain why you made the choice you did and document your architectural decision.\nAs you learned in Chapter 3, an architectural decision record, or ADR, is an effective way to document your architectural decisions. Use the ADR on the next page to document your architectural style decision. Assume this is your 11th architectural decision.\nNote\nRevisit Chapter 3 if you need a refresher on architectural decision records.\nEvery architectural decision has consequences.\nMaybe it’s about cost, or maybe it’s sacrificing a little bit of performance to have better security. Regardless, every architectural decision has consequences.\nThink about the trade-off analysis you just did. Each one of those trade-offs implies a consequence—something you were willing to give up (or accept) to get something better. The Consequences section of an ADR is a great place to document your trade-off analysis and the corresponding consequences of your decision.\nIf you can’t find any consequences in your architectural decision, keep looking, because they’re there.\nExercise\nArchitectural Decision Record\nSolution in “Exercise Solution”\nStep 5: Diagram your architecture\nNow it’s time to combine all four dimensions of software architecture and show us your vision of the TripEZ architecture. In this last exercise, you’ll diagram your architecture on the following page using the key on this page.\nWe didn’t give you a lot of room to diagram your architecture, and that’s on purpose. While many architecture diagrams are very detailed, what we’re asking you to do here is to sketch out a high-level physical view of the user interfaces, databases, and components that make up your architecture and how they all connect to each other.\nPhysical Architecture Key\nExercise\nUse this space and refer to the key on the previous page to sketch your physical architecture for TripEZ.\nSolution in “Exercise Solution”\nThere are no right (or wrong) answers\nCongratulations—you’ve just created an architecture!\nWhat we’re about to show you are the exercise “solutions.” We’ve used quotes there because the solutions we present here are just some of many possible solutions. You see, there are no right or wrong answers in software architecture: it’s all about analyzing trade-offs and being able to justify your decisions.\nCompare your answers with the ones we’re about to show you to see how your solutions differ. You can think about what you might have done differently, or confirm that you made what seems to you to be the most appropriate choice. We’ll show you our TripEZ architectures for layered, modular monolith, and microkernel architectures, since all of these styles are viable options.\nSoftware architecture is always a learning process. Each new problem brings a whole new set of conditions, constraints, and business and technical concerns. There is no one-size-fits-all architecture—it’s up to you, the architect, to come up with the most appropriate architecture for your situation.\nBullet Points\nWhen analyzing requirements for a business problem, always gather additional information from the business stakeholders or project sponsor.\nWhile there’s no “checklist” for creating an architecture, the four dimensions of software architecture (introduced in Chapter 1) provide a good roadmap.\nIdentifying driving architectural characteristics requires you to analyze the business requirements and technical constraints.\nImplicit architectural characteristics become driving characteristics if they are critical or important to the success of the system.\nMake sure you can tie each driving characteristic back to some sort of requirement or business need.\nWhen identifying logical components and creating a corresponding logical architecture, try to avoid adding physical details such as services, databases, queues, and user interfaces—those artifacts go into the physical architecture.\nWhen choosing an architectural style, make sure you consider the characteristics of the architectural style, the problem domain, and the driving architectural characteristics you identified.\nHybrid architectures (those combining two or more different architectural styles) are very common. If you use one, be sure to verify that it addresses your critical architectural characteristics.\nArchitectural decision records (ADRs) are a great way to document your choices. They communicate the reasons for your architectural decisions as well as your trade-off analyses.\nWhen diagramming your physical architecture, be sure to include all the components you identified in your logical architecture.\nRemember, there are no right or wrong answers in software architecture. As long as you can provide a reasonable justification for your architectural decisions, you’re on the right track.\nFrom “Exercise”\nExercise Solution\nIn Chapter 2, we showed you how to use this template to limit the number of architectural characteristics. Flip back to “Limiting architectural characteristics” if you need a refresher on how to use it.\nFrom “Sharpen your pencil”\nSharpen your pencil Solution\nGiven the requirements for TripEZ, list some challenges that you will need to address when creating an architectural solution.\n• Making sure that we can deliver alerts in time\n• Supporting a sufficient number of users\n• Finding a way to manage all the different integration points\n• Integrating with social media accounts\nFrom “Sharpen your pencil”\nSharpen your pencil Solution\nUsing the actor/action approach, identify actions for each of the actors below.\nFrom “Exercise”\nExercise Solution\nUsing the space below, draw your logical components and their interactions.\nFrom “Exercise”\nExercise Solution\nOutline the pros and cons of each architectural style to help you make a choice about which one might be most appropriate for TripEZ.\nFrom “Exercise”\nExercise Solution\nFrom “Exercise”\nExercise Solution\nFrom “Exercise”\nExercise Solution\nFrom “Exercise”\nExercise Solution\nUse this space and refer to the key in “Exercise” to sketch your physical architecture for TripEZ.\nFrom “Exercise”\nExercise Solution\nUse this space and refer to the key on the “Exercise” to sketch your physical architecture for TripEZ.\nFrom “Exercise”\nExercise Solution\nUse this space and refer to the key on the prior page to sketch your physical architecture for TripEZ.","metadata":{"id":3923089723867567,"pageNumber":16,"bookId":1}},{"text":"Chapter 10. Microservices Architecture: Bit by Bit\nHow do you make an architecture easier to change? Business is changing faster than ever, and software architectures need to keep up. In this chapter you’ll learn how to create a flexible architecture that can change as your business changes, scale as your business grows, and remain operational even when system failures occur. Intrigued? We hope so, because in this chapter we’re going to show you microservices—an architectural style that solves all of these problems and more. Let’s get started on our journey through microservices, bit by bit.\nAre you feeling okay?\nStayHealthy, Inc., is a company that specializes in medical monitoring systems for patients in hospitals. Using its systems, doctors and nurses can monitor a patient’s heart rate, oxygen levels, body temperature, blood sugar levels, and more, and even determine whether the patient is sleeping or awake. If something goes wrong, a doctor or nurse is notified right away.\nRecent advances in medicine have given rise to a new set of needs for medical monitoring. As a result, StayHealthy plans to leverage newer technology to replace its current patient medical monitoring software with a new system called MonitorMe. Guess what? You’re the architect they chose for the new project.\nBelow are the requirements for the new system. You’ll need to figure out what kind of architecture would be best suited for the job.\nStayHealthy MonitorMe requirements document\n□ The system reads inputs from StayHealthy’s patient monitoring equipment and sends the results to a single monitoring screen.\n□ MonitorMe must analyze each patient’s vital signs and alert a medical professional if it detects a change that reaches a preset threshold.\n□ For each vital sign, the system must record all readings and measurements for the past five minutes. A medical professional should be able to review this five-minute history.\n□ Medical professionals select how they’d like to be notified if something goes wrong. Notifications can be sent to an assigned nurse or doctor’s cell phone or to a central nurses’ station.\n□ MonitorMe reads inputs from eight different input sources. It is vital that if any of these fails, the other inputs will still be monitored and recorded.\n□ The vital signs monitored by the MonitorMe system include heart rate, blood pressure, oxygen level, blood sugar, respiration rate, electrocardiogram (ECG), body temperature, and sleep status (sleep or awake).\n□ The system can measure the vital signs of multiple patients (up to 500) within a single hospital, meaning each physical hospital location has its own copy of the complete system (including the data).\nSharpen your pencil\nBased on the problem domain and requirements document on the previous page, check off the top five architectural characteristics you think are critical to the MonitorMe architecture and indicate why you think they are critical.\nTestability (the ease and completeness of testing)\nReason: _________________________________________________\nResponsiveness (the time it takes to get a response to the medical professional)\nReason: _________________________________________________\nDeployability (the difficulty and ceremony involved in releasing changes)\nReason: _________________________________________________\nAbstraction (the level of isolation and knowledge between parts of the system)\nReason: _________________________________________________\nScalability (the system’s ability to grow to accommodate more users or patients)\nReason: _________________________________________________\nFault tolerance (the system’s ability to continue operating when parts of the system fail)\nReason: _________________________________________________\nData integrity (the data is consistent and correct across the system and there is no data loss)\nReason: _________________________________________________\nWorkflow (the system’s ability to handle complex business workflows)\nReason: _________________________________________________\nConcurrency (the system’s ability to process concurrent requests or operations)\nReason: _________________________________________________\nSolution in “Sharpen your pencil Solution”\nCubicle conversation\nSam: I think we can all agree that microservices is a perfect fit for the new MonitorMe system.\nMara: Hold on—what brought you to that conclusion so quickly?\nSam: It’s obvious, isn’t it? From a domain perspective, we have independent monitoring functions, and we need high fault tolerance and comprehensive testability. Microservices does all this and more.\nNote\nAssumptions like this are a common trap. We’ll show you how to avoid it by better understanding the microservices architectural style and its trade-offs.\nAlex: Slow down a second. I’m not familiar with microservices, and I have no idea how it supports all the things you say it does.\nMara: I agree with Alex. I know that we need a distributed architecture, so microservices might be a fit here. But let’s back up and take a closer look before we jump to any conclusions.\nSam: Okay, I see your point—what might seem obvious to me might not be obvious to you. It’s important that you both understand what microservices is all about, and then together we can decide if it’s the right fit for MonitorMe. So let’s get started.\nWhat’s a microservice?\nWhat’s in a name? When it comes to microservices, plenty. We’ll show you what a microservice is and how it differs from other types of services.\nGenerally, a service is a separately deployed unit of software that performs some business or infrastructure process. For example, a single Monitor All Vital Signs service in MonitorMe might perform a lot of functions, including monitoring the patient’s heart rate, blood pressure, temperature, and so on. This service does quite a bit, but we still call it a service.\nThe prefix micro- in microservice refers not to physical size, but to what the service does. For example, a Monitor Heart Rate service is single-purpose and does one thing really well—it monitors a heart rate. That’s the idea behind microservices. By contrast, the larger Monitor All Vital Signs service performs many vital sign monitoring functions.\nA microservice is a single-purpose, separately deployed unit of software that does one thing really well.\nExercise\nWe’re having trouble determining what single-purpose means. Can you help us by checking off all the functions below that you would consider single-purpose and therefore possible microservices?\nAdd a movie to your personal “to watch” list\nPay for an order using your credit card\nGenerate sales-forecasting and financial-performance reports\nSubmit and process a loan application to get that new car you’ve always wanted\nDetermining the shipping cost for an online order\nSolution in “Exercise Solution”\nIt’s my data, not yours\nAnother feature that makes microservices special is that they own their own data. In other words, each microservice is the only one that can directly access its data.\nWhy? The primary reason is to manage change control. Say you have 50 microservices, all sharing the same data. If one microservice changes the structure of its data, which the other 49 microservices are also accessing, all of those other services will need to change at the same time. (Is your head exploding yet?)\nPhysically associating a microservice with its data is known as creating a physical bounded context. Physical bounded contexts help manage change and coupling. If other microservices need access to data they don’t own, they must ask the owning service for it.\nNote\nA physical bounded context includes the microservice and all of its data.\nIn the example above, the Monitor Heart Rate microservice is asking for the data rather than directly accessing the data. This way, even if the Sleep Status data structures change, the Monitor Heart Rate microservice doesn’t have to. This is the whole idea behind physical bounded contexts.\nSharpen your pencil\nWe created the following services for an ecommerce site, but we need your help in figuring out the data ownership and bounded contexts. Can you associate the database tables below with the corresponding microservices that should own the data?\nSolution in “Sharpen your pencil Solution”\nHow micro is “micro”?\nFiguring out how big or small a microservice should be is hard. By now you know that a microservice is a single-purposeservice that’s separately deployed. But how do you determine the scope of that single purpose?\nAs an example, let’s take a look at the MonitorMe functionality for blood pressure. Monitoring a vital sign involves capturing the input from the medical device attached to the patient, recording the input, analyzing the measurements, and alerting a nurse or doctor if something is wrong. We can model this functionality in one of three ways:\n• Option 1: Create a single monitoring microservice that performs all monitoring and alerting functions.\n• Option 2: Create two separate microservices—one that captures and records vital signs data, and one that analyzes the data and alerts staff if necessary.\n• Option 3: Create four separate microservices, each one performing a specific blood pressure monitoring function.\nRelax\nYou don’t have to choose yet. At this point, we’re only showing you the different options you can choose from to create a microservice. Keep reading to find out how to make the right choice for your situation.\nNo, granularity is not a guessing game.","metadata":{"id":2432000361731114,"pageNumber":17,"bookId":1}},{"text":"Granularity—the scope of what a microservice does—is an important factor when identifying microservices. Microservices that are too fine-grained tend to communicate more with each other to complete business functions, leading to high levels of coupling, poor performance, and overall reliability issues. This is commonly referred to as the Grains of Sand antipattern, in which services are so small that they start to resemble sand on a beach. However, microservices that are too coarse-grained are harder and more expensive to maintain, test, and scale (which defeats the whole purpose of using microservices).\nSo how do you determine the most appropriate level of granularity for a microservice? By applying forces called granularity disintegrators and granularity integrators. Granularity disintegrators are forces that tell you to make your service smaller (meaning it’s doing less work), whereas granularity integrators are forces that tell you to make the service bigger (meaning it’s doing more work). Let’s see how these forces work.\nGranularity disintegrators\nGranularity disintegrators are forces that help you decide whether you should break a service apart into several smaller ones. To show you how these forces can influence your decision to break a service apart, we’ll take a look at MonitorMe’s Monitor Basic Vital Signs functionality.\nThe three basic vital signs are blood pressure, temperature, and heart rate. Since they’re all related, we could put them all in the same microservice or create separate microservices, one for each basic vital sign.\nLet’s analyze each of these forces to see how it might help you decide whether to break the monitoring functionality into separate microservices.\nWhy should you make microservices smaller?\nCohesion\nA single-purpose microservice has functionality that is highly cohesive—meaning all the things it does are closely related to each other. If the functionalities of a microservice lack cohesion, then it might be a good idea to break that microservice apart.\nFault tolerance and availability\nDo certain functions in a microservice frequently produce fatal errors? In larger microservices, all functionalities become unavailable when a part of the microservice fails. However, if the faulty functionality is in its own separate microservice, it won’t affect other functions.\nAccess control\nThe larger the service, the more difficult it is to control access to sensitive information. For example, a Patient Profile microservice containing functionality to access medical history might inadvertently allow unauthorized staff to access this sensitive (and protected) information.\nMoving sensitive functionalities (like access to medical history) into their own microservices isolates them, making it easier to control access to that information.\nCode volatility\nNote\nThis is also referred to as “volatility-based decomposition.”\nDoes one part of the microservice change faster than others? Constant changes to one part of a large microservice mean you have to test the entire microservice, including functionalities you didn’t change. That’s a lot of extra work.\nMoving a frequently changing function into its own separate microservice isolates those changes from other functions, making it much easier to maintain and test functionality.\nScalability and throughput\nDo some parts of the microservice need more scalability than others? If so, breaking the service apart allows better control over which portions need to scale and which do not.\nFor example, suppose the heart rate monitoring function accepts sensor readings every second, but the temperature monitoring function accepts sensor readings once every 5 minutes. Separating these monitoring functions into distinct services allows each one to accommodate a different throughput rate.\nNote\nSmaller microservices start up much faster than larger ones, making much-needed functionality available to the user sooner.\nGranularity integrators\nGranularity integrators work in the opposite direction from disintegrators—they help you decide when to make services bigger and combine their functionalities. We’ll use the same Monitor Basic Vital Signs microservice we broke apart earlier to illustrate why you might want to consider combining separate microservices into one larger microservice.\nLet’s analyze each of these forces to see how they might help you determine whether you should put all this monitoring functionality into a single larger microservice.\nWhy should you make microservices bigger?\nDatabase transactions\nWhen requests involve multiple microservices, you can’t perform a single database commit or rollback for all updates. Since each microservice update is in its own separate transaction, it must instead be committed or rolled back separately.\nIf data consistency and integrity are more important than any of the disintegrator forces, then it makes sense to combine the functionality into a single microservice so that operations take place in a single database transaction.\nData dependencies\nNote\nData dependencies are one of the most common integration drivers.\nWhen you break a microservice apart, you also have to break its data apart. However, if the data is highly coupled, it will be very difficult to break it apart and form new physical bounded contexts.\nAn example of data coupling is when one database table refers to the key of another database table (known as a foreign key constraint). Another example of data coupling is when an entity (like customer information) is spread across multiple tables.\nIf your data is highly coupled and functions in the microservice need to share that data, it makes sense to keep the microservice large and combine the functions.\nWorkflow and choreography\nIf a single business request requires separate microservices to communicate with each other, that’s coupling. Too much coupling between microservices can have many negative effects on the system.\nFor example, performance is affected by network, security, and data latency. Scalability is affected because each microservice in the call chain must scale as the other microservices scale (something that is hard to coordinate). Fault tolerance is affected because if one of the microservices in the chain becomes unresponsive or unavailable, the request cannot be processed.\nIf your workflow involves a lot of coordination between your microservices and these characteristics are important to you, consider combining them.\nIt’s all about balance\nDetermining the appropriate level of granularity for a microservice isn’t easy. You have to balance the trade-offs associated with each granularity disintegrator and integrator, and determine which trade-offs are more important. This usually involves collaborating with your product owner or business stakeholder, particularly if the trade-offs are significant.\nMake it Stick\nHow small should a microservice be?\nUse this tip and you will see.\nKeep them coarse-grained when you begin,\nThen move to fine-grained for the win!\nExercise\nNow it’s your turn to apply granularity disintegrators and granularity integrators to decide whether to implement the Monitor Basic Vital Signs functionality (which covers blood pressure, temperature, and heart rate) as a single microservice or three separate services. Here is some additional information:\n* A patient’s heart rate and blood pressure are the two most critical basic vital signs to monitor. If something should go wrong with temperature monitoring, heart rate and blood pressure monitoring must continue to work.\n* All three basic vital signs share an alert functionality to notify medical professionals if something goes wrong.\n* The heart rate monitoring functionality accepts sensor readings once a second, whereas the temperature and blood pressure monitoring functions only accept sensor readings once every 5 minutes.\n* Each basic vital sign’s data is recorded and stored separately, as simple JSON name/value pairs in a single document database. For example, the heart rate readings are stored as follows:\nWhich of the two options would you choose, and why? ____________________\n___________________________________________________________________","metadata":{"id":762347211324536,"pageNumber":17,"bookId":1}},{"text":"Chapter 11. Event-Driven Architecture: Asynchronous Adventures\nWhat if your architecture could do lots of things at the same time? As businesses grow and become more successful, they need to be able to handle more and more users, without slowing down or crashing systems. In this chapter, you’ll learn how to design high-performance systems that can scale as a business grows. Get ready for event-driven architecture, a highly popular distributed architectural style. It’s very fast, highly scalable, and easy to extend—but it’s also quite complex. You’ll be learning about lots of new concepts in this chapter, including things like events, messages, and asynchronous communication, so you can create an architecture that can do many things at once. Fasten your seatbelt, and let’s go on an asynchronous adventure through event-driven architecture.\nToo slow\nImagine going to your favorite diner to order their famous grilled cheese sandwich, crispy fries, and a chocolate milkshake. Sounds easy, right? But what if the person taking your order had to make all of those things one at a time, without any help? Not only would everything take longer, but the diner wouldn’t be able to serve as many customers. Let’s visualize that workflow:\nThis is no way to run a diner! Let’s see if we can make things go a little faster so they can serve more customers.\nBrain Power\nPretend you are a customer of this diner. How would you suggest they speed things up?\nNote\nWrite your ideas here.\nSpeeding things up\nIf the diner hires three more workers (one to make the sandwiches, one to cook the french fries, and one to make milkshakes) and they prepare all parts of the meal at once, completing orders will take half as long. That effectively doubles the number of customers the diner can serve during the lunch hour.\nDoing all three activities at the same time significantly reduces customers’ wait time (we’ll call that responsiveness). Because meals can be made faster, the server taking orders can now handle more customers (we’ll call that scalability).\nNote\nNote: we’ll be referring to event-driven architecture as EDA going forward, because we’re cool like that (and, thankfully, we don’t get paid by the word).\nThis is the fundamental concept behind event-driven architecture (EDA)—breaking up processing into separate services, with each of those services performing its function at the same time by responding to an event (something that just happened). In EDA, services communicate asynchronously through an event channel, meaning they don’t wait for responses from other services to complete their work.\nNote\nDon’t worry—we’ll cover all of these terms.\nWe know this is a lot to take in at once, so we’ll take it step by step. But before we jump in, let us introduce you to Der Nile, a large German online-ordering company that is having growing pains and needs your help.\nDer Nile flows faster than ever\nDer Nile is Germany’s largest online retailer, selling everything from diapers to hair-growth supplements.\nBusiness is booming—so much, as a matter of fact, that the company’s online ordering system is stressed to the breaking point. Der Nile’s customers demand fast systems and quick order fulfillment, and the current system simply can’t handle the volume of orders coming in. Processing orders takes too long, and fulfillment times are increasing.\nDer Nile would like to create a new ordering system from scratch to handle this growth—and needs your help in designing it.\nHere is the basic flow of the legacy online-ordering system currently in place:\nExercise\nAs the architect, how can you modify the current workflow (shown on the previous page) to speed things up a bit? Draw your ideas for a new workflow in the space below. Hint: What can you do at the same time?\nSolution in “Exercise Solution”\nWhat is an event?\nBack in the late 1950s, a journalist asked Prime Minister Harold Macmillan of the United Kingdom what troubled him the most. “Events, my dear boy, events,” was his famous reply. Events may have troubled Harold Macmillan, but they can be a lot of help to us in solving complex business problems.\nAn event is something that happens, especially something of importance. Things like the World Cup, musical concerts, big promotions at work, weddings, and birthday celebrations are all important events.\nNote\nPublishing this book was an important event for the authors.\nIn software systems, certain user actions trigger events—things that happen, like placing a bid for an item up for auction, filing an insurance claim, or making a purchase.\nEvents are a way for a service to let the rest of the system know that something important has just happened. In EDA, events are the means of passing information to other services.\nNote\nFriendly reminder: EDA is event-driven architecture.\nAn event usually contains data, like all the details of an online order. On occasion, it might only have key information (like the order ID). In the latter case, services that must do something when they receive the event will have go to a data store to get additional information about it.\nNote\nThe data inside an event is referred to as its payload.\nNo, an event is not the same thing as a message. Although they both deliver information to other parts of the system, there are some important differences between them.\nAn event is used to broadcast some action that a service just performed to other services in the system. For example, a service might tell the rest of the system: A customer just placed an order. A service sending an event never waits for a response. The service generally has no knowledge about what other services (if any) are listening for that event, or what they’ll do with that information if they respond to it.\nNote\nThis is often referred to as “fire-and-forget.”\nNote\nMore on this soon.\nA message, on the other hand, is a command, such as Apply the payment for this order, or a request, like Give me shipping options for this customer. Because messages are only meant to reach one other service, the other services in the system are unaware of the message. Services sometimes stop and wait for a response (for instance, if they are sending a request for information). Other times, the service might just issue a command and trust that the receiving service will do its job.\nTurn the page to see more differences between an event and a message.\nEvents versus messages\nHere are two really important differences between events and messages:\n1. Events are broadcast to other services using topics, whereas messages are sent to a single service using queues.\n2. Events always broadcast something that has already happened, whereas messages request something that needs to be done.\nSharpen your pencil\nIt’s time to test your knowledge about events and messages. For each of the quotes below, mark whether it is more likely an event or a message, and indicate why.\nSolution in “Sharpen your pencil Solution”\nInitiating and derived events\nEvents that originate from a customer or end user are called initiating events. These are a special type of event that kicks off a business process.\nOnce a service responds to an initiating event, it might in turn broadcast what it did to the rest of the system, within the scope of that initiating event. These events are called derived events because they are internal events generated in response to the initiating event.\nDid you notice that the Payment service generates two different derived events? This is typical in EDA. Anything a service generates or causes to happen can be a derived event.\nExercise\nBased on the Credit Card Charged initiating event and the corresponding processing below, can you identify what the derived events should be for each service? Think of as many possible outcomes as you can.\nSolution in “Exercise Solution”\nIs anyone listening?\nWhen you post something on social media, you often get a reaction—someone liking or commenting on your post. But how many times have you posted something only to get no reaction? Maybe you wondered: Did anyone see my post? Did anyone care?\nIn EDA, any action a service performs should trigger a derived event. However, there is a chance that no one cares about certain events. So why publish those events? Because this provides architectural extensibility—the ability to extend the system to add new functionality.\nNote\nExtensibility is one of the architectural characteristics you learned about in Chapter 2.\nLet’s say customers in the Der Nile online ordering system get notified when an order is shipped and also when it has been delivered. The Email Notification service handles this by sending the customer an email. That event in turn triggers a Customer Notified derived event.\nNow let’s suppose Der Nile wants to do some analytics to learn what times of the day the system sends the most customer notification emails. Since the Customer Notified derived event is already being published, you can simply create a new Notification Analytics service and tell it to listen for that event. You don’t need to modify any other parts of the system.\nAsynchronous communication\nEvent-driven architecture is fast because it uses mostly asynchronous (or “async” for short) communication.","metadata":{"id":463028932051086,"pageNumber":18,"bookId":1}},{"text":"You’re probably most familiar with communication styles such as REST or HTTP, particularly when you need to call an API or another service. These are forms of synchronous communication. With synchronous (or “sync”) communication, when a service sends information, it must sit and wait for a response from the receiving service before doing anything else (even if it’s just acknowledging receipt of the information). This slows systems down and makes them less scalable. It’s like calling a friend—you have to wait for your phone to make a connection to your friend’s phone, let it ring, and wait for your friend to answer before you can talk.\nAsynchronous communication is a fancy way of saying that services don’t wait for a response or acknowledgment from other services when sending them information. This creates systems that are highly decoupled and very fast. It’s one of the unique features of event-driven architecture. It’s like sending your friend a text—you can do other things while you wait for their response.\nFireside Chats\nTonight’s talk: Asynchronous and synchronous communication debate: Who’smore useful?","metadata":{"id":6403950860285936,"pageNumber":18,"bookId":1}},{"text":"Asynchronous CommunicationSynchronous CommunicationWell, it’s about time you showed up.Sorry I’m late. I can’t seem to multitask, so everything I do takes such a long time.Yeah, I’ve noticed. You’re as slow as a herd of snails traveling through peanut butter.Now, wait just one minute!Wait? You want me to wait? That’s your whole problem—you’re always waiting around for answers. No one has to wait when I’m around. And that makes me fast—really fast.That may be so, but your problem is that you never know what’s going on. You ask others to do things, but you never find out whether those things actually got done or not.I trust others to get the job done, unlike you. You need verification for everything, all the time.Yeah, right. Tell me: when an error occurs downstream, how do you deal with it?I don’t. I can’t be responsible for everyone, you know. I let others deal with their own issues.And what if you need information from someone else before you can finish your work? What do you do then?Oh, I’m sorry—did you say something? I wasn’t listening.That’s exactly my point! You never listen to anyone else. I may be slow, but at least I pay attention to what’s going on and communicate with others.Sorry—I wasn’t paying attention. What was that?Sigh...\nFire-and-forget\nAsynchronous communication is one of the foundations of event-driven architecture. When a service broadcasts information to other services, it doesn’t wait for a response, nor does it care whether the services are available or not. This is known as fire-and-forget communication—the event is sent (that’s the fire part), and the service moves on to do other things (that’s the forget part). Architects usually use a dotted line to represent async communication between services.\nSynchronous communication, on the other hand, means that the sending service must stop and wait for a response from the service it’s calling before continuing its work. This means that the service being called must be available to respond, or an error occurs. Architects usually represent synchronous communication using a solid line.\nEvent-driven architecture relies on asynchronous communication when sending and receiving events.\nSharpen your pencil\nFor each of these tasks, would you use asynchronous or synchronous communication?\nGive me the shipping options for this order.\nAsynchronous  Synchronous","metadata":{"id":8967283245059850,"pageNumber":18,"bookId":1}},{"text":"Chapter 12. Do It Yourself: Testing Your Knowledge\nReady to test your skills in creating a distributed architecture? In this chapter, you’re the software architect. You’ll be determining architectural characteristics, building a logical architecture, making architectural decisions, and deciding whether to use microservices or event-driven architecture. The exercises in this chapter will give you an end-to-end view of what a software architect does and show you how much you’ve learned. Get ready to create an architecture for a student standardized test–taking system called Make the Grade. Good luck—we hope you get an A on your architecture!\nWelcome to Make the Grade\nCongratulations—you’ve just been hired by Dataville Public Schools to build a new system for standardized testing. All students in a specific grade level will take the same test to determine how well students, teachers, and the schools are doing.\nMake the Grade requirements document\n□ Students will take a web-based test in their homeroom, proctored by their homeroom teacher. Because tests are timed (2 hours), the system must present questions as fast as possible.\n□ Each student is presented with a multiple-choice question on the screen. Once they answer it, the system captures the answer and delivers the next question. Students may skip questions, but may not go back to prior ones—only moving forward is allowed.\n□ Once captured, each answer is automatically graded (correct or incorrect) and the results are stored in a central relational database, which has only 300 database connections available.\n□ Anywhere from 20 to 200,000 students could be taking tests at the exact same time.\n□ The Dataville Public Schools testing administrator is responsible for scheduling tests and for maintaining tests, answer keys, and the list of students (used when students sign in to the system).\n□ Rita, the head of Dataville Public Schools, uses the system to generate student reports, teacher evaluations, and school reports after all testing is complete.\n□ The proctor (teacher) uses the system to find out when tests are scheduled.\n“It’s imperative that no student answers are lost, even if the system crashes.”\nNote\nRita has some other important requirements for the system.\n“We need this system in place for the start of the next term, which is in six months.”\n“You absolutely have to make sure that students cannot hack into the system and steal the test answer keys.”\n“Testing doesn’t occur every day. Some days there are only 20 students taking a test; other days there could be 200,000 at the exact same time. Sometimes tests might be staggered throughout the day.”\nStudent testing workflow\nNow that you have the requirements, let’s take a look at the primary workflow of the Make the Grade system so you can better understand those requirements.\nSharpen your pencil\nGiven the requirements for Make the Grade, list some challenges that you will need to address when creating an architectural solution.\nSolution in “Sharpen your pencil Solution”\nPlanning the architecture\nWe have to create an architecture first.\nAs you’ve learned, architecture is a critical part of any software system. Without it, the system will likely fail to achieve any of its goals.\nBefore you start developing code, you have to create an architecture. This means going back to what you learned in Chapter 1 about the four dimensions of software architecture.\nDon’t worry—we’ll get the system done. But first, it’s important to know what we’re building.\nThe architects’ roadmap\nLet’s get the Make the Grade architecture started. You’ll use the steps you’ve learned to translate requirements into an architecture.\nThis diagram will serve as your roadmap as you make your way through each of the exercises, so get used to seeing it. The next few pages will walk you through these steps.\nGood luck on your journey—Dataville Public Schools is counting on you.\nStep 1: Identify architectural characteristics\nIn this first step, you’ll use the requirements below to identify the architectural characteristics that are critical for the success of the Make the Grade student test-taking system. On the next page, identify up toseven driving characteristics. Then select the three you think are the most critical for the system to be successful.\nRemember, implicitcharacteristics are those that are implied in virtually every software architecture. (Would you ever not worry about security?) If you see one you feel is critical for the success of the system, move it over to the driving characteristics area.\n“It’s imperative that no student answers are lost, even if the system crashes.”\n“We need this system in place for the start of the next term, which is in six months.”\n“You absolutely have to make sure that students cannot hack into the system and steal the test answer keys.”\n“Testing doesn’t occur every day. Some days there are only 20 students taking a test; other days there could be 200,000 at the exact same time. Sometimes tests might be staggered throughout the day.”\nNote\nWe copied the requirements here to make it easier for you to use them to identify the driving architectural characteristics.\nMake the Grade requirements document\n□ Students will take a web-based test in their homeroom, proctored by their homeroom teacher. Because tests are timed (2 hours), the system must present questions as fast as possible.\n□ Each student is presented with a multiple-choice question on the screen. Once they answer it, the system captures the answer and delivers the next question. Students may skip questions, but may not go back to prior ones—only moving forward is allowed.\n□ Once captured, each answer is automatically graded (correct or incorrect) and the results are stored in a central relational database, which has only 300 database connections available.\n□ Anywhere from 20 to 200,000 students could be taking tests at the exact same time.\n□ The Dataville Public Schools testing administrator is responsible for scheduling tests and for maintaining tests, answer keys, and the list of students (used when students sign in to the system).\n□ Rita, the head of Dataville Public Schools, uses the system to generate student reports, teacher evaluations, and school reports after all testing is complete.\n□ The proctor (teacher) uses the system to find out when tests are scheduled.\nExercise\nIn Chapter 2, we showed you how to use this template to limit the number of architectural characteristics. Flip back to “Sharpen your pencil” if you need a refresher on how to use it.\nSolution in “Exercise Solution”\nStep 2: Identify logical components\nGood job! Now that you’ve identified the critical architectural characteristics for Make the Grade, it’s time to apply what you learned in Chapter 4 to create logical components.\nUsing the requirements and primary workflow on the previous pages, use the actor/action approach to identify the users and their actions. Then identify as many logical components as you can on the next page.\nHere’s some additional information you might find useful for this exercise:\nStudents sign in to the system using their student ID. The system will verify the date, student ID, test, and teacher when a student signs in.\nRita, the head of Dataville Public Schools, will wait at least one day after testing has finished before generating reports.\nNote\nThis gives the system time to record all the answers in the database.\nThe classroom teacher acts as the proctor for the test, watching the students to make sure they don’t cheat and providing assistance. The teachers use the system to find out when a test is scheduled for their class.\nWhen a test is created, the questions and answers are sent to the test administrator, who enters them into the system. The same goes for any modifications to existing tests.\nSharpen your pencil\nUsing the actor/action approach, identify the actions for each of these actors.\nSolution in “Sharpen your pencil Solution”\nExercise\nUsing the space below, draw your logical components and their interactions.\nSolution in “Exercise Solution”\nStep 3: Choose an architectural style","metadata":{"id":1483195215654470,"pageNumber":19,"bookId":1}},{"text":"We know that this system will have separate parts that require different architectural characteristics, so it makes sense to use a distributed architecture, such as microservices or event-driven architecture. Leveraging what you’ve learned about both styles, use the next page to analyze their pros and cons with respect to the Make the Grade test-taking system. You will also need to go back to the requirements, your logical architecture, and the star rating charts for each architectural style (we’ve added those for you below). Choose an architectural style based on your analysis.\nHere are some considerations that might help you decide which architectural style would be better suited for Make the Grade:\nGo back to your logical architecture diagram and count the actions you identified that you would consider events. If you find there aren’t many events, event-driven architecture might not be the right choice.\nThink about the nature of the data in the system. If most of the data is shared, then microservices probably isn’t the right choice.\nThink about how many actions you identified are synchronous and how many are asynchronous. If you have a lot of synchronous actions, event-driven architecture might not be a good fit.\nExercise\nOutline the pros and cons of each architectural style to help you make a choice about which one might be most appropriate for Make the Grade.\nSolution in “Exercise Solution”\nStep 4: Document your decision\nGood work: you’ve just chosen which architectural style you are going to use for Make the Grade. Now’s your chance to explain why you made the choice you did and document your architectural decision.\nAs you learned in Chapter 3, an architectural decision record, or ADR, is an effective way to document your architectural decisions. Use the ADR on the next page to document your architectural style decision. Assume that this is your 11th architectural decision.\nNote\nRevisit Chapter 3 if you need a refresher on architectural decision records.\nEvery architectural decision has consequences.\nMaybe it’s cost, or maybe it’s sacrificing a little bit of performance to have better security. Regardless, every architectural decision has consequences.\nThink about the trade-off analysis you just did. Each one of those trade-offs implies a consequence—something you were willing to give up (or accept) to get something better. The Consequences section of an ADR is a great place to document your trade-off analysis and the corresponding consequences of your decision.\nIf you can’t find any consequences in your architectural decision, keep looking, because they’re there.\nExercise\nArchitectural Decision Record\nSolution in “Exercise Solution”\nStep 5: Diagram your architecture\nNow it’s time to combine all four dimensions of software architecture and show us your vision of the Make the Grade architecture. In this last exercise, you’ll diagram your architecture on the following page using the key on this page.\nThere’s not a lot of room to diagram your architecture, but that’s intentional. While a lot of detail can go into architecture diagrams, what we’re asking you to do is sketch out a high-level physical view showing the user interfaces, services, databases, communication type (sync or async), and how all of these architectural artifacts connect to each other.\nPhysical Architecture Key","metadata":{"id":6409538343112678,"pageNumber":19,"bookId":1}},{"text":"Draw a computer screen to represent the user interface, and indicate which type(s) of users are interacting with it. For example, if you have separate user interfaces for the test administrator and the education department (for generating reports), show two computer screens. If they share a single user interface, show one computer screen with multiple actors interacting with it.Draw a cylinder to represent each physical database in your solution. Your label should indicate what type of data it stores (for example, Student Answers). Show which services write to the database and which services are read-only by drawing arrows to indicate the data flow to and from the services. (Writes assume reads.)Draw dotted lines to represent asynchronous communication (such as using a queue, topic, or stream), and solid lines to represent synchronous (blocking) communication between services and user interfaces.If your architecture uses messages or events, draw a box or an envelope to indicate the data being passed (for example, Student Answer) or the event being triggered (for example, Answer Submitted).\nUse a box to represent a service. Be sure to include the components that the services implement, which should match the logical components you identified in the prior exercise. Also, indicate which user interfaces access the service and which other services communicate with the service. Last, give your service a meaningful and descriptive name.\nNote\nFeel free to annotate your diagram to clarify points or describe things.\nExercise\nUse this space and refer to the key on the previous page to sketch your physical architecture for Make the Grade.\nSolutions in “Exercise Solution”\nThere are no right (or wrong) answers!\nCongratulations—you’ve just created an architecture!\nWhat we’re about to show you are the exercise “solutions.” We’ve used quotes there because our answers are not the only ones possible. You see, there are no right or wrong answers in software architecture: it’s all about analyzing trade-offs and being able to justify your decisions.\nCompare your answers with the ones we’re about to show you. See how your solutions differ and think about what you might have done differently, or confirm that you made what seems to you to be the most appropriate choice. We’ll show you our Make the Grade architectures for microservices and event-driven architecture, since both these styles are viable options.\nSoftware architecture is always a learning process. Each new problem brings a whole new set of conditions, constraints, and business and technical concerns. There is no one-size-fits-all architecture—it’s up to you, the architect, to come up with the most appropriate architecture for your situation.\nBullet Points\nWhen analyzing requirements for a business problem, always gather additional information from the business stakeholders or project sponsor.\nWhile there’s no “checklist” for creating an architecture, the four dimensions of software architecture (introduced in Chapter 1) provide a good roadmap.\nIdentifying driving architectural characteristics requires you to analyze the business requirements and technical constraints.\nImplicit architectural characteristics become driving characteristics if they are critical or important to the success of the system.\nMake sure you can tie each driving characteristic back to some sort of requirement or business need.\nWhen identifying logical components and creating a corresponding logical architecture, try to avoid adding physical details such as services, databases, queues, and user interfaces—those artifacts go into the physical architecture.\nWhen choosing an architectural style, make sure you take into account the characteristics of the architectural style, the problem domain, and the driving architectural characteristics you identified.\nHybrid architectures (those combining two or more different architectural styles) are very common. Just be sure to verify that the hybrid architecture still addresses your critical architectural characteristics.\nArchitectural decision records (ADRs) are a great way to document your choices. They communicate the reasons for your architectural decisions as well as your trade-off analyses.\nWhen diagramming your physical architecture, be sure to include all the components you identified in your logical architecture.\nRemember that there are no right or wrong answers in software architecture. As long as you can provide a reasonable justification for your architectural decisions, you are on the right track for success.\nYou are well on your way to thinking architecturally!\nWe are going to assume that you actually read this book all the way through and didn’t just jump to the end. If so, we congratulate you for it! Job well done.\nCongratulations!\nYou’ve made it to the end.\nThough there is still the appendix.\nAnd the index.\nAnd there’s a website...\nYou aren’t getting away that easily!\n(Go ahead, you can admit it—you just can’t get enough of software architecture, can you?)\nFrom “Sharpen your pencil”\nSharpen your pencil Solution\nGiven the requirements for Make the Grade, list some challenges that you will need to address when creating an architectural solution.\nStoring up to 200,000 simultaneous student answers in a relational database that has only 300 connections.\nDelivering the next question to each student as fast as possible while making sure student answers are not lost.\nComing up with a viable solution that can be delivered within a six-month time frame.\nMaking the system elastic to reduce cost and resource use when testing is not happening or there are only a few students taking a test.\nFrom “Sharpen your pencil”\nSharpen your pencil Solution\nUsing the actor/action approach, identify the actions for each of these actors.\nFrom “Exercise”\nExercise Solution\nIn Chapter 2, we showed you how to use this template to limit the number of architectural characteristics. Flip back to “Sharpen your pencil” if you need a refresher on how to use it.\nFrom “Exercise”\nExercise Solution\nUsing the space below, draw your logical components and their interactions.\nFrom “Exercise”\nExercise Solution\nOutline the pros and cons of each architectural style to help you make a choice about which one might be most appropriate for Make the Grade.\nFrom “Exercise”\nExercise Solution\nArchitectural Decision Record\nTitle:011: Use of the microservices architectural style for the Make the Grade system\nStatus:Proposed\nContext:\nMake the Grade is a test-taking system that needs high levels of responsiveness, fault tolerance, elasticity, and data integrity. Because there are separate parts of the system (admin, reporting, grading, and test taking) that require different architectural characteristics, a distributed architecture is appropriate. The two choices are microservices and event-driven architecture.\nDecision:\nWe will use the microservices architectural style.\nMicroservices provides the necessary fault tolerance, elasticity, and scalability.\nPerformance deficiencies and high responsiveness needs are addressed through minimal inter-service communication, caching to minimize data retrieval needs (student information, test questions, and test answer keys), and asynchronous communication for automatic grading and storing students’ answers.\nData integrity (preventing data loss) is addressed by using persistent queues between the Capture Answer and Automatic Grading components, along with client acknowledgment mode in the Automatic Grading component, to make sure that each student answer stays on the queue until it is persistent in the Student Answer Database.\nThe test administration functionality will be a single microservice that combines the test scheduling, test maintenance, and student maintenance functionalities. Reporting will be a single microservice as well.\nConsequences:\nTechnically partitioned teams will need to be reorganized into cross-functional teams and will work in parallel in order to finish the system in six months.\nWe will need to use in-memory caching to address the system’s performance, elasticity, and data sharing needs.\nWe will need additional infrastructure to support microservices: specifically, a service orchestrator like Kubernetes and a more effective CI/CD deployment pipeline.\nFrom “Exercise”\nExercise Solution\nUse this space and refer to the key on the “Exercise” to sketch your physical architecture for Make the Grade.\nFrom “Exercise”\nExercise Solution\nUse this space and refer to the key in “Exercise” to sketch your physical architecture for Make the Grade.","metadata":{"id":2380299738404653,"pageNumber":19,"bookId":1}},{"text":"Appendix A. Leftovers: The Top Six Topics We Didn’t Cover\nThere’s a lot more to be said about software architecture. We promise, you’re done with this book. But reading this book is just the first step in your journey to thinking architecturally, and we couldn’t in good conscience let you go without a little more preparation. So, we’ve gathered a few additional juicy bits into this appendix. Each of the topics that follow deserves as much attention as the other topics we’ve covered. However, our goal here is just to give you a high-level idea of what they’re all about. And yes, this really is the end of the book. Except for the index, of course—it’s a real page-turner!\n#1 The coding architect\nYes! We firmly believe that software architects should still write source code. Not only does it help you maintain your technical skills, but it also shows you how your architectural decisions play out in real life.\nHowever, it’s not always easy to balance hands-on coding with software architecture. As you’ve seen, there’s a lot to software architecture. It will take up most (if not all) of your time.\nDon’t worry though—we’ll share some tips and techniques for writing software while being an effective software architect.\nDon’t become a bottleneck\nBe careful not to take ownership of code that is on the product’s critical path. Leave things like the underlying framework code and really complex or crucial parts of the system to your development team. That way, if you get pulled away by architecture-related stuff, you won’t hold up your team.\nWrite proof-of-concept code\nHaving trouble making an architectural decision? How about writing some code to demonstrate each option? Writing proof-of-concept code is a great way to better understand the implications of your architectural decisions while maintaining your technical expertise. A word of advice, however—unless you know for sure you’re going to throw it away, take the time to write the bestproduction-ready code you can. It could very well end up in production.\nPay back some technical debt\nAlmost every development team accumulates technical debt (needed changes that are deferred to a later time). Help your team out by addressing some of it. They’ll appreciate it, and if you get called away, it won’t hold them up.\nGet involved during production outages\nWhen an outage strikes, step in to assist, if you can. Help your development team identify the root cause and make the code changes needed to get the system back up and running. This also gives you an opportunity to see the detailed implementation of your architecture.\nDo lots of code reviews\nNo one likes doing code reviews. But it’s a good way to stay involved, and it helps you make sure the source code stays aligned with your architectural decisions.\nNote\nAnd here are some ways to stay continuously involved.\n#2 Expectations for architects\nWe’ve talked a lot in this book about architecture, but not so much about the role of a software architect. While the specifics will vary from company to company, here are some things any software architect will be expected to do, regardless of title.\nMake architectural decisions\nAn architect is expected to define architectural decisions and design principles and use them to guide technology decisions within the team, the department, and/or across the enterprise.\nKeep current with the latest trends\nTo remain relevant (and retain a job!), developers must keep up to date on technical and industry trends. For architects, it’s even more critical to keep current. Doing so helps you prepare for the future and make correct decisions.\nContinually analyze the architecture\nAn architect is expected to always be analyzing the current architecture and technology environment and making recommendations for solutions and improvements. This continuous analysis is a way of checking for architectural vitality—that is, how viable the architecture still is, given constant changes in business and technology.\nEnsure compliance with the architecture\nArchitects should continually verify that the development teams are following the approved architectural decisions and design principles. This is called architectural governance. Regardless of how good the architecture is, the system won’t work unless everyone adheres to your architectural decisions.\nCultivate diverse exposures and experiences\nNote\nAs an architect, it’s important to know a little about a lot of things.\nNote\nMore about this in a few!\nAn architect is expected to be familiar with technologies, frameworks, platforms, and environments of all sorts. This doesn’t mean you need to be an expert in all of them, but you should have some knowledge of what’s out there.\nPossess exceptional interpersonal skills\nHaving exceptional leadership and interpersonal skills is important. Typically, technologists, developers, and architects prefer to solve technical problems, not people problems. But an architect is expected to provide technical guidance to the team and lead them through implementing the architecture. Leadership skills are at least half of what it takes to become an effective software architect, regardless of your role or title.\nNote\nThe American computer scientist Gerald Weinburg is famous for saying, “No matter how it looks at first, it’s always a people problem” (https://oreil.ly/wyDB8).\nKnow the business domain\nEffective software architects understand the business domain of a problem space. Without knowing what the business does and how, it’s difficult to understand the problem, goals, and requirements well enough to design an effective architecture.\nUnderstand and navigate office politics\nMany people will challenge your decisions. Product owners, project managers, and business stakeholders may see a solution as too costly or not fast enough to implement. Developers and other architects may challenge your approach if they feel theirs is better. You’ll be expected to make a case for what you propose. You must navigate office politics and apply basic negotiation skills to get your decisions approved.\n#3 The soft skills of architecture\nLike we said on the last page, at least half of being a software architect is having great people skills. You’ll need them to lead and guide your development team, gain the respect of your peers, and get everyone to agree to a common vision and direction.\nWe call these “soft” skills, but they are hard skills to acquire. Using them effectively requires years of practice and trial and error. Here are some soft skill techniques to help you become a more effective software architect.\nDemonstrate, don’t discuss\nRather than arguing a point with another architect or development team, demonstrate it. Every environment is different, which is why simply Googling never yields correct answers. When you compare the options in a production-like environment and show the results, there’s little room for argument.\nNote\nSay it with us: “Demonstration defeats discussion.”\nKnow when to fight and when to let go\nChoosing your battles wisely is the mark of a great leader and makes you a reasonable person to work with. It gains you respect. Fight to the death for something that’s crucial to making the architecture work, but let things go if they’re not so important.\nNote\nChoosing your battles is good advice, even outside of software architecture. You’re welcome.\nFocus on business value\nWhen talking with business stakeholders, describe your decision or solution in terms of its business value. Business stakeholders aren’t interested in things like fault tolerance or testability—they care about things like time to market, regulatory compliance, and mergers and acquisitions. Translate your technical concerns into business ones and you’ll be speaking their language.\nInvolve developers in your architectural decisions\nWe have learned two basic leadership rules over the years:\nRule Number 1: If developers don’t know why you made a decision, they are less likely to agree with it.\nRule Number 2: If developers aren’t involved in a decision, they are less likely to follow it.\nKeep your developers involved. Collaborate by asking their opinions about a particular decision, involving them in a risk-storming exercise, or using the Request for Comment status in an ADR. Always justify your architectural decisions—and make sure everyone on the development team understands that justification.\nDivide and conquer\nIn the book The Art of War, the ancient Chinese warrior Sun Tzu advises, “If your enemy’s forces are united, separate them.” You can use this tactic when faced with all-or-nothing situations. Do all parts of the system need 400 ms response times or 99.999% availability? Dividing the problem into parts can help you identify what’s hard to achieve, which makes negotiation easier.\nKeep things simple, clear, and concise\nNothing helps an architect gain respect and trust better than being able to explain things in clear, concise terms. It makes you more approachable. People will want to ask you things and get you involved. We call this the “four Cs” of architecture—be Clear, be Concise, Communicate, and Collaborate. You need all four to become an effective software architect.\nBe available to your development team\nNothing is more frustrating for a developer or business stakeholder than having a critical question come up when you aren’t around to answer it. Make sure not to spread yourself too thin—be there for your team.\nBlocking out your calendar early in the morning or late in the afternoon is a great way to ensure you don’t get cooped up in meetings all day. Use that time to collaborate with your development team and be available to answer their questions. They’ll be grateful for it, and you will gain a lot of respect.\n#4 Diagramming techniques\nBack in Chapter 3, we discussed ADRs as the best way to document the analysis process that leads to a decision. Another common method architects use to document architecture is diagrams. Architecture diagrams illustrate many important details that team members benefit from visualizing, such as structure, topology, communication, dependencies, and integration points.\nThis topic can (and does) fill entire books. We’re just here to provide some quick tips to make your diagrams better, regardless of how you create them.\nKeep it simple\nDon’t try to create comprehensive architecture diagrams that include every detail. If you do, your diagrams will suffer from the “hairball effect”—becoming too complex and dense to understand.\nAlways include a title\nMost architecture diagrams represent a view or perspective, and your title should make yours explicit.\nUse unidirectional arrows to represent communication\nDouble-headed arrows are ambiguous. Did the author intend to indicate two-way communications, or is just that the default arrow?\nUsing unidirectional arrows removes all ambiguity and makes documentation more explicit.\nUse real labels, not acronyms\nOnly insiders understand acronyms. Spell things out whenever possible to avoid confusion and eliminate the need for extra documentation.\nUse solid lines for sync and dotted for async communication\nArchitects need a way to specify whether communication is synchronous (blocking) or asynchronous (nonblocking). A solid line is common shorthand for synchronous communication, and a dotted one represents the asynchronous alternative.\nUse consistent shapes and colors\nDon’t use arbitrary shapes to try to save room; consistent shapes and colors cut down on the visual “noise” created by needless inconsistency.\nKey\nEvent handler written and maintained by internal teamExternal system accessed through a standard APIAsynchronous callSynchronous callOperational database\nAlways include a key\nJust about the only universal shape in software diagrams is the database cylinder. Pretty much everything else is up for grabs. Don’t make your viewers guess! Adding an explicit key makes the diagram accessible to a broader audience, with less extra documentation.\n#5 Knowledge depth versus breadth\nAn unexpected thing happens to your brain when you become a software architect—the new role changes the kinds of things you seek out and learn. Consider this structure, which categorizes all the information in the world, as far as you know at the beginning of your career.\nAs you move along in your career from a junior software developer to a tech lead, the “stuff you know” grows—things like programming languages, frameworks, tools, and platforms. You’re also able to help and mentor other developers in this role.\nOver time, as you gather more expertise and become the go-to person, you start to grow the middle part of the pyramid—the “stuff you know you don’t know.” Because you’re maintaining your hardcore technical skills as well (the “stuff you know”), it takes a lot of effort to get to this point. Congratulations!\nYour technicaldepth consists of every topic on which you have expertise.\nRemaining an expert in any technology requires investing time to keep up with constant change. Thus, maintaining technical depth takes time.\nYour technicalbreadth includes the areas in which you have expertise, what you know about the existence of other solutions, and what you know about some of these solutions’ trade-offs. As an architect, knowing that there are five different ways to solve a problem is better than deeply knowing one way to solve it.\nNew architects’ knowledge pyramids start out looking like those of tech leads, but you should make an effort to broaden your experience base. If you have expertise in .NET, for example, see if you can do some work on a Java project, a user interface–heavy Javascript project, or a hard data architecture problem... you get the idea.\nOver time, your expertise will slowly fade a bit (which is extraordinarily painful), but this will have the benefit of increasing your breadth of knowledge. Remember, software architecture decisions are all about trade-offs.\n#6 Practicing architecture with katas\nThe legendary martial artist and actor Bruce Lee once said, “I fear not the man who has practiced 10,000 kicks once, but I fear the man who has practiced one kick 10,000 times.” So how do you attain that kind of proficiency with software architecture? Glad you asked! We recommend architectural katas.\nA kata is an individual form of exercise used in many martial arts to practice moves until they’re perfected. In the same spirit, architectural katas simulate the process of designing a real architecture.\nArchitectural katas are intended for several small groups of three to five people. Each group becomes a project team and works on a different kata. (We sometimes get two teams to do each kata, just to see what differences arise.) A moderator keeps track of time and facilitates the exercise.\nThe moderator assigns each group a project needing development. The team meets for a while, asking questions of the “customer” (the moderator) for clarification. They discuss technology options that could work and sketch out a rough vision of their solution. Then they present their solution to the other project teams and answer challenges (hard but fair questions). Choosing an overall winner is optional.\nThe key to getting better at software architecture is to practice it—even in a simulated exercise.\nNote\nDo we have your attention? Keep reading to find out more.\nHow to run katas\nKatas are meant to be an adaptable exercise, so follow the rules below when they make sense for your organization, context, and needs. Any questions not covered by these rules are the domain of the moderator.\nPreparation\nGather several teams of three to five people. (We prefer odd numbers, so disputes can be decided by a majority.) Generally, people who work together in the real world should not be on the same teams; this exercise stresses collaborating with other architects you don’t already know.\nGather supplies like poster paper or whiteboards. The artifacts you produce may be very low-tech, depending on the time, complexity, and resources you commit.\nSpeaking of time, a kata exercise could take as little as 45 minutes or last as long as several weeks!\nNote\nYour authors have done several katas for real companies that gave teams eight weeks to work out a solution.\nDiscussion\nThe teams get together and work through the exact process outlined in this book: analyzing architectural characteristics, determining logical components, choosing an architectural style, and documenting their decisions.\nAny technology is fair game, although you should honor reasonable constraints (you won’t have an unlimited budget or get to hire new developers). The focus is on architecture and trade-off analysis.\nPresentation\nEach team presents its solution and answers questions.\nWhen you are listening to another project team presenting, your job is to ask questions. Try to keep them constructive. Don’t focus on only the good parts of the solution or only the deficiencies. Strive for balanced feedback.\nDon’t worry. This isn’t goodbye.\nCongratulations on reading all the way to the end and doing all the exercises! Job well done.\nIn case you haven’t noticed, you’ve come a long way in this book—and your software architecture journey is just getting started. We’d like to suggest some next steps.\nFirst, point your browser to https://www.headfirstsoftwarearchitecture.com to learn what’s next! Then check out the books below","metadata":{"id":1764355136757614,"pageNumber":20,"bookId":1}},{"text":"Index\nA\nAccepted status (ADRs), Writing ADRs: What’s your status?\naccess control, Why should you make microservices smaller?\naccessibility, Cross-cutting architectural characteristics, Cross-cutting architectural characteristics, Characteristics Crossword\nactor/action approach to logical architecture, Actor/action approach, The entity trap\nADRs (architectural decision records), Architectural decision records (ADRs), Two Many Sneakers is a success, There are no right (or wrong) answers\nbenefits of, The benefits of ADRs\ncollaboration and, Writing ADRs: Considering the consequences\nConsequences section, Writing ADRs: Considering the consequences, Two Many Sneakers is a success, “Two Laws” Crossword, Step 4: Document your decision\nContext section, Writing ADRs: Establishing the context, Two Many Sneakers is a success\ncontext versus justification, Writing ADRs: Communicating the decision\nDecision section, Writing ADRs: Communicating the decision, Two Many Sneakers is a success, “Two Laws” Crossword\ndecision-capturing tools, Writing ADRs: Closing notes\ndocumentation and, Step 4: Document your decision\nediting, Writing ADRs: What’s your status?\nexercises, There are no right (or wrong) answers\nfile naming, Writing ADRs: Closing notes\nGovernance section, Writing ADRs: Ensuring governance, Two Many Sneakers is a success\nimmutability, Writing ADRs: What’s your status?\nmultiple projects, Writing ADRs: Closing notes\nNotes section, Writing ADRs: Ensuring governance, Two Many Sneakers is a success\nopinion and, Writing ADRs: Communicating the decision\nStatus section, Writing ADRs: What’s your status?\nstorage, Writing ADRs: Closing notes\nTitle section, Writing ADRs: Getting the title right, Two Many Sneakers is a success\nvisualization flowchart, Writing ADRs: What’s your status? (recap)\nafferent coupling (CA), Afferent coupling, Some final words about components\nmeasuring, Measuring coupling\nagility, Process architectural characteristics, What do we know so far?\narchitects, #1 The coding architect\ncoding architects, #1 The coding architect\ndevelopment team and, #3 The soft skills of architecture\nsoft skills, #3 The soft skills of architecture\narchitectural characteristics, The dimensions of software architecture, The first dimension: Architectural characteristics, You made it!\nabundance, Limit characteristics to prevent overengineering\naccessibility, Cross-cutting architectural characteristics, Cross-cutting architectural characteristics, Characteristics Crossword\narchitectural style and, Cubicle conversation\nauditability, What are architectural characteristics?\nbalancing, Balancing domain considerations and architectural characteristics\ncapabilities and, Architectural characteristics and logical components\ncategories, Limit characteristics to prevent overengineering\ncomposite, Composite architectural characteristics\nconsistency, What are architectural characteristics?\ncross-cutting, Cross-cutting architectural characteristics\ndata integrity, What are architectural characteristics?\ndefining, Defining architectural characteristics, Characteristics are nondomain design considerations\ndeployability, Cross-cutting architectural characteristics, Characteristics Crossword\ndomain requirements, Sourcing architectural characteristics from the problem domain\ndomains, What are architectural characteristics?\ndriving, There are no right (or wrong) answers\nexplicit, Consider explicit and implicit capabilities\nfrom environmental awareness and, Sourcing architectural characteristics from environmental awareness\nfrom holistic domain knowledge, Sourcing architectural characteristics from environmental awareness\nfrom problem domain, Sourcing architectural characteristics from the problem domain\nimplicit, Consider explicit and implicit capabilities, There are no right (or wrong) answers, Step 1: Identify architectural characteristics\nlimiting, Limit characteristics to prevent overengineering, Limiting architectural characteristics\nmaintainability, Cross-cutting architectural characteristics, Characteristics Crossword\nmodular monolithic architecture, Modular monolith kryptonite\nmodularity, Cross-cutting architectural characteristics, Characteristics Crossword\nnumbers, Balancing domain considerations and architectural characteristics\noperational, Operational architectural characteristics\noverengineering and, Limit characteristics to prevent overengineering\nplanning stages, The architects’ roadmap\npriorities, Priorities are contextual\nprivacy, Cross-cutting architectural characteristics\nprocess, Process architectural characteristics\nreliability, What are architectural characteristics?\nrobustness, Cross-cutting architectural characteristics, Characteristics Crossword\nscalability, What are architectural characteristics?, Cross-cutting architectural characteristics, Characteristics Crossword\nsecurity, What are architectural characteristics?\nsources, Cross-cutting architectural characteristics\nstructural, Structural architectural characteristics\nsynergy, Limit characteristics to prevent overengineering\nusability, What are architectural characteristics?, Cross-cutting architectural characteristics\nzoo metaphor, The International Zoo of “-ilities”\narchitectural decision records (ADRs) (see ADRs (architectural decision records))\narchitectural decisions, The dimensions of software architecture, The second dimension: Architectural decisions, You made it!, Two Many Sneakers is a success\n(see also ADRs (architectural decision records))\narchitecture/design spectrum, Strategic versus tactical\nas guides versus rules, Making an architectural decision\nexamples, Making an architectural decision\nplanning stages, The architects’ roadmap\nSecond Law of Software Architecture, The second law of software architecture\nstrategic, Is it strategic or tactical?\nstrategic versus tactical, Strategic versus tactical\ntactical, Is it strategic or tactical?\ntrade-offs, Is it strategic or tactical?, Significant versus less-significant trade-offs\nTwo Many Sneakers, What else makes a decision architectural?\nwhys, The second law of software architecture\narchitectural perspective, An architectural perspective\narchitectural styles, The dimensions of software architecture, The fourth dimension: Architectural styles, You made it!, There are lots of architectural styles\narchitectural characteristics and, Cubicle conversation\ndistributed (see distributed architectures)\nevent-driven architecture, The fourth dimension: Architectural styles\nhybrid, There are no right (or wrong) answers\nlayered architecture, The fourth dimension: Architectural styles\nlogical components and, Cubicle conversation\nmicrokernel, Step 3: Choose an architectural style\nmicroservices, The fourth dimension: Architectural styles, The world of architectural styles\nmonolithic (see monolithic architecture)\nplanning documentation, Step 4: Document your decision\nplanning stages, The architects’ roadmap\nselecting, The fourth dimension: Architectural styles, Step 3: Choose an architectural style, Step 3: Choose an architectural style\narchitecture, Building plans and software architecture\nbuilding plans, Building plans and software architecture\ndistributed, Characteristics influence architectural structure\ngardening exercise, Building your understanding of software architecture\nhouse, Building your understanding of software architecture\ninterconnectedness, Puzzling out the dimensions\nlogical versus physical, Logical versus physical architecture\nmonolithic, Characteristics influence architectural structure\nneed for, Building your understanding of software architecture\nplanning, Planning the architecture\nspectrum with design, The spectrum between architecture and design\nstructure, Building plans and software architecture\nversus design, The fourth dimension: Architectural styles\nArchitecture Tradeoff Analysis Method (ATAM), The first law of software architecture\nasynchronous communication, Asynchronous communication, Wrapping up\narchitecture style selection and, Step 3: Choose an architectural style\nbenefits, Asynchronous for the win\ndiagramming, #4 Diagramming techniques\nEDA and, Fire-and-forget\nversus synchronous communication, Fireside Chats\nATAM (Architecture Tradeoff Analysis Method), The first law of software architecture\nauthentication, Cross-cutting architectural characteristics\nauthorization, Cross-cutting architectural characteristics\nB\nbehavior of logical components, Architectural characteristics and logical components\nblueprints, Building plans and software architecture\nbroadcasting model, Communicating with downstream services\nbuilding plans, Building plans and software architecture\nC\ncapabilities, architectural characteristics, Architectural characteristics and logical components\nCBAM (Cost Benefit Analysis Method), The first law of software architecture\nchoreography, Choreography: Let’s dance\ngranularity and, Granularity integrators\ncode, #1 The coding architect\nproof-of-concept code, #1 The coding architect\nreviews, coding architects and, #1 The coding architect\nshared libraries, Code reuse with a shared service\nshared services, Code reuse with a shared service\nvolatility, microservices and, Why should you make microservices smaller?\ncode sharing, It’s all about balance\nmicroservices and, It’s all about balance\nshared libraries, Code reuse with a shared library\ncoding architects, #1 The coding architect\ncohesion, microservices and, Why should you make microservices smaller?\ncollaboration, ADRs and, Writing ADRs: Considering the consequences\ncommunications, EDA versus microservices, EDA versus microservices\ncompliance, Cross-cutting architectural characteristics\ncomponent coupling, The Bid Capture component, Some final words about components\n(see also logical components)\nafferent coupling (CA), Afferent coupling\nchoreography, Choreography: Let’s dance\nefferent coupling (CE), Efferent coupling, Some final words about components\nFirst Law of Software Architecture and, A balancing act\nLaw of Demeter and, Measuring coupling\nmeasuring, Measuring coupling\norchestration and, Orchestration: Conducting microservices\ntightly coupled systems, A tightly coupled system\ntotal coupling (CT), Measuring coupling\ncomposite architectural characteristics, Composite architectural characteristics\nCost Benefit Analysis Method (CBAM), The first law of software architecture\ncross-cutting requirements, Cross-cutting architectural characteristics\nD\ndata coupling, Why should you make microservices bigger?\ndata dependencies, Granularity integrators\ndata ownership, It’s my data, not yours\nDatabase layer, Layering MVC\ndatabase-per-service pattern, Database-per-service, Wrapping up\ndatabases, Step 5: Diagram your architecture\ndiagramming, Step 5: Diagram your architecture\ndomain-partitioned, Wrapping up\nEDAs, Event-driven architecture kryptonite\nforeign keys, Why should you make microservices bigger?\nmodular monolithic architecture, Taking modularity all the way to the database\ntopologies, Database topologies, Wrapping up\ntransactions, granularity and, Granularity integrators\nDDD (domain-driven design), The entity trap\ndeployability, Process architectural characteristics, Cross-cutting architectural characteristics, Characteristics Crossword\nlayered architecture, Layered architecture kryptonite\nmicroservices architecture, Microservices architecture superpowers\ndeployment models, The world of architectural styles, And that’s a wrap!\ndistributed systems, Monolithic deployment models: The pros\nmonolithic architectures, Monolithic deployment models: The pros\npros and cons, Monolithic deployment models: The pros, Monolithic deployment models: The pros, Distributed deployment models: The pros\nderived events, Events versus messages, Wrapping up\ndesign, The spectrum between architecture and design\nspectrum with architecture, The spectrum between architecture and design\nversus architecture, The fourth dimension: Architectural styles\ndesign perspective, A design perspective\ndevice-assessment service core, Device assessment service core\ndiagramming, #4 Diagramming techniques\nasynchronous communications, #4 Diagramming techniques\ncommunications, #4 Diagramming techniques\nkey, #4 Diagramming techniques\nlabels, #4 Diagramming techniques\nmicroservices architecture, There are no right (or wrong) answers!\nphysical architecture, Step 5: Diagram your architecture\nphysical architecture key, Step 5: Diagram your architecture\nshapes and colors, consistency, #4 Diagramming techniques\ntitle, #4 Diagramming techniques\ndimensions, The dimensions of software architecture, The fourth dimension: Architectural styles\ndistributed architectures, Characteristics influence architectural structure, Deployment model: Monolithic versus distributed, And that’s a wrap!\ndeployment models, Monolithic deployment models: The pros\npros and cons, Monolithic deployment models: The pros, Distributed deployment models: The pros\nrelevance, Distributed deployment models: The cons\ndistributed physical architecture, Device assessment service core\nplugins, Device assessment service core\npros and cons, Microkernel Crossword\ndistributed plugins, Encapsulated versus distributed plugins\ncalls, Plugin communication\ndocumentation, Step 4: Document your decision\ndomain-based alignment, Modular monolith superpowers\ndomain-driven design (DDD), The entity trap\ndomain-partitioned architecture, Partitioning: Technical versus domain\ndomain-partitioned databases, Domain-partitioned databases, Wrapping up\ndomains, The third dimension: Logical components\ncharacteristics, Characteristics are nondomain design considerations\nholistic domain knowledge, Sourcing architectural characteristics from environmental awareness\nmodular monoliths, Modular monolith superpowers\npartitioning, Modular monolith superpowers\nsubdomains, Naan & Pop is delivering pizza!\ndriving characteristics, There are no right (or wrong) answers!\nimplicit characteristics, There are no right (or wrong) answers\nE\nEclipse IDE, The spectrum of “microkern-ality”\nEDA (event-driven architecture), The fourth dimension: Architectural styles, Speeding things up\nanalysis, There are no right (or wrong) answers!\nasynchronous communication, Asynchronous communication, Fire-and-forget, Wrapping up\ncomplexity, Event-driven architecture kryptonite\ndatabases, Event-driven architecture kryptonite\ndrawbacks, Event-driven architecture kryptonite\nevents, What is an event?, Wrapping up\nevolvability, Event-driven architecture superpowers\nextensibility, Events versus messages\nfault tolerance, Event-driven architecture superpowers\nmaintainability, Event-driven architecture superpowers\nmessages, events, What is an event?\nNotification Analytics, Events versus messages\nperformance, Event-driven architecture superpowers\nscalability, Event-driven architecture superpowers\nstar ratings, Layered architecture star ratings, Event-driven architecture star ratings\nsuperpowers, Event-driven architecture superpowers\nsynchronous calls, Event-driven architecture kryptonite\ntestability, Event-driven architecture kryptonite\nversus microservices, EDA versus microservices, Step 3: Choose an architectural style\nefferent coupling (CE), Efferent coupling, Some final words about components\nmeasuring, Measuring coupling\nelasticity, layered architecture, Layered architecture kryptonite\nelectronics recycling program, Step 2: Assign requirements\nembedded/mobile architecture, Layers, meet the real world: Physical architectures\nencapsulated plugins, Encapsulated versus distributed plugins\nencryption, Cross-cutting architectural characteristics\nentity trap, The entity trap\nenvironmental awareness, Sourcing architectural characteristics from environmental awareness\nerror handling, Choreography: Let’s dance\nchoreography, Choreography: Let’s dance\norchestration and, Orchestration: Conducting microservices\nevent processing, Wrapping up\nEDA versus microservices, EDA versus microservices\nevent storming, The entity trap\nevent-driven architecture (EDA) (see EDA (event-driven architecture)\nevent-driven microservices, Hybrids: Event-driven microservices\nevents, Events versus messages\ncompared to messages, Events versus messages, Wrapping up\nderived events, Events versus messages, Wrapping up\ninitiating events, Events versus messages, Wrapping up\nevolvability, Event-driven architecture superpowers\nEDAs, Event-driven architecture superpowers\nmicroservices architecture, Microservices architecture superpowers\nexplicit architectural characteristics, Consider explicit and implicit capabilities\nextensibility, Process architectural characteristics, Structural architectural characteristics, Wrapping up\nEDAs, Events versus messages\nF\nfault tolerance, Event-driven architecture superpowers\nEDAs, Event-driven architecture superpowers\nmicroservices and, Why should you make microservices smaller?\nmicroservices architecture, Microservices architecture superpowers\nfile naming, ADRs, Writing ADRs: Closing notes\nfire-and-forget, Wrapping up\n(see also asynchronous communication)\nFirst Law of Software Architecture, The first law of software architecture, Two Many Sneakers is a success\ncomponent coupling and, A balancing act\nlayered architecture and, One final caveat about domain changes\nforeign keys, Why should you make microservices bigger?\nFowler, Martin, High versus low levels of effort\nFront Controller pattern, Choreography: Let’s dance\nG\nGrains of Sand pattern, How micro is “micro”?\ngranularity, microservices, How micro is “micro”?, Wrapping it up\nbalance, It’s all about balance, Wrapping it up\ndisintegrators, How micro is “micro”?, It’s all about balance\nintegrators, Granularity integrators, Wrapping it up\nH\nheterogeneous, Trade-off analysis: Queue edition\nhouse architecture, Building your understanding of software architecture\nhybrid architecture, There are no right (or wrong) answers, There are no right (or wrong) answers!\nevent-driven microservices, Hybrids: Event-driven microservices, Wrapping up\nI\nimplicit characteristics, Consider explicit and implicit capabilities, Step 1: Identify architectural characteristics\ndriving characteristics, There are no right (or wrong) answers, There are no right (or wrong) answers!\ninfrastructure, queues and, Writing ADRs: Considering the consequences\ninitiating events, Events versus messages, Wrapping up\ninventory management, Putting it all together, Logical components revisited\niterative approach, Cubicle conversation\nJ\nJenkins (continuous integration), The spectrum of “microkern-ality”\njoins between databases, Beware of joins\nJPMS (Java Platform Module System), Keeping modules modular (last time!)\nK\nkatas, #6 Practicing architecture with katas\nknowledge pyramid, #5 Knowledge depth versus breadth\nL\nLaw of Demeter, Measuring coupling, Some final words about components\nlayered architecture, The fourth dimension: Architectural styles\ncapabilities, sorting by, Domains, components, and layers\ncomponent placement, Domains, components, and layers\ncomponents, Layering it on\ndata-intensiveness, Layered architecture superpowers\nDatabase layer, Layering MVC\ndeployability, Layered architecture kryptonite\ndiagramming layers, Step 5: Diagram your architecture\ndomain changes, One final caveat about domain changes\ndownsides, Layered architecture kryptonite\nease of reuse, Drivers for layered architecture\nelasticity, Layered architecture kryptonite\nfeasibility, Layered architecture superpowers\nFirst Law of Software Architecture, One final caveat about domain changes\nMVC and, Design patterns redux, Drivers for layered architecture\nnamespaces, Layering it on\npackages, Layering it on\nperformance, Layered architecture superpowers\nPersistence layer, Layering MVC\nphysical architecture, Drivers for layered architecture\nPresentation layer, Layering MVC\nquick builds, Layered architecture superpowers\nreasons for layers, Cubicle conversation\nscalability, Layered architecture kryptonite\nspecialization, Drivers for layered architecture\ntechnically partitioned, Translating layers into code, Layered architecture superpowers\ntestability, Layered architecture kryptonite\nWorkflow layer, Layering MVC\nlayered monolithic architecture, There are no right (or wrong) answers\nanalysis, There are no right (or wrong) answers\nplanning stage, Step 3: Choose an architectural style\nuses, There are no right (or wrong) answers\nlibraries, shared, Code reuse with a shared library, Fireside Chats, Wrapping it up, Microservices Crossword\nlinters, The spectrum of “microkern-ality”\nlocalization, Structural architectural characteristics\nlogical architecture, Actor/action approach\nactor/action approach, Actor/action approach, The entity trap\nassigning requirements, Step 2: Assign requirements\ncharacteristics analysis, Step 4: Analyze characteristics\ncohesion, Sticking to cohesion\ncomponents, Logical versus physical architecture, Step 1: Identifying initial core components, The Bid Capture component\ncreating, Creating a logical architecture\nentity trap, The entity trap\nroles and responsibilities, Step 3: Analyze roles and responsibilities\nversus physical architecture, Logical versus physical architecture, Logical Components Crossword\nworkflow approach, Workflow approach, The entity trap\nlogical component system, Defining architectural characteristics\nlogical components, The dimensions of software architecture, The third dimension: Logical components, You made it!, Some final words about components\nafferent coupling (CA), Afferent coupling\narchitectural style and, Cubicle conversation\nbehavior and, Architectural characteristics and logical components\ncharacteristics analysis, Step 4: Analyze characteristics\ncohesion, Sticking to cohesion\ncomponent coupling, The Bid Capture component\ndesign and, Defining architectural characteristics\nefferent coupling (CE), Efferent coupling\nentity trap and, The entity trap, Some final words about components\nidentifying, Step 2: Identify logical components, Step 2: Identify logical components\nmeasuring, Measuring coupling\nmonolithic architectures, Deployment model: Monolithic versus distributed\nnames, The entity trap\nplanning stages, The architects’ roadmap\nrequirements, Step 2: Assign requirements\nroles and responsibilities, The third dimension: Logical components\nsource code repository directory, Logical components revisited\nsplitting by capability, Domains, components, and layers\nM\nmaintainability, Structural architectural characteristics, Cross-cutting architectural characteristics, Characteristics Crossword\nEDAs, Event-driven architecture superpowers\nmicroservices architecture, Microservices architecture superpowers\nmicrokernel architecture, Microkernel superpowers\nadaptability, Microkernel superpowers\nanalysis, There are no right (or wrong) answers\ncore, The two parts of microkernel architectures\nDecorator design pattern, Cubicle conversation\ndevice-assessment service core, Device assessment service core\ndistributed, Encapsulated versus distributed plugins\ndistributed physical architecture, Device assessment service core, Microkernel Crossword\ndrawbacks, Microkernel kryptonite\nEclipse IDE, The spectrum of “microkern-ality”\nevolvability, Microkernel superpowers\ninsurance application, The spectrum of “microkern-ality”\nJenkins Continuous Integration (CI) tool, The spectrum of “microkern-ality”\nlinters, The spectrum of “microkern-ality”\nmonoliths, Device assessment service core, Encapsulated versus distributed plugins, Wrapping it up, Microkernel Crossword\npartitions, Microkernel superpowers\nperformance, Microkernel kryptonite\nplanning stages, Step 3: Choose an architectural style\nplugins, The two parts of microkernel architectures, Encapsulated versus distributed plugins, Microkernel kryptonite\nsimplicity, Microkernel superpowers\nstar ratings, Microkernel star ratings\nsynchronous communication, Device assessment service core\nuser interface, Cubicle conversation\nuses, There are no right (or wrong) answers, There are no right (or wrong) answers\nvolatility, Microkernel kryptonite\nweb browsers, The spectrum of “microkern-ality”\nmicroservices, The world of architectural styles\ndefined, Wrapping it up\nevent-driven microservices, Hybrids: Event-driven microservices, Wrapping up\nversus EDA, EDA versus microservices\nmicroservices architecture, The fourth dimension: Architectural styles\nanalysis, There are no right (or wrong) answers!\nbalance, It’s all about balance, Wrapping it up\nchoreography, Choreography: Let’s dance, Microservices Crossword\ncode sharing, It’s all about balance\ncommon functionality, It’s all about balance\ncomplexity, Microservices architecture kryptonite\ndata ownership, It’s my data, not yours\ndeployability, Microservices architecture superpowers\ndiagramming, There are no right (or wrong) answers!\ndrawbacks, Microservices architecture kryptonite\nevolvability, Microservices architecture superpowers\nfault tolerance, Microservices architecture superpowers\nGrains of Sand pattern, How micro is “micro”?\ngranularity, How micro is “micro”?, Wrapping it up\ngranularity disintegrators, How micro is “micro”?, Wrapping it up\ngranularity integrators, Granularity integrators, Wrapping it up\nmaintainability, Microservices architecture superpowers\nmonolithic databases, Microservices architecture kryptonite\norchestration, Orchestration: Conducting microservices, Wrapping it up, Microservices Crossword\nperformance, Microservices architecture kryptonite\nphysical bounded contexts, It’s my data, not yours\nreasons to use, Cubicle conversation\nscalability, Microservices architecture superpowers\nservices, What’s a microservice?, How micro is “micro”?, It’s all about balance\nstar ratings, Microservices star ratings\nsuperpowers, Microservices architecture superpowers\ntechnically partitioned teams, Microservices architecture kryptonite\ntestability, Microservices architecture superpowers\nversus EDA, Step 3: Choose an architectural style\nworkflow, Fireside Chats, Microservices architecture kryptonite, Wrapping it up\nmodular monolithic architecture, Modular monolith?, Modular monolith?, Naan & Pop is delivering pizza!\nanalysis, There are no right (or wrong) answers\narchitectural characteristics, Modular monolith kryptonite\ndatabases, Taking modularity all the way to the database\ndomain changes and, Why modular monoliths?\ndomain partitioning, Modular monolith superpowers\ndomain-based alignment, Modular monolith superpowers\ndrawbacks, Modular monolith kryptonite\nintermodule communication, Naan & Pop is delivering pizza!\nmaintainability, Modular monolith superpowers\nmaintaining modularity, Keeping modules modular\nmodularity fragility, Modular monolith kryptonite\nnamespaces, Show me the code!\noperational characteristics, Modular monolith kryptonite\npartitioning by technical concerns, Modular monolith?\nperformance, Modular monolith superpowers\nplanning stages, Step 3: Choose an architectural style\nreasons to use, Why modular monoliths?\nreuse in, Modular monolith kryptonite\nstar ratings, Modular monolith star ratings\ntestability, Modular monolith superpowers\nuses, There are no right (or wrong) answers, There are no right (or wrong) answers\nmodularity, Process architectural characteristics, Cross-cutting architectural characteristics, Characteristics Crossword\nmonolithic architecture, Characteristics influence architectural structure, The world of architectural styles, Deployment model: Monolithic versus distributed, And that’s a wrap!, Wrapping it up\nanalysis, There are no right (or wrong) answers, There are no right (or wrong) answers\ndeployment models, Monolithic deployment models: The pros\nlayered, Step 3: Choose an architectural style, There are no right (or wrong) answers, There are no right (or wrong) answers\nmicrokernel architecture, Device assessment service core, Microkernel Crossword\nmodular (see modular monolithic architecture)\nrelevance, Distributed deployment models: The cons\nsmartphone as, Deployment model: Monolithic versus distributed\nmonolithic databases, Microservices architecture kryptonite, Monolithic database, Wrapping up\nMVC (Model-View-Controller) pattern, Design patterns redux, Translating layers into code, Drivers for layered architecture\nN\nnamespaces, Layering it on\nmodular monolithic architecture, Show me the code!\nnon-domain design, Characteristics are nondomain design considerations\nnonfunctional requirements, Cubicle conversation, Cross-cutting architectural characteristics\nnotifications, Trade-off analysis: Queue edition\ntrade-off analysis, Trade-off analysis: Queue edition\nTwo Many Sneakers, It starts with a sneaker app\nO\noperational architectural characteristics, Operational architectural characteristics\norchestration, Orchestration: Conducting microservices, Wrapping it up\noutages, #1 The coding architect\noverengineering, Limit characteristics to prevent overengineering\nP\npackages, Layering it on\npartitioned architecture, Partitioning: Technical versus domain\ndomain-partitioned, Partitioning: Technical versus domain\ntechnically partitioned, Partitioning: Technical versus domain\npartitioning, The world of architectural styles, And that’s a wrap!\nmicrokernel architecture, The two parts of microkernel architectures, Microkernel superpowers\nmodular monolithic architecture, Modular monolith?, Modular monolith superpowers\nmodules, Modular monolith?\ntechnically partitioned teams, Microservices architecture kryptonite\nperformance, The first dimension: Architectural characteristics, Operational architectural characteristics\nEDA versus microservices, EDA versus microservices\nEDAs, Event-driven architecture superpowers\norchestration and, Orchestration: Conducting microservices\nPersistence layer, Layering MVC, Translating layers into code\nphysical architecture, Logical versus physical architecture\ncomponents, Logical versus physical architecture\ndiagramming, Step 5: Diagram your architecture, Step 5: Diagram your architecture\ndistributed, Device assessment service core\nembedded/mobile, Layers, meet the real world: Physical architectures\npros and cons, Microkernel Crossword\ntiered, Layers, meet the real world: Physical architectures\nversus logical architecture, Logical versus physical architecture, Logical Components Crossword\nphysical bounded context, EDA versus microservices\nEDA versus microservices, EDA versus microservices\nmicroservices, It’s my data, not yours, Wrapping it up\nplanning architecture, Planning the architecture\narchitectural characteristics, The architects’ roadmap\narchitectural decisions, The architects’ roadmap\narchitectural style, The architects’ roadmap\nlogical components, The architects’ roadmap\nstakeholders input, There are no right (or wrong) answers\nplugins, Device assessment service core\nas components, Device assessment service core\ncalling, Plugin communication\ncommunication, Plugin communication, Microkernel kryptonite\ncontracts, Plugin contracts\ndesign, Wrapping it up\ndistributed, Encapsulated versus distributed plugins\nencapsulated, Encapsulated versus distributed plugins\nimplementing, Device assessment service core\nsharing between, Microkernel kryptonite\nportability, Structural architectural characteristics\nPresentation layer, Layering MVC, Translating layers into code\npriorities, Priorities are contextual\nprivacy, Cross-cutting architectural characteristics\nprocess architectural characteristics, Process architectural characteristics\nproof-of-concept code, #1 The coding architect\nProposed status (ADRs), Writing ADRs: What’s your status?\nQ\nqueues, Communicating with downstream services\n(see also messages; topics)\ninfrastructure and, Writing ADRs: Considering the consequences\nsecurity and, The first law of software architecture\ntrade-off analysis, Trade-off analysis: Queue edition\nR\nRDD (resume-driven development), Limit characteristics to prevent overengineering\nrecoverability, Operational architectural characteristics\nchoreography and, Choreography: Let’s dance\nreliability/safety, Operational architectural characteristics\nrequest for comment (RFC), Writing ADRs: What’s your status?\nrequest processing, EDA versus microservices\nrequirements, Causing Lafter\ndocuments, Causing Lafter, Making travel easier, Step 1: Identify architectural characteristics, Are you feeling okay?, Welcome to Make the Grade\ninterpreting/translating, Lost in translation\nnon-functional, Cubicle conversation\nversus solutions, Sourcing architectural characteristics from holistic domain knowledge\nresume-driven development (RDD), Limit characteristics to prevent overengineering\nreturn on investment (ROI), The first law of software architecture\nRFC (request for comment), Writing ADRs: What’s your status?\nroadmap for planning, The architects’ roadmap\nrobustness, Operational architectural characteristics, Cross-cutting architectural characteristics, Characteristics Crossword\nROI (return on investment), The first law of software architecture\nS\nscalability, The dimensions of software architecture, The first dimension: Architectural characteristics, Operational architectural characteristics, Cross-cutting architectural characteristics, Characteristics Crossword\nchoreography, Choreography: Let’s dance\nEDAs, Event-driven architecture superpowers\nlayered architecture, Layered architecture kryptonite\nmicroservices and, Why should you make microservices smaller?, Microservices architecture superpowers\norchestration and, Orchestration: Conducting microservices\nSecond Law of Software Architecture, The second law of software architecture, Two Many Sneakers is a success\nsecurity, Structural architectural characteristics, Cross-cutting architectural characteristics\nimplicit characteristic, Consider explicit and implicit capabilities\nqueues and, The first law of software architecture\nservice granularity, microservices versus EDA, EDA versus microservices\nshared code, granularity and, Granularity integrators\nshared libraries, Fireside Chats, Wrapping it up, Microservices Crossword\ncode sharing, Code reuse with a shared library\nshared services, Fireside Chats, Wrapping it up, Microservices Crossword\ncode reuse, Code reuse with a shared service\nsingle-purpose, What’s a microservice?\nsmartphone as monolith, Deployment model: Monolithic versus distributed\nsoft skills for architects, #3 The soft skills of architecture\nsolutions versus requirements, Sourcing architectural characteristics from holistic domain knowledge\nsource code repository, Logical components revisited\nSQL (Structured Query Language) joins, Beware of joins\nstakeholders, There are no right (or wrong) answers\nplanning stages and, There are no right (or wrong) answers\nrequirements documents, Causing Lafter\nstandardization, characteristics and, Limit characteristics to prevent overengineering\nstate management, choreography and, Choreography: Let’s dance\nstrategic decisions, Is it strategic or tactical?\nstructural architectural characteristics, Structural architectural characteristics\nstructural design, Characteristics are nondomain design considerations\ndomain considerations, Characteristics are nondomain design considerations\ninternal, Consider explicit and implicit capabilities\nnon-domain considerations, Characteristics are nondomain design considerations\nSuperseded status (ADRs), Writing ADRs: What’s your status?\nsynchronous calls, EDAs, Event-driven architecture kryptonite\nsynchronous communication, Step 3: Choose an architectural style\narchitecture style selection and, Step 3: Choose an architectural style\nbenefits, Synchronous for the win\nversus asynchronous communication, Fireside Chats\nsystem functionality, The third dimension: Logical components\nsystem quality attributes, Cross-cutting architectural characteristics\nT\ntactical decisions, Is it strategic or tactical?\ntechnical debt, coding architect and, #1 The coding architect\ntechnical depth of knowledge, #5 Knowledge depth versus breadth\ntechnically-partitioned architecture, Partitioning: Technical versus domain, And that’s a wrap!\ntestability, The dimensions of software architecture, Process architectural characteristics\nEDAs, Event-driven architecture kryptonite\nlayered architecture, Layered architecture kryptonite\nmicroservices architecture, Microservices architecture superpowers\nmodular monoliths, Modular monolith superpowers\nthree-tier architectures, Layers, meet the real world: Physical architectures\ntightly coupled systems, A tightly coupled system\ntopics, Communicating with downstream services\n(see also events; messages; queues)\ntrade-off analysis, Trade-off analysis: Topic edition\ntopologies, Wrapping up\ndatabase-per-service, Database-per-service\ndatabases, Wrapping up\ndomain-partitioned, Domain-partitioned databases\nmonolithic, Monolithic database\ntrade-off analysis, Two Many Sneakers is a success\narchitectural decisions, Two Many Sneakers is a success\nATAM (Architecture Tradeoff Analysis Method), The first law of software architecture\nEDA (event-driven architecture), Event-driven architecture kryptonite\nFirst Law of Software Architecture, The first law of software architecture\nlayered architecture, Layered architecture kryptonite\nmicrokernel architecture, Microkernel kryptonite\nmicroservices architecture, Microservices architecture kryptonite\nmodular monolithic architecture, Modular monolith kryptonite\nqueues, Trade-off analysis: Queue edition\nselections and, Analyzing trade-offs\ntopics, Trade-off analysis: Topic edition\ntranslating/interpreting requirements, Lost in translation\ntwo-tier architectures, Layers, meet the real world: Physical architectures\nU\nUML (Unified Modeling Language) class diagram, A design perspective\nunknown unknowns, What do we know so far?\nusability, Cross-cutting architectural characteristics\nuser interface, Design patterns redux\n(see also MVC (Model-View-Controller) pattern)\ndiagramming, Step 5: Diagram your architecture\nfield arrangement, High versus low levels of effort\nintegration, Step 1: Identify architectural characteristics\nmicrokernel architecture, Cubicle conversation\npublic-facing, The benefits of Going Green\nrequests and, Layering MVC\nscalability and, Sourcing architectural characteristics from the problem domain\nUI layer, Translating layers into code\nV\nversion-control system, Writing ADRs: Closing notes\nW\nwhiteboards, What else makes a decision architectural?, Writing ADRs: Establishing the context\nwikis, Writing ADRs: Closing notes\nworkflow, Microservices architecture kryptonite\namount, Microservices architecture kryptonite\nanalysis, TripEZ’s user workflow\ngranularity and, Granularity integrators\nmanagement, Fireside Chats\norchestration and, Orchestration: Conducting microservices\nworkflow approach to logical architecture, Workflow approach, Some final words about components\nactor/action approach and, The entity trap\nWorkflow layer, Layering MVC, Translating layers into code","metadata":{"id":6822662515643779,"pageNumber":21,"bookId":1}}]